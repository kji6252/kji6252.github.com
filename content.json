{"meta":{"title":"종인의 기술 블로그","subtitle":"Jongin's Home","description":"A blog of Jongin","author":"Jongin Kim","url":"http://kji6252.github.io"},"pages":[{"title":"김종인 소개","date":"2018-07-09T13:07:23.000Z","updated":"2021-04-02T02:38:07.052Z","comments":true,"path":"about/index.html","permalink":"http://kji6252.github.io/about/index.html","excerpt":"","text":"인적 사항이름; 김종인나이; 90년생경력; 2014년 11월 ~ Java 언어로 프로그래밍에 입문 했으며 Ahea 스터디 모임을 통해 꾸준히 성장 하고 있습니다. Program language Java, Spring, Javascript, jQuery, Python, Node.js 스터디 활동자바 스터디 모임 Ahea에서 2013년 부터 시작 하였으며 대학생 오픈소스 경진대회 (Naver D2 fest) 본선 진출 해커톤 총 4회 진행 공개 세미나 총 2회 하였고, 공개 세미나 에서는 Java ORM 매핑 방법, Server와 TIME_WAIT 소켓 상태에 따른 성능 튜닝 주제로 발표를 진행 했었습니다. Java ORM 매핑 방법 : Java에서 ORM정보를 가져 올때 Reflection API와 Java Bean 규약에 맞춰서 개발한 내용을 발표 Server와 TIME_WAIT 소켓 상태에 따른 성능 튜닝 : Server에서 Web Service 구성시에 나타나는 TIME_WAIT상태의 Socket을 튜닝 하는 방법 발표 했었습니다. 경력KTB투자증권 2017년 6월 ~ 2018년 7월Python flask를 이용한 json데이터 처리, Node.js Loopback Framwork API서버 유지 보수, 블룸버그단말기 시세 데이터 가공 및 전송, 방화벽 로그 검색을 위한 ELK 구축 팍스넷 2014년 11월 ~ 2017년 6월팍스넷 커뮤니티 Java Webservice 유지 보수, 실전투자대회 프론트/백 추가 개발 및 운영, 팍스넷 차세대 커뮤니티 Spring으로 개발 프로젝트장외 파생 프론트 오피스 구축 지원 2017년 6월 ~ 2018년 6월사용언어 및 기술 : Python(flask), Node.js(Loopback) 업무내용 flask를 사용하여 프론트오피스 JSON데이터를 백오피스로 전송 블룸버그 터미널 API를 이용한 시세 데이터 배치 프로그램 작성 장외 파생 상품 이해 및 시세 데이터 매핑 Loopback API Gateway Server 유지 보수 방화벽 로그 검색 시스템 구축 2018년 1월 ~ 2018년 3월사용언어 및 기술 : Elasticsearch, Kibana, Logstash, Filebeat, Kafka 업무내용 방화벽 로그 수집을 위한 FileBeat 셋팅 log의 정형화를 위한 Logstash GROK패턴 적용https://drive.google.com/drive/folders/1DDraVQd173sW-pDpg71Q2DtiR4F2L53M?usp=sharing 팍스넷 커뮤니티 개발 2016년 10월 ~ 2017년 6월사용언어 및 기술 : Java, Spring, jsp, jQuery, Javascript, Tomcat, Mybatis, Oracle, Linux 업무내용 팍스넷 사이트 개편과 함께 신규 기획된 게시판 오픈 소스 WYSIWYG에디터Summernote 적용 및 추가 플러그인 개발 종목차트 삽입을 위한 jQuery live fillter 적용 설문 기능 개발 링크 미리보기 개발(오픈 그래프 프로토콜) http://zzong.net/post/6 Ehcache(애플리케이션 설정값, 재기동시 파일캐시 로딩, P2P 캐시 동기화 설정), Redis(조회수및 댓글수) 적용 증권사 실전투자대회 2015년 3월 ~ 2017년 6월사용언어 및 기술 : Java, JPA, jsp, jQuery, Javascript, Weblogic, Linux 업무내용 증권사에서 고객 예수금,잔고,거래내역,수수료 등의 파일을 받아서 계산하는 프로그램성과개발환경 : 젠킨스 구축, maven으로 설정엔진 : 자바 Concurrent 적용으로 인한 실행시간 70% 감축 파일 원장 처리 프로그램 리펙토링(리플렉션 적용 및 JPA 적용 유지보수시간 대폭 감소)웹 : jquery 플러그인 사용(live filter,tablesorter, date fomat 등) 일별 차트 google chart, baidu echart2.0 적용 팍스넷 커뮤니티 운영 2014년 11월 ~ 2017년 4월사용언어 및 기술 : Java, JSP, jQuery, Javascript, Weblogic, Oracle, EJB, Ant 업무내용 게시판, 블로그, 카페 버그 수정 및 추가 기능 개발 댓글 페이징 개발 반응형 웹페이지 개발 어드민 페이지를 통한 게시판 내 서비스 요소 개발"}],"posts":[{"title":"Spring Boot + Spring Cloud 를 경험 하자","slug":"Spring-Boot-+-Spring-Cloud-를-경험-하자","date":"2020-06-06T05:00:00.000Z","updated":"2021-04-04T09:51:50.211Z","comments":true,"path":"2020/06/06/Spring-Boot-+-Spring-Cloud-를-경험-하자/","link":"","permalink":"http://kji6252.github.io/2020/06/06/Spring-Boot-+-Spring-Cloud-를-경험-하자/","excerpt":"Spring Boot + Spring Cloud 를 경험 하자Spring 에서 제공 해주는 MSA 환경 구축 가이드를 경험하여 실력을 향상해 보자! https://spring.io/guides","text":"Spring Boot + Spring Cloud 를 경험 하자Spring 에서 제공 해주는 MSA 환경 구축 가이드를 경험하여 실력을 향상해 보자! https://spring.io/guides Service Registration and Discovery Learn how to register and find services with Eureka Centralized Configuration Learn how to manage application settings from an external, centralized source Routing and Filtering Learn how to route and filter requests to a microservice using Netflix Zuul Circuit Breaker Learn how to degrade gracefully services using Hystrix Client Side Load Balancing with Ribbon and Spring Cloud Dynamically support services coming up and going down without interrupting the client 5가지 가이드를 학습하여 차례대로 Spring Cloud를 경험해 보자 스프링에서 제공하는 가이드를 학습하면서 github에 commit별로 정리 하였습니다. 학습하다가 막힐 경우 commit내역을 참고 하면서 학습 하시길 바랍니다. 각 단계를 실시한 후 확인하기 위해 http/check-config.http로 확인 하였습니다. https://github.com/kji6252/study-spring-cloud 1.Service Registration and Discovery가이드대로 진행 한 후 eureka baseurl을 넣어 대비하는게 좋을거 같다 12345#discovery client의 application.yml에 추가eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 2.Centralized ConfigurationEureka Server와 충돌을 피하기 위해 spring.cloud.config.server.prefix=/config를 추가 1spring.cloud.config.server.prefix=/config 12345# study-springboot-eureka/config/example-app.properties 에 추가 한 뒤# cd study-springboot-eureka/config/# git init &amp;&amp; git add. &amp;&amp; git commit 하기message=Remote Config! 3.Routing and Filtering4.Circuit Breakerstudy-springboot-discoveryclient를 stop 한 후에 실행하면 hystrixcommand에 명시된 fallback을 실행 5.Client Side Load Balancing with Ribbon and Spring Cloudribbon은 더이상 관리하지 않으므로 Spring Cloud Load Balancer로 예제가 바뀜 https://spring.io/guides/gs/spring-cloud-loadbalancer/ eureka와 통합하여 service discovery부분을 생략함","categories":[{"name":"Spring","slug":"Spring","permalink":"http://kji6252.github.io/categories/Spring/"}],"tags":[{"name":"Java, Spring, Spring Boot, Spring Cloud","slug":"Java-Spring-Spring-Boot-Spring-Cloud","permalink":"http://kji6252.github.io/tags/Java-Spring-Spring-Boot-Spring-Cloud/"}]},{"title":"PC에서 안드로이드폰 크롬 디버깅 하기","slug":"PC에서-안드로이드폰-크롬-디버깅-하기","date":"2018-12-27T04:00:43.000Z","updated":"2021-04-02T02:38:07.046Z","comments":true,"path":"2018/12/27/PC에서-안드로이드폰-크롬-디버깅-하기/","link":"","permalink":"http://kji6252.github.io/2018/12/27/PC에서-안드로이드폰-크롬-디버깅-하기/","excerpt":"개요평소 Web개발을 하시는 분들은 빠른 속도와 편리한 도구들이 많은 Chrome devtools를 이용하여 개발 하게 됩니다. 그중 모바일 페이지를 개발 할때 우리는 2가지 방법을 사용하게 됩니다. devtools &gt; Toggle device Toolbar 크롬 확장 프로그램 User-Agent Swicher 위에 소개 된 방식 이외에도 devtools &gt; Remote devicese를 사용 하면 자신의 안드로이드폰의 크롬App을 PC에서 디버깅을 할 수 있습니다.","text":"개요평소 Web개발을 하시는 분들은 빠른 속도와 편리한 도구들이 많은 Chrome devtools를 이용하여 개발 하게 됩니다. 그중 모바일 페이지를 개발 할때 우리는 2가지 방법을 사용하게 됩니다. devtools &gt; Toggle device Toolbar 크롬 확장 프로그램 User-Agent Swicher 위에 소개 된 방식 이외에도 devtools &gt; Remote devicese를 사용 하면 자신의 안드로이드폰의 크롬App을 PC에서 디버깅을 할 수 있습니다. 준비 할것USB 디버깅 활성화 된 안드로이드폰, PC와 연결할 USB케이블, PC USB 디버깅 활성은 안드로이드폰 개발자 옵션 활성 후 개발자 옵션 &gt; USB 디버깅을 활성 하시면 됩니다. 사용 방법안드로이드폰과 USB케이블을 PC에 연결을 합니다. 크롬 &gt; devtools &gt; ⋮(More Options) &gt; more Tools &gt; Remote devices 로 실행 하면 됩니다. 이 후엔 폰기종 Connected를 클릭 후 안드로이드폰에서 크롬App을 실행 하면 Intercept를 클릭 하시면 안드로이드폰과 PC에 동일한 화면을 공유 하며 디버깅이 가능 합니다.","categories":[{"name":"Web","slug":"Web","permalink":"http://kji6252.github.io/categories/Web/"}],"tags":[{"name":"Chrome, devtools, Android, Web Debug","slug":"Chrome-devtools-Android-Web-Debug","permalink":"http://kji6252.github.io/tags/Chrome-devtools-Android-Web-Debug/"}]},{"title":"JHipster MSA 구축","slug":"JHipster-MSA-구축","date":"2018-08-11T05:53:44.000Z","updated":"2021-04-02T02:38:07.045Z","comments":true,"path":"2018/08/11/JHipster-MSA-구축/","link":"","permalink":"http://kji6252.github.io/2018/08/11/JHipster-MSA-구축/","excerpt":"개요Mricroservice는 수많은 장점을 가지고 있지만 구축하는건 생각보다 쉽지 않습니다. JHipster와 함께 MSA구축을 하면 한층 쉽게 다가갈수 있다고 생각 되어 글을 작성 하게 되었습니다. 본 글에서는 크게 개발 MSA 환경 구축 Docker Compose를 활용한 Service Mash 나뉘며 프로젝트 생성부터 Microservice Gateway와 Microservice Application생성과 더불어 상용 배포를 위한 Docker Compose 설정까지 알아 보겠습니다. 개발 MSA 환경 구축","text":"개요Mricroservice는 수많은 장점을 가지고 있지만 구축하는건 생각보다 쉽지 않습니다. JHipster와 함께 MSA구축을 하면 한층 쉽게 다가갈수 있다고 생각 되어 글을 작성 하게 되었습니다. 본 글에서는 크게 개발 MSA 환경 구축 Docker Compose를 활용한 Service Mash 나뉘며 프로젝트 생성부터 Microservice Gateway와 Microservice Application생성과 더불어 상용 배포를 위한 Docker Compose 설정까지 알아 보겠습니다. 개발 MSA 환경 구축 Gateway 생성 Registry 실행 Gateway 실행 Application 생성 Application 실행 여기에선 이 구조로 프로젝트를 생성 해 보겠습니다. Gateway 생성Gateway를 생성한 뒤 먼저 JHipster Registry를 실행한다. 123// Gateway로 프로젝트 생성$ cd gateway$ jhipster 12// Registry 실행$ docker-compose -f src/main/docker/jhipster-registry.yml up JHipster Registry는 Spring Cloud Config와 Eureka Server로 이루어져 있으며 Microservice의 Config관리 및 서버 발견 역할을 한다. registry가 셋팅 된후에 gateway를 실행 시킨다. 12// Gateway 실행$ ./gradlew Application 생성123// Application로 프로젝트 생성 (member, wallet 각각 실행)$ cd member$ jhipster 생성 후 별도의 비즈니스로직 추가 후 애플리케이션을 실행 하시면 됩니다. 12// Gateway 실행$ ./gradlew 개발 MSA 환경 실행지금까지 잘 따라오셨으면 Registry Gateway Application 3개의 서비스들이 잘 실행 되어 있고 Gateway에서 각각의 Application의 API를 호출하면 정상적으로 동작하는걸 확인 하실 수 있습니다. swagger를 통해 Gateway에서 각각의 member와 wallet Service의 API를 확인하고 개발 할 수 있습니다. Docker Compose를 활용한 Service MashDocker Compose를 실행하기전 각각의 애플리케이션의 Dokcer Image가 필요하여 아래의 명령어를 실행 해줘야 합니다.1$ ./gradlew bootWar -Pprod buildDocker docker images로 Docker Image를 확인 하실 수 있습니다.1$ docker images 필요한 모든 준비가 완료 되었습니다. 이제 docker-compose로 서비스들을 묶은 뒤 실행만 하면 됩니다.12$ cd wallet-app-compose$ jhipster docker-compose 생성을 완료 한 후 실행을 해봅니다.1$ docker-compose up -d 이외 compose사용시 유용한 명령어들 입니다. docker-compose up -d - 컨테이너들 생성과 동시에 실행 docker-compose down - 컨테이너들 종료와 동시에 삭제 docker-compose start - 컨테이너들 실행 docker-compose stop - 컨테이너들 종료 docker로 실행 시 몇가지 유용한 명령어를 정리 해 보았습니다. docker stats - 컨테이너의 cpu, memory, I/O 등 docker images - 이미지 확인 docker ps - 컨테이너 확인 docker rmi - 이미지 삭제 docker rm - 컨테이너 삭제 자세한 사용법은 명령어 뒤에 --help 를 넣어 확인 바랍니다. JHipster Console도 설치 하여 MSA관리를 수월할 수 있게 도와 줍니다.","categories":[{"name":"JHipster","slug":"JHipster","permalink":"http://kji6252.github.io/categories/JHipster/"}],"tags":[{"name":"JHipster","slug":"JHipster","permalink":"http://kji6252.github.io/tags/JHipster/"},{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kji6252.github.io/tags/Spring/"}]},{"title":"JHipster란?","slug":"JHipster란","date":"2018-07-29T08:25:17.000Z","updated":"2021-04-02T02:38:07.046Z","comments":true,"path":"2018/07/29/JHipster란/","link":"","permalink":"http://kji6252.github.io/2018/07/29/JHipster란/","excerpt":"JHipster란?간단히 정의 하면 자바 기반 생성(generate) 개발 플랫폼 이라고 말씀 드릴 수 있습니다. 기존 뛰어난 생산성으로 흥한 개발 플랫폼인 Ruby의 Ruby on Ralse나 Node.js의 Meteor.js등 애플리케이션 개발을 생성 도구 활용으로 인기를 었습니다. 그동안 Spring 진영에서도 생성 도구를 활용한 개발이 없어 생산성에서 뒤쳐졌지만, JHipster에서 만들게 되어 Spring에서도 빠른 생산성을 확보하게 되었습니다. 생성 도구는 Yeoman이라는 기존 웹 보일러플레이트 프로젝트 생성 도구인데 JHipster에서 Yeoman기반으로 만들어 활용 하였습니다.","text":"JHipster란?간단히 정의 하면 자바 기반 생성(generate) 개발 플랫폼 이라고 말씀 드릴 수 있습니다. 기존 뛰어난 생산성으로 흥한 개발 플랫폼인 Ruby의 Ruby on Ralse나 Node.js의 Meteor.js등 애플리케이션 개발을 생성 도구 활용으로 인기를 었습니다. 그동안 Spring 진영에서도 생성 도구를 활용한 개발이 없어 생산성에서 뒤쳐졌지만, JHipster에서 만들게 되어 Spring에서도 빠른 생산성을 확보하게 되었습니다. 생성 도구는 Yeoman이라는 기존 웹 보일러플레이트 프로젝트 생성 도구인데 JHipster에서 Yeoman기반으로 만들어 활용 하였습니다. Yeoman이란? 웹 개발을 프레임워크 및 라이브러리들을 통합하여 쉽게 프로젝트를 생성 할 수 있는 Tool 입니다. 12$ npm i -g yo$ npm i -g generator-원하는도구 기본적으로 Node.js가 설치 되어 있어야 하며, yo를 설치 후 원하는 도구를 설치 하면 됩니다. Yeoman에서 제공하는 API를 활용하면 쉽게 CLI기반 Generate가 가능 하므로 관심 있으신 분들은http://yeoman.io/authoring/index.html이 URL을 참조 하셔서 개발 하시면 됩니다. JHipster Sample Project준비JHipster를 사용하기 전 필수로 설치할 프로그램을 소개 합니다. Java Git Node.js Yarn Yeoman Java와 Git, Node.js는 OS에 맞추어 설치 하시고 Yarn과 Yeoman은 Node.js와 함께 설치된 npm으로 설치 하시면 됩니다. 12$ npm i -g yarn$ yarn global add generator-jhipster https://www.jhipster.tech 에 접속 하여 Quick Start를 보고샘플 프로젝트 생성을 진행 하겠습니다. JHipster 문서 보실때 헷갈릴까봐 한가지 짚고 넘어 가겠습니다.명령어 사용 시 옛날 방식과 최근 방식에 차이점이 있는데 yo를 쓰고 안쓰고 차이 입니다. 입맛에 맞게 골라서 사용하시면 될거 같습니다. 프로젝트 생성 시 12345//옛날 방식$ yo jhipster//최근 방식$ jhipster 추가 기능 사용 시 12345//옛날 방식$ yo jhipster:추가기능//최근 방식$ jhipster 추가기능 생성샘플프로젝트 생성 시 선택 가능한 내역 입니다.굵게 표시한건 이번 프로젝트 생성 시 선택한 것 입니다. 어떤 타입의 프로젝트를 생성하는가? 모놀로식 애플리케이션 마이크로서비스 애플리케이션 마이크로서비스 게이트웨이 JHipster UAA Server 어떤 인증을 사용 할 것인가? JWT Oauth2 / OIDC HTTP Sesstion Authentication 어떤 DB를 사용 할 것인가? SQL(H2, MySQL, MariaDB, PostgreSQL, Oracle, MSSQL) MongoDB Couchbase Cassandra (SQL 선택시 나옴) dvelopment와 production에 사용할거 선택 Spring Cache를 사용할 것인가? Ehcach Hazelcast Memcached 사용안함 어떤 빌드 도구를 쓸 것인가? Maven Gradle 다른 기술을 사용할 것인가?(모두 선택 가능) 엘라스틱서치 기반 검색 웹소켓 OpenAPI-generator Kafka 어떤 Front를 사용 할 것인가? Angular 6 React 추가 테스트 프레임워크를 사용할 것인가?(모두 선택 가능) Gatling Cucumber Protractor 어떤 기본 언어를 선택 할 것인가? 한국어 영어 기타 등등 추가로 지원할 언어는?(모두 선택 가능) 영어 나머지 선택지는 위와 동일 본격적으로 생성을 해보겠습니다. 12PS C:\\Users\\a\\jhipsterProjects&gt; mkdir myApp; cd myAppPS C:\\Users\\a\\jhipsterProjects\\myApp&gt; Spring Boot + React앱이 만들어 졌고 다음시간엔 JDL과 CLI을 통한 Entity+Controller+Service생성을 알아 보겠습니다.","categories":[{"name":"JHipster","slug":"JHipster","permalink":"http://kji6252.github.io/categories/JHipster/"}],"tags":[{"name":"JHipster","slug":"JHipster","permalink":"http://kji6252.github.io/tags/JHipster/"},{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kji6252.github.io/tags/Spring/"}]},{"title":"해외판 전자정부프레임워크? JHipster에 대해 알아 보자!","slug":"해외판-전자정부프레임워크-JHipster에-대해-알아-보자","date":"2018-07-29T08:23:45.000Z","updated":"2021-04-02T02:38:07.051Z","comments":true,"path":"2018/07/29/해외판-전자정부프레임워크-JHipster에-대해-알아-보자/","link":"","permalink":"http://kji6252.github.io/2018/07/29/해외판-전자정부프레임워크-JHipster에-대해-알아-보자/","excerpt":"개요우리나라에서 공공기관과 민간기업에서 많이 사용하는 전자정부프레임워크가 있습니다. 업데이트도 느리거니와 생성도 불편하다고 생각 됩니다. 그에 반해 해외에서는 Yeoman을 가지고 쉽게 Spring Boot 개발 환경을 만들 수 있고 더불어 편한 유지 보수를 할 수 있게 도와주는 JHipster를 소개 합니다. 해외에서 자바 개발 플랫폼으로 핫한 프로젝트 입니다.","text":"개요우리나라에서 공공기관과 민간기업에서 많이 사용하는 전자정부프레임워크가 있습니다. 업데이트도 느리거니와 생성도 불편하다고 생각 됩니다. 그에 반해 해외에서는 Yeoman을 가지고 쉽게 Spring Boot 개발 환경을 만들 수 있고 더불어 편한 유지 보수를 할 수 있게 도와주는 JHipster를 소개 합니다. 해외에서 자바 개발 플랫폼으로 핫한 프로젝트 입니다. 다양한 기업들에서도 JHipster를 사용하고 있습니다. 프로젝트 셋팅부터 시작해서 귀찮은 일은 JHipster가 도 맡아 하고 개발자는 비즈니스 로직에만 집중 할 수 있습니다. JHipster로 할 수 있는것 Spring Boot + Angular/React 프로젝트 UML을 통한 Entity+Controler+Service 자동 생성 MSA 환경 구축 Docker Image 생성 Cloud와 통합 기능 제공(Kubernetis, Heroku, AWS 등) 이외에도 여러 오픈소스들을 사용할 수 있게 셋팅이 되어 있으며 입맛이 맞게 골라서 사용 하실 수 있습니다. 개인적으로 마음에 드는 부분Spring Project들을 사용 하면서 공부 할 때 구조를 잘 잡는게 중요하다고 생각 됩니다. 물론 샘플 프로젝트만으로도 만족 할 수 있겠지만, 여러 프로젝트들을 융합 하였을때 복잡성이 증가하고 문맥과 명칭들이 뒤죽박죽 섞여 있어 통일성을 잃기 쉽습니다. 그래서 JHipster의 생성된 프로젝트를 봤을 때 깔끔한 설정과 generator를 사용 하여 일관된 개발을 할 수 있게 도와 줍니다. 소개소개는 JHipster란? With Sample Project JHipster와 생성 도구 JHipster와 오픈소스 JHipster MSA With Docker Compose 4 단계로 나눠서 소개를 할까 싶습니다.","categories":[{"name":"JHipster","slug":"JHipster","permalink":"http://kji6252.github.io/categories/JHipster/"}],"tags":[{"name":"JHipster","slug":"JHipster","permalink":"http://kji6252.github.io/tags/JHipster/"},{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kji6252.github.io/tags/Spring/"}]},{"title":"2018 Ahea 세미나 - Server에서 만남을 추구하면 안되는 걸까","slug":"2018-Ahea-세미나-Server에서-만남을-추구하면-안되는-걸까","date":"2018-07-09T13:07:23.000Z","updated":"2021-04-02T02:38:07.045Z","comments":true,"path":"2018/07/09/2018-Ahea-세미나-Server에서-만남을-추구하면-안되는-걸까/","link":"","permalink":"http://kji6252.github.io/2018/07/09/2018-Ahea-세미나-Server에서-만남을-추구하면-안되는-걸까/","excerpt":"강진우님의 리눅스 커널 이야기를 읽고 직접 실습을 하며 정리한 내용 입니다. 도입사람과 사람사이 예의가 정말 중요 합니다. 서버에서 동작하는 서비스들 한테도 마찬가지인데요. 이 글에서는서버에서 돌아가는 서비스들의 관계와 사람의 관계를 비교해 가면서 설명 하겠습니다.","text":"강진우님의 리눅스 커널 이야기를 읽고 직접 실습을 하며 정리한 내용 입니다. 도입사람과 사람사이 예의가 정말 중요 합니다. 서버에서 동작하는 서비스들 한테도 마찬가지인데요. 이 글에서는서버에서 돌아가는 서비스들의 관계와 사람의 관계를 비교해 가면서 설명 하겠습니다. 1차 웹서비스 예제에서 쓰인 웹 서비스는 파이썬 웹 프레임워크인 Flask를 썻으며 DB로는 Key/Value store인 redis를 사용 하였습니다. http://localhost:5000/test/1 접속 Flask에서 Redis에 접속하여 Set(1,155030303)를 실행(redis에 데이터 주입) Flask에서 Redis에 Get(1)을 하여 데이터 가져오기 사용자에게 전달 해당 서비스의 플로우는 총 4단계로 구성 되며 이 예제를 가지고 사용자에게 서비스 가능한 웹서비스를 튜닝 하겠습니다. 사과를 구입할 경우엔 이런식의 플로우로 흘러간다고 예를 들겠습니다. Flask와 Redis의 사이도 마찬가지인데요 위의 그림과 같이 3way-handshake 후에 데이터셋팅을 하고 데이터를 가져오며 4way-handshake를 통해 연결을 끊습니다. 만약에 이작업을 1000명 혹은 10000명이 요청할 경우 2가지 문제점이 발생하게 됩니다. TCP 연결과 종료에 대한 오버헤드 local port에 대한 고갈 여기서 잠깐!!! local port란? Client가 TCP 소켓 연결시 필요한 port, OS에서 정의 해놓은 local port 범위 안에서 할당 보통 http Request를 날리거나 다른 TCP연결을 할시에 OS에서 ‘IP주소:로컬포트’를 가지고 통신을 하게 됨 문제점 2가지TCP 통신 오버헤드 3way-handshake와 4way-handshake를 1000번 10000번 하게 되면 그만큼의 네트워크 자원 낭비가 되기 때문에 계속 연결 되어 있는 상태여야 합니다. 아까의 사과 구매 프로세스를 대입해 보면 사과 1000개를 구매 할 때에도 똑같이 1000번을 인사해야 하는 불상사가 생깁니다. local port 고갈의 문제 Flask에서 Client가 되므로 지속적으로 local_port를 만들어 내어 나중엔 고갈이 되어 버리는 현상까지 오게 됩니다. 그리고 다시 사용할시엔 timewait지속 시간이 60초 이므로 60초가 지나야 다시 사용 가능 합니다. netstat 명령어를 통해 현재 OS의 소켓 상태를 확인 할수 있으며 Flask가 local_port를 무지막지하게 사용한 모습을 보실수 있습니다. 우분투에서 할당 해 줄수 있는 포트를 ‘sysctl -a | grep local_port’ 명령어로 확인 할수 있습니다. 위의 문제점을 해결할 방법도 2가지가 됩니다. net.itv4.tcp_tw_reuse 활성화 Connection Pool 해결법 2가지net.ipv4.tcp_tw_reuse 활성화 ‘sysctl -a | grep reuse’명령어를 통해 확인 할수 있으며 0이면 비활성 1이면 활성화 입니다. ‘sysctl -w net.ipv4.tcp_tw_reuse=1’명령어를 입력시 활성화 되며 이 기능은 패킷 소실의 위험이 있습니다. 지금과 같은 형태에서는 비추천 하지만 다른서버에 접속하는 Cilent용 서버일 경우에는 필요 할 수도 있습니다. Connection Pool 다른 해결 방법인 Connection Pool을 만들어 사용 하는 것입니다. 미리 Pool을 만들어 놓고 사용자들이 http Request를 사용시엔 이런 식으로 3way-handshake와 4way-handshake가 사라지기 때문에 TCP 맺고 끊음에 대한 오버헤드가 사라지게 됩니다. 그리고 계속 연결 상태 이므로 로컬 포트도 고정적으로 사용하게 되어서 고갈을 방지 할 수 있습니다. 사과 구매를 할때에도 인사를 한번만 할수 있으므로 인사(TCP 연결과 종료)할 수 있으므로 오버헤드를 감소 할수 있습니다. 2차 웹서비스 Nginx를 추가 해보자실질적으로 외부에 서비스하는 웹서비스들은 대부분 앞에 Web Server를 두게 되는데 그이유는 크게 Virtual Host, resource cache, Route등의 이유가 있어 약간의 지연이 있어도 3tier(WebServer-App-DB)로 구성을 하게 됩니다. 그런데 바로 추가시엔 위와 동일한 현상이 발생하게 됩니다. 다시 나타난 2가지 문제점 TCP 연결과 종료에 대한 오버헤드 local port에 대한 고갈 Nginx가 Cilent이며 Flask가 Server인 입장이 되어 위와 동일한 현상이 발생하게 됩니다. 이 문제점도 동일하게 해결법이 2가지가 있습니다. net.ipv4.tcp_tw_reuse 활성화 Keepalive Connections Keepalive Connections 추가 nginx 설정에서 keepliave만 추가 해주면 됩니다. 자세한 설정은 기본 예제도 많으므로 nginx example을 참조해서 keepalive만 추가 해 줍시다. 위와 같은 구성도가 되며 Nginx에서 Keepalive Connections를 만들어 관리하게 됩니다. 참고로 time_out 값도 줄수 있어 한번 연결 후에는 몇초 후에 Keepalive를 없앨지 정할 수 있습니다. keepalive를 추가 할때와 안할때의 플로우는 아래와 같습니다. 보통 한번 http연결시 6~8번의 요청을 하게 된다고 하여 keepalive로 TCP 연결과 종료에 대한 오버헤드를 줄일 수 있습니다. Keepalive 설정 전후의 테스트 결과 입니다. 스트레스 테스트 툴은 siege를 사용 하였습니다. TPS가 200이나 차이가 났습니다. netstat를 통해 테스트 후의 time_wait소켓을 살펴보니 8300개의 차이가 발생 하였습니다. 최종 정리 서비스 대 서비스로 연결시에는 Connection Pool을 고려해 보자! Nginx 사용시 Keepalive사용을 고려해 보자! time_wait소켓이 많다는건 나쁘진 않지만 지나치게 많을 경우 살펴 보자! 출처 책 ‘리눅스 커널 이야기’ 강진우 지음 nginx keepalive - https://www.nginx.com/blog/http-keepalives-and-web-performance/ TCP Flags - http://www.dbguide.net/knowledge.db?cmd=view&amp;boardUid=183652&amp;boardConfigUid=21","categories":[{"name":"세미나","slug":"세미나","permalink":"http://kji6252.github.io/categories/세미나/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://kji6252.github.io/tags/Nginx/"},{"name":"TIME_WAIT","slug":"TIME-WAIT","permalink":"http://kji6252.github.io/tags/TIME-WAIT/"},{"name":"Server","slug":"Server","permalink":"http://kji6252.github.io/tags/Server/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-13T01:21:00.000Z","updated":"2021-04-02T02:38:07.047Z","comments":true,"path":"2018/06/13/hello-world/","link":"","permalink":"http://kji6252.github.io/2018/06/13/hello-world/","excerpt":"소감블로그를 github pages로 옮기게 되었습니다. 여러가지 이유가 있지만 Markdown으로 블로깅 github의 안정적인 호스팅 손쉬운 테마 변경 3가지의 이유가 있어서 사용하게 되었습니다.","text":"소감블로그를 github pages로 옮기게 되었습니다. 여러가지 이유가 있지만 Markdown으로 블로깅 github의 안정적인 호스팅 손쉬운 테마 변경 3가지의 이유가 있어서 사용하게 되었습니다. 사용 이유그리고 github pages를 편리하게 사용하기 위해 필요한 Tool인 Static Web Generator를 StaticGen에서 조사해본 결과 여러가지 종류의 Static Web Generator가 있었고 Hexo가 엄청나게 밀려 있지만 Hexo Temes에 예쁜 테마를 발견하여 결국 쓰게 되었습니다.추 후 다른 예쁜 테마를 발견하게 되면 Static Web Generator 상관없이 테마 기준으로 Static Web Generator를 선택 할 예정 입니다. 현재 테마의 github 주소는 맨밑을 확인해 주세요.","categories":[{"name":"이모저모","slug":"이모저모","permalink":"http://kji6252.github.io/categories/이모저모/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"http://kji6252.github.io/tags/Blog/"},{"name":"Tool","slug":"Tool","permalink":"http://kji6252.github.io/tags/Tool/"},{"name":"Hexo","slug":"Hexo","permalink":"http://kji6252.github.io/tags/Hexo/"}]},{"title":"가상화폐? 암호화폐?","slug":"bitcoin-summary","date":"2017-12-25T01:03:00.000Z","updated":"2021-04-02T02:38:07.046Z","comments":true,"path":"2017/12/25/bitcoin-summary/","link":"","permalink":"http://kji6252.github.io/2017/12/25/bitcoin-summary/","excerpt":"최근 인기를 끌고 있는 블록체인(blockchain)기술과 그 기술을 활용한 가상화폐에 대해서 알아 봅시다. 블록체인은 사토시 나카모토가 2009년 처음 블록체인 기반 암호화폐 비트코인이 처음 등장하면서 세상에 나오게 되었습니다. 블록체인이란 거래내역을 블록이라는 단위로 묶고 다음에 발생한 블록을 끝에 붙이는 Linked List방식으로 연결 하는걸 체인이라고 하여 블록체인 이라고 합니다. 이 기술이 나온 2009년부터 현재 2017년 동안 거래내역이 변조 없이 잘 보존되어있다는걸로 증명 되어 보안에도 강하다는 강점이 나타나면서 획기적인 기술로 인정 받게 되었습니다. 그 후 비탈릭 부테린이 만든 이더리움이라는 가상화폐가 나오게 되었는데 기존 블록체인을 가상화폐 교환에서만 사용한걸 스마트 컨트렉트 라는 기능을 추가 함으로써 탈중앙화 앱(decentralized application = DAPP)을 제작할수 있는 환경을 제공 하게 되었습니다. 그 후 이더리움 스마트컨트렉트를 활용한 크립토키티스 라는 게임이 나오게 되었으며 이더리움의 가능성과 한계성을 알게 되었습니다.","text":"최근 인기를 끌고 있는 블록체인(blockchain)기술과 그 기술을 활용한 가상화폐에 대해서 알아 봅시다. 블록체인은 사토시 나카모토가 2009년 처음 블록체인 기반 암호화폐 비트코인이 처음 등장하면서 세상에 나오게 되었습니다. 블록체인이란 거래내역을 블록이라는 단위로 묶고 다음에 발생한 블록을 끝에 붙이는 Linked List방식으로 연결 하는걸 체인이라고 하여 블록체인 이라고 합니다. 이 기술이 나온 2009년부터 현재 2017년 동안 거래내역이 변조 없이 잘 보존되어있다는걸로 증명 되어 보안에도 강하다는 강점이 나타나면서 획기적인 기술로 인정 받게 되었습니다. 그 후 비탈릭 부테린이 만든 이더리움이라는 가상화폐가 나오게 되었는데 기존 블록체인을 가상화폐 교환에서만 사용한걸 스마트 컨트렉트 라는 기능을 추가 함으로써 탈중앙화 앱(decentralized application = DAPP)을 제작할수 있는 환경을 제공 하게 되었습니다. 그 후 이더리움 스마트컨트렉트를 활용한 크립토키티스 라는 게임이 나오게 되었으며 이더리움의 가능성과 한계성을 알게 되었습니다.크립토키티스라는 게임 출시때에는 엄청난 트래픽으로 인하여 이더리움 환경에서 돌아가는 모든 행위들이 수행속도가 현저히 낮아졌다고 하여 이로 인해 아직도 갈길이 멀었다는 생각을 하게 되었습니다. 이더리움은 DDos를 막고자 gas라는 수수료가 있는데 이더리움 환경을 이용시 이 gas가 필요 하기 때문에 크립토키티스 게임 행동하나하나가 비용이 필요한 게임이 되었습니다. 간단히 말해서 모든 행동이 캐시템이 필요하다고 보시면 될거 같습니다. 그래도 가상화폐를 가장 잘 활용한 플랫폼은 스팀인거 같습니다.(게임 스팀 아닙니다.) 스팀잇 이라는 SNS 플랫폼이 있는데 글작성도 블록으로 저장된다고 하고 글작성자는 보팅기능으로 돈도 벌수 있다고 합니다. 다른 가상화폐 진영에서는 이 단점을 없애고자 3세대 라고 주장하면서 나온 EOS라는 코인이 있으며 ADA 코인 등 앞으로 많은 코인이 등장 하면서 다음 3세대 코인은 1세대 2세대 단점들을 극복하면서 나올지 기대 됩니다. 특징을 정리해보면 개인간 거래가 가능하다 (Peer To Peer = P2P) 보안에 강하다 (노드가 많을 수록 안정됨) 여러 분야에 활용이 가능 하다.(스마트 컨트렉트로 인한 다양한 곳에 활용 가능 ex: steemit(voting), CryptoKitties 등) 현재 알고 있는걸 간략하게 설명 하였고 앞으로는 DAPP 예제도 작성하면서 조금더 블록체인에 대해 접근해보면서 공부 하고자 합니다. 암호화폐라는 용어는 가상화폐라는 단어 대신에 암호화폐 라는 단어를 사용함으로써 부정적인 인식을 개선하고자 최근에 나온 단어로 알고 있습니다. 저도 이제부터는 암호화폐라고 불러보도록 노력 하겠습니다. 앞으로 진행할 개념 설명 및 예제는 이더리움 기준으로 해볼까 합니다. 공부하면서 도움이 되었던 사이트를 아래에 남겼습니다. http://goodjoon.tistory.com/230?category=632200 - 이더리움 프로젝트 설명 및 예제 https://www.etherchain.org/ - 이더리움 익스플로러(최근 블록과 통계를 보여줌)","categories":[{"name":"가상화폐","slug":"가상화폐","permalink":"http://kji6252.github.io/categories/가상화폐/"}],"tags":[{"name":"Bitcoin","slug":"Bitcoin","permalink":"http://kji6252.github.io/tags/Bitcoin/"}]},{"title":"java data access","slug":"java-data-access","date":"2017-07-06T01:39:00.000Z","updated":"2021-04-02T02:38:07.047Z","comments":true,"path":"2017/07/06/java-data-access/","link":"","permalink":"http://kji6252.github.io/2017/07/06/java-data-access/","excerpt":"JDBC자바에서 데이터베이스에 접속 할수 있는 API를 제공하는데 그게 JDBC(Java Database Connectivity) 입니다.","text":"JDBC자바에서 데이터베이스에 접속 할수 있는 API를 제공하는데 그게 JDBC(Java Database Connectivity) 입니다. 자바 JDBC와 DB벤더들아래 표는 JDBC를 사용시의 불편함점 개선과 기능추가가된 라이브러리 및 프레임워크들 이다. 자바 스프링 JDBC Plane JDBC Spring JDBC Mybatis Mybatis-Spring Apache commons DbUtils sql2o JDBI ORMLite JPA(ORM) Plane JPA Spring Data JPA JPA provider Hibernate, EclipseLink, TopLink JDO TpyeSafe Builder jOOQ , QueryDSL JDBC APIJDBC API는 Java에서 가장 로우레벨의 데이터베이스 API 입니다. 그래서 SQL을 실행하는 데도 매우 번잡한 코드가 필요하고 DB에 따라 일관성없는 예외체크를 해야 하며 SQL은 코드 내에서 문자로 제공해야 하는 불편을 감수해야 한다. 커넥션과 같은 공유 리소스를 제대로 처리하지 않으면 시스템의 자원이 바닥나는 심각한 버그를 심어놓을 수도 있다. MyBatisMyBatis는 first class persistence framework with support라고 소개 되어 있는데 말그대로 클래스 중심으로 프로그램을 개발 할 수 있게 도움을 준다는 프레임워크 지원 하는 기능은 커스텀SQL, 스토어프로시저, 고급매핑을 지원한다. 어떤곳에서는 ORM매퍼 라고 하는데 공식홈페이지를 가보면 ORM이라는 단어는 없고 first class persistence framework 가 맞는거 같다. http://blog.mybatis.org/p/products.html 들어가면 마이바티스부터 시작해서 코드자동생성 제너레이터, 이클립스개발시 도움을 주는 플러그인, 스칼라버전 마이바티스, 닷넷버전 마이바티스 등등 JDBC를 직접 사용하는것 보다 편의 기능이나 각종 툴이 제공되어서 생산성을 높일수 있다. JPA(ORM)JPA(Java Persistence API)는 관계형 데이터베이스에 접근하기 위한 표준 ORM 기술을 제공 한다. 2006년 java 1.5버전 이상부터 JPA1.0이 정의 되었으며 현재버전은 2013년에 정의된 JPA2.1버전이 최신이다. JPA는 구현체를 함께 사용해야 하는데 주로 사용되는 구현체의 점유율은 이러하다. SpringSpring JDBCTemplatespring 에서는 jdbc를 확장해서 만든 jdbcTemplate을 이용하여 데이터베이스에 접근을 합니다. jdbcTemplate은 JDBC API를 가지고 템플릿콜백패턴을 통해 간결함과 리소스 처리를 함으로써 비즈니스로직에 집중할수 있게 하였고 데이터베이스마다 다른 exception핸들링을 통하여 데이터베이스 예외처리를 획일화 하였습니다. 스프링 SQLException 핸들링 Spring Data와 서브 프로젝트들 spring data 는 JDBC뿐만 아니라 JPA와 각각의 클라이언트를 제공하던 NoSQL들도 제공 함으로써 Spring에서 가장 대표적으로 사용하는 Dao Access 프레임워크가 되었습니다. Repositories, Templates, Object Mapping과 트랜잭션동시지원, 간편한 설정등의 기능을 더하고 확장 하였습니다. spring data 서브프로젝트 중에서는 Repository만 구현해도 자동으로 CRUD및 Paging, sort 기능을 자동으로 생성되는 프로젝트들도 있습니다. spring data의 기능은 Repository에 crud, paging, sort 기능을 함유 커스텀 Repository 하고 있고 각종 유틸과 QueryDSL에 관련된 서포트툴이 있어 QueryDSL의 TypeSafe한 쿼리문을 작성하기에 용이 합니다. TpyeSafe BuilderQueryDSLQueryDSL은 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있는 프레임워크다. 문자열이나 XML에 쿼리를 작성하는 대신 QueryDSL이 제공하는 플루언트(Fluent) API를 이용해서 쿼리를 생성할 수 있다. IDE의 코드 자동 완성 기능 사용 컴파일 시점에서 잘못된 쿼리를 허용하지 않음 도메인 타입과 프로퍼티를 안전하게 참조할 수 있음 도메인 타입의 리팩토링을 더 잘 할 수 있음 jOOQ처음엔 JPA를 공부할때는 QueryDSL을 먼저 알았지만 타입세이프빌더쪽에서는 jOOQ가 더 오래된걸 알게 되었습니다. 아무래도 유료이다 보니 QueryDSL보다 덜 활성화 된게 아닐까 싶습니다. jOOQ의 장점은 돈을 내고 지원을 받을수 있다는 점인거 같습니다. 흥미로운건 jOO로 시작하는 프로젝트들인 jOOX : jquery 문법을 자바에서 사용가능하게 해줌 jOOR : 자바 리플렉션 랩퍼 라이브러리 jOOL : 자바에 람다 기능 보강(?) jOOU : unsigned 타입을 지원 등 재미 있는 프로젝트들이 있어서 뭔가 새로운걸 도전하는 팀같아서 좋게 보였습니다. 작성 하다보니 쓸모 있는 내용이 없어서 죄송합니다. 안바쁠때 예제와 함께 올릴예정이였지만 이직과 이리저리 많은일이 있어서 간단하게 나마 남겨 봅니다.","categories":[{"name":"자바","slug":"자바","permalink":"http://kji6252.github.io/categories/자바/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kji6252.github.io/tags/Spring/"},{"name":"DB","slug":"DB","permalink":"http://kji6252.github.io/tags/DB/"}]},{"title":"윈도우 에서 도커(Docker)와 Kitematic 설치","slug":"windows-docker-install","date":"2017-04-03T02:22:00.000Z","updated":"2021-04-02T02:38:07.051Z","comments":true,"path":"2017/04/03/windows-docker-install/","link":"","permalink":"http://kji6252.github.io/2017/04/03/windows-docker-install/","excerpt":"저같이 도커를 잘모르는 사람에게 쉽게 접근할수있게 제공해주는 GUI툴 Kitematic이 있습니다. 클릭 몇번으로 이미지를 다운로드 받아서 컨테이너 생성까지 정말 간편하게 사용하고 로그도 출력되며 웹포트가 열려있으면 웹도 쉽게 띄울수있습니다. 도커를 처음 입문 하시는 분들을 위해 설치법을 공유 합니다. 윈도우에서 도커를 깔기 위해 메인페이지의 다운로드를 사용하여 설치하였습니다.","text":"저같이 도커를 잘모르는 사람에게 쉽게 접근할수있게 제공해주는 GUI툴 Kitematic이 있습니다. 클릭 몇번으로 이미지를 다운로드 받아서 컨테이너 생성까지 정말 간편하게 사용하고 로그도 출력되며 웹포트가 열려있으면 웹도 쉽게 띄울수있습니다. 도커를 처음 입문 하시는 분들을 위해 설치법을 공유 합니다. 윈도우에서 도커를 깔기 위해 메인페이지의 다운로드를 사용하여 설치하였습니다. 이화면이 계속 나오고… 아무리 진행을 해도 안되더군요… 좌절을 하였습니다. 해결방법을 검색 하던중 어느한 커뮤니티에서 다른 페이지에 있는걸 다운 받아 설치하라고 하더군요. 도커 docs에 있는 다른 설치 파일을 찾았습니다. 기존껀 지우고 설치해 보죠. https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows 여기서 잠깐!!! Windows10 pro 이상이신 분들은 Hyper-v 를 활성화 하시는걸 추천드립니다. 윈도우10에서부터 탑재된 Hyper-v는 오라클 버추얼박스나 vm웨어보다 성능이 더 좋다고 하더군요. 제어판 &gt; 모든 제어판 항목 &gt; 프로그램 및 기능 > Windows 기능 &gt; Hyper-V 체크 이 창이 뜨면서 작업표시줄엔 아름다운 고래 마스코트가 뜨게 됩니다. 설치후엔 PowerShell 에서 직접 도커 명령어로도 실행 할수있지만 GUI툴도 제공 함으로 같이 설치 해보겠습니다. 고래를 우클릭 후 Kitematic을 클릭합니다. 보시면 다운로드하고 난 뒤 압축을 푼 후 C:\\Program Files\\Docker\\Kitematic 이 디렉토리에 삽입하라는 뜻 같습니다.(압축푼 후 폴더명이 Kitematic-Windows 이므로 Kitematic으로 이름변경) 이 위치에 이동 한 후 다시 고래를 우클릭하여 Kitematic을 클릭 합니다. GUI로 편하게 다운로드하고 실행 할수 있습니다. 이걸로 로컬에서 텐서플로우나 젠킨스를 설치해서 연습 해보는것도 좋을거 같습니다.","categories":[{"name":"도커","slug":"도커","permalink":"http://kji6252.github.io/categories/도커/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://kji6252.github.io/tags/Docker/"}]},{"title":"오브젝트 매핑과 슈퍼 타입 토큰","slug":"obj-map-super-type-token","date":"2017-02-26T05:49:00.000Z","updated":"2021-04-02T02:38:07.050Z","comments":true,"path":"2017/02/26/obj-map-super-type-token/","link":"","permalink":"http://kji6252.github.io/2017/02/26/obj-map-super-type-token/","excerpt":"자바 프로젝트를 진행 하면서 외부 데이터를 가지고 VO클래스에 매핑하고 여러가지 연산작업을들 합니다. 그중에서도 VO클래스의 정보를 가져와 매핑하는 방법에 대해서 궁금하게 되었고 자바에서 제공하는 리플렉션API와 간단한 예제들을 통해서 오브젝트 매핑에 대해 알아 보겠습니다. 클래스 정보 가져오기 자바는 java.lang.reflect패키지의 API를 가지고 클래스의 정보와 필드 어노테이션 정보까지 모두 가져 올수 있는 리플렉션을 제공 합니다. 그래서 이렇게 구할수 있는 정보를 가지고 외부에서 가져오는 json 데이터나 sql문을 가져올시 매핑을 하여서 해당 오브젝트로 값을 삽입해 넘겨줄수 있습니다.","text":"자바 프로젝트를 진행 하면서 외부 데이터를 가지고 VO클래스에 매핑하고 여러가지 연산작업을들 합니다. 그중에서도 VO클래스의 정보를 가져와 매핑하는 방법에 대해서 궁금하게 되었고 자바에서 제공하는 리플렉션API와 간단한 예제들을 통해서 오브젝트 매핑에 대해 알아 보겠습니다. 클래스 정보 가져오기 자바는 java.lang.reflect패키지의 API를 가지고 클래스의 정보와 필드 어노테이션 정보까지 모두 가져 올수 있는 리플렉션을 제공 합니다. 그래서 이렇게 구할수 있는 정보를 가지고 외부에서 가져오는 json 데이터나 sql문을 가져올시 매핑을 하여서 해당 오브젝트로 값을 삽입해 넘겨줄수 있습니다. 조금더 편리한 API리플렉션 API로도 훌륭하게 매핑이 가능하지만 조금더 사용하기 편리하고 안전하게 매핑할수 있도록 자바에서 제공하는 java.beans 에서 제공하는 API를 사용 하겠습니다. BeanInfo 객체를 생성할 땐 Introspector.getBeanInfo라는 static factory methode를 이용하여 빈정보를 생성한뒤 각각의 BeanDescriptor, PropertyDecriptors, MethodDescriptors를 가져와서 리플렉션보다는 편리하게 클래스 정보를 가져 올수 있습니다. 여기에서 map형태나 json형태의 값을 가져 왔을때 오브젝트 매핑을 해야 하는데 PropertyDecriptors의 출력결과를 자세히 보시면 각각의 property에 대해서 redeMethod와 writeMethod정보를 보여주고 있습니다. 이걸 활용하여 맵에 프로퍼티이름과 값을 넣어두고 간단하게 매핑하는 예제를 보여드리겠습니다. 심플 매핑 Map에 프로퍼티 이름과 동일하게 값을 셋팅해주고 List에 한개씩 담았습니다. 소스를 보시면 셋팅된 데이터로 forEach문을 돌리면서 Map을 한개씩 가져옵니다 그러면서 데이터를 셋팅될 오브젝트를 생성하고(User u = new User();) forEach문 안에 property를 한개씩 꺼내오면서 property의 이름을 으로 Map의 키값을 검색하여 Map의 Value를 가져와 propertyDescriptor.getWriteMethod를 이용하여 값을 셋팅 해줍니다. 보기엔 복잡해 보이지만 하나씩 따라가보면 비교적 쉽게 느껴 지실수 있습니다. 타입 토큰예제 소스 코드중에서 Introspector.getBeanInfo(User.class)가 있는데 보통 User.class를 타입 토큰 이라고 합니다. 그런데 자바에서는 아쉽게도 타입 토큰에는 컴파일시 제너릭정보를 담을수가 없어서 class정보만을 가져올수가 있습니다.(C#은 자바와는 다르게 제너릭정보를 바로 가져올 수 있다고 하네요…) 그래서 이걸 해결하기 위해 나온것이 슈퍼 타입 토큰 이라고 합니다. 슈퍼 타입 토큰슈퍼 타입 토큰은 클래스의 제너릭 정보까지 가져오는 방식 입니다. 익명클래스를 작성하여 상속하면 상속된 정보는 컴파일시 지워지지가 않는다고 하여 익명클래스 상속방식으로 슈퍼 타입 토큰을 가져옵니다. 예제 소스를 보시면 extends가 된 클래스(슈퍼 클래스)는 가져오지만 List의 String정보는 못가져오고 있습니다. 이를 이용하여 슈퍼 타입 토큰을 이용하면 제너릭 정보를 가져올수가 있습니다. 위의 예제에서 슈퍼 타입 토큰을 사용하기 편하게 클래스를 정의해 보겠습니다. 타입 토큰과 슈퍼 타입 토큰 비교슈퍼 타입 토큰을 사용을 간소화 하기 위해서 클래스를 작성하였습니다. ParametertizedType은 파라미터형의 타입을 표현하는 인터페이스 입니다. 슈퍼 타입 토큰의 경우 제너릭정보를 모두 불러오지만 타입 토큰은 제너릭정보를 담을수가 없어 제한적일수바께 없습니다. 예제1. JDBC 예제GitHub : https://github.com/kji6252/ORM-example2.git 앞에서 알아본 클래스정보를 가져올수있는 BeanInfo와 슈퍼타입 토큰을 활용한 JDBC 오브젝트 매핑 예제를 작성 했습니다. 그림. JDBC 예제 구성도 그림. JDBC 예제 메인 OMMaper에서는 query메서드 에서 각각 원하는 결과를 리턴 할 수 있는 classQuery,listQuery,mapQuery 로 분기 한다음 ResultSet과 BeanInfo의 PropertyDescriptor로 매핑하여 최종 결과를 리턴 하게 됩니다. 예제2. Spring JDBC 예제 스프링에서 제공하는 SqlQuery를 상속받으면 protected abstract RowMapper newRowMapper(Object[] parameters, Map&lt;?, ?&gt; context); 메서드를 구현해야 합니다. 스프링 JDBC예제에서도 예제1과 동일한 방식으로 매핑을 하였습니다. 예제 1과 동일하게 구성 하였습니다. SqlQuery에서 아이디값으로 sql문을 실행하여 RowMapper로 매핑하여 결과를 가져 옵니다. 예제 : https://github.com/kji6252/ORM-example2","categories":[{"name":"스프링","slug":"스프링","permalink":"http://kji6252.github.io/categories/스프링/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://kji6252.github.io/tags/Spring/"},{"name":"JDBC","slug":"JDBC","permalink":"http://kji6252.github.io/tags/JDBC/"}]},{"title":"QueryDSL","slug":"jpa-basic-10","date":"2017-01-23T00:53:00.000Z","updated":"2021-04-02T02:38:07.049Z","comments":true,"path":"2017/01/23/jpa-basic-10/","link":"","permalink":"http://kji6252.github.io/2017/01/23/jpa-basic-10/","excerpt":"1 QueryDSL 소개 JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API JPA 크리테리아에 비해서 편리하고 실용적임 쿼리를 문자가 아닌 코드로 작성해도, 쉽고 간결하며 그 모양도 쿼리와 비슷하게 개발 할 수 있는 프로젝트가 바로 QueryDSL 이다. 오픈소스","text":"1 QueryDSL 소개 JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API JPA 크리테리아에 비해서 편리하고 실용적임 쿼리를 문자가 아닌 코드로 작성해도, 쉽고 간결하며 그 모양도 쿼리와 비슷하게 개발 할 수 있는 프로젝트가 바로 QueryDSL 이다. 오픈소스 1.1 장점 문자가 아닌 코드로 작성 컴파일 시점에 오류 발견 코드 자동완성 단순함, 쉬움: 코드 모양이 JPQL과 거의 흡사. 동적 쿼리 1.2 작동 방식 1.3 maven 셋팅 1.4 쿼리 타입 생성 메이븐 QueryDSL 설정을 하고 나서 mvn compile 명령어를 실행 하면 QueryDSL에서 사용할수 있는 Q타입 생성 JPQL - Entity QueryDSL - QEntity 자동 생성된 쿼리 타입(Q) 1.5 쿼리 사용 조인 페이징 동적쿼리 1.6 기능 정리 from innerJoin, join, leftJoin, fullJoin, on where (and, or, allOf, anyOf) groupBy having orderBy (desc, asc) limit, offset, restrict(limit + offset) (Paging) list listResults (list + Paging Info(totalCount)) iterate count singleResult, uniqueResult","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"객체지향 쿼리 언어","slug":"jpa-basic-09","date":"2017-01-23T00:47:00.000Z","updated":"2021-04-02T02:38:07.049Z","comments":true,"path":"2017/01/23/jpa-basic-09/","link":"","permalink":"http://kji6252.github.io/2017/01/23/jpa-basic-09/","excerpt":"1 JPQL 소개JPQL(Java Persistence Query Language) : 엔티티 객체를 조회하는 객체지향 쿼리. JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다. JPQL은 객체지향 쿼리 언어다. 테이블X 엔티티O JPQL은 결국 SQL로 변환된다.","text":"1 JPQL 소개JPQL(Java Persistence Query Language) : 엔티티 객체를 조회하는 객체지향 쿼리. JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다. JPQL은 객체지향 쿼리 언어다. 테이블X 엔티티O JPQL은 결국 SQL로 변환된다. 1.1 기본문법 JPQL도 SQL과 비슷하게 SELECT, UPDATE, DLEETE 문을 사용(INSERT는 EntityManager.persist() 사용) 대소문자 구분 : 엔티티와 속성은 대소문자 구분(ex : Member, username). 반면 SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않음 엔티티 이름 : @Entity(name=”XXX”)로 지정하거나 지정안할시 클래스명을 기본으로 사용 별칭은 필수 JPQL 표준은 필수 HQL(Hibernate Query Language)는 생략 가능. 1.2 쿼리 API반환타입을 명확히 할수 있는 TypeQuery와 명확히 지정할 수 없을땐 Query를 사용하면 됨 1.3 파라미터 바인딩이름 기준 123SELECT m FROM Member m where m.username=:usernamequery.setParameter(&quot;username&quot;, usernameParam); 위치 기준 123SELECT m FROM Member m where m.username=?1query.setParameter(1, usernameParam); 1.4 페이징 API 페이징 API - MySQL 방언 123456789SELECTM.ID AS ID,M.AGE AS AGE,M.TEAM_ID AS TEAM_ID,M.NAME AS NAMEFROMMEMBER MORDER BYM.NAME DESC LIMIT ?, ? 페이징 API - Oracle 방언 1234567891011121314SELECT * FROM( SELECT ROW_.*, ROWNUM ROWNUM_FROM( SELECTM.ID AS ID,M.AGE AS AGE,M.TEAM_ID AS TEAM_ID,M.NAME AS NAMEFROM MEMBER MORDER BY M.NAME) ROW_WHERE ROWNUM &lt;= ?)WHERE ROWNUM_ &gt; ? 1.5 집합과 정렬123456789selectCOUNT(m), //회원수SUM(m.age), //나이 합AVG(m.age), //평균 나이MAX(m.age), //최대 나이MIN(m.age) //최소 나이from Member mGROUP BY, HAVINGORDER BY 1.6 조인 내부 조인: SELECT m FROM Member m [INNER] JOIN m.team t 외부 조인: SELECT m FROM Member m LEFT [OUTER] JOIN m.team t 세타 조인: select count(m) from Member m, Team t where m.username = t.name 한계: 세타 조인시은 내부 조인만 사용할 수 있다.​ 페치 조인 엔티티 객체 그래프를 한번에 조회하는 방법 별칭을 사용할 수 없다. JPQL: select m from Member m join fetch m.team SQL: SELECT M., T. FROM MEMBER T INNER JOIN TEAM T ON M.TEAM_ID=T.ID 예시 최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다. 물론 일부는 빠를 수는 있지만 전체로 보면 사용하지 않는 엔티티를 자주 로딩하므로 오히려 성능에 악영향을 미칠 수 있다. 따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적이다. 1.7 JPQL 기타 서브 쿼리 지원 (from절에서 사용안됨) EXISTS, IN BETWEEN, LIKE, IS NULL JPQL 기본 함수 CONCAT 문자열 합침 SUBSTRING 문자열 자름 TRIM 빈공간제거 LOWER, UPPER 소문자로, 대문자로 치환 LENGTH 길이를 구함 LOCATE 검색위치부터 문자를 검색 1부터 시작 못찾으면 0반환 ABS 절대값, SQRT 제곱근, MOD 나머지 SIZE 컬렉션크기 구함, INDEX 컬렉션의 위치값 구함(JPA 용도) CASE 식 1.8 Named 쿼리: 정적 쿼리 미리 정의해서 이름을 부여해두고 사용하는 JPQL 어노테이션, XML에 정의 애플리케이션 로딩 시점에 초기화 후 재사용 애플리케이션 로딩 시점에 쿼리를 검증","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"값 타입","slug":"jpa-basic-08","date":"2017-01-23T00:30:00.000Z","updated":"2021-04-02T02:38:07.049Z","comments":true,"path":"2017/01/23/jpa-basic-08/","link":"","permalink":"http://kji6252.github.io/2017/01/23/jpa-basic-08/","excerpt":"기본값 타입basic value type 자바 기본 타입(예: int, double) 래퍼 클래스(예: Integer) String 임베디드 타입embedded type(복합 값 타입) 컬렉션 값 타입collection value type 복합 값 타입 복합값 정의 : @Embeddable 어노테이션으로 정의","text":"기본값 타입basic value type 자바 기본 타입(예: int, double) 래퍼 클래스(예: Integer) String 임베디드 타입embedded type(복합 값 타입) 컬렉션 값 타입collection value type 복합 값 타입 복합값 정의 : @Embeddable 어노테이션으로 정의 복합값 적용 : 값으로만 사용시엔 @Embedded로 키로 사용할땐 @EmbeddedID로 사용 임베디드 타입과 테이블 매핑 @AttributeOverride를 통해 컬럼명 변경 가능 컬렉션 타입 컬렉션 타입은 기본적으로 영속성 전이 + 고아 객체 제거기능을 필수로 가진다.","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"프록시와 연관관계 관리","slug":"jpa-basic-07","date":"2017-01-22T03:10:00.000Z","updated":"2021-04-02T02:38:07.049Z","comments":true,"path":"2017/01/22/jpa-basic-07/","link":"","permalink":"http://kji6252.github.io/2017/01/22/jpa-basic-07/","excerpt":"프록시 : 연관된 객체를 실제 사용하는 시점에 데이터베이스에서 조회 하는 기술 지연로딩: 연관된 객체를 실제 사용하는 시점에 불러 오는것 즉시로딩 : 연관된 객체를 조인을 통하여 함께 불러오는것 영속성 전이 : 연관된 객체를 함께 저장하거나 삭제 고아 객체 : 부모객체가 삭제시 홀로 남겨지는 객체 8.1 프록시엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다. JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 지연 로딩이라 한다. 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다.","text":"프록시 : 연관된 객체를 실제 사용하는 시점에 데이터베이스에서 조회 하는 기술 지연로딩: 연관된 객체를 실제 사용하는 시점에 불러 오는것 즉시로딩 : 연관된 객체를 조인을 통하여 함께 불러오는것 영속성 전이 : 연관된 객체를 함께 저장하거나 삭제 고아 객체 : 부모객체가 삭제시 홀로 남겨지는 객체 8.1 프록시엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다. JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 지연 로딩이라 한다. 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다. 8.1.1 프록시 기초12345//즉시 로딩Member member = em.find(Member.class, “member1”);//지연 로딩Member member = em.getReference(Member.class, “member1”); em.getReference() 사용시 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다. 대신에 데이터베이스 접근을 위임한 프록시 객체를 반환한다. 프록시 초기화 프록시의 특징 프록시 객체는 처음 사용할 때 한 번만 초기화된다. 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다. 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다. 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다. 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다. 하이버네이트는 org.hibernate.LazyInitializationException예외를 발생시킨다. 8.1.2 프록시와 식별자프록시는 식별자 값을 가지고 있으므로 식별자 값을 조회해도 초기화하지 않는다 엔티티 접근 방식 설정으로 초기화 유무를 결정 할 수 있다. @Access(AccessType.PROPERTY) : 식별자(getID())메소드 호출시 초기화 하지 않음 @Access(AccessType.FIELD) : 식별자(getID())메소드 호출시 초기화 함 8.1.3 프록시 확인 JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object Entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다. 12em.getEntityManagerFactory().getPersistenceUnitUtil().isLoaded(entity); 8.2 즉시 로딩과 지연 로딩즉시 로딩(EAGER) : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다. @ManyToOne(fetch=FetchType.EAGER) 지연 로딩(LAZY) : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다. @ManyToOne(fetch=FetchType.LAZY) 8.2.1 즉시 로딩대부분 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다. NULL제약 조건에 따라 내부 조인(INNER JOIN)이나 외부 조인(LEFT OUTER JOIN)을 사용 @JoinColunm(nullable=true) : NULL 허용(기본값), 외부 조인 사용 @JoinColunm(nullable=false) : NULL 허용하지 않음, 내부 조인 사용 또는 @ManyToOne(fetch=FetchType.EAGER, optional=false) 8.3.2 JPA 기본 패치 전략fetch 속성의 기본 설정값은 다음과 같다. @ManyToOne, @OneToOne : 즉시 로딩(FetchType.EAGER) @OneToMany, @ManyToMany : 지연 로딩(FetchType.LAZY) JPA의 기본 페치 전략은 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용 한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다. 8.3.3 컬렉션에 FetchType.EAGER 사용시 주의점 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다. 컬렉션 즉시 로딩은 항상 외부 조인(OUTER JOIN)을 사용한다. @ManyToOne, @OneToOne (optional=false) : 내부 조인 (optional=true) : 외부 조인 @OnetoMany, @ManyToMany (optional=false) : 외부 조인 (optional=true) : 외부 조인 일대다 다대다시엔 값이 없을경우도 조회를 해야 해서 무조건 외부조인으로 가져온다. 8.4 영속성 전이: CASCADE특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이(transitive persistence)기능을 사용하면 된다. 8.4.1 영속성 전이: 저장1@OneToMany(mappedBy=”parent”, cascade=CascadeType.PERSIST) 부모를 영속화할때 연관된 자식들도 함께 영속화하라고 cascade=CascadeType.PERSIST 옵션을 설정했다. 12345678//영속성 전이:저장Xem.persist(parent);//연관관계 매핑 코드em.persist(child1);//연관관계 매핑 코드em.persist(child2); 123//영속성 전이: 저장//child와 parent연관관계 추가em.persist(parent); CASCADE 실행 1234//영속성 전이: 삭제Xem.remove(findChild1);em.remove(findChild2);em.remove(findParent); 12//영속성 전이: 삭제em.remove(findParent); 엔티티를 영속화 하거나 제거 시 연관된 엔티티도 같이 처리 하는 편리함을 제공 한다. 8.4.3 CASCADE의 종류12345678public enum CascadeType&#123;ALL, //모두 적용PERSIST, //영속MERGE, //병합REMOVE, //삭제REFRESH, //REFRESHDETACH //DETACH&#125; 8.5 고아 객체(ORPHAN)JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라 한다. 1@OneToMany(mappedBy=”parent”, orphanRemoval=true) orphanRemoval=true 을 설정하면 사용 가능 하다. 1234567Parent parent1 = em.find(Parent.class, id);//한개만 제거parent1.getChildren().remove(0); //자식 엔티티를 컬렉션에서 제거//모두 제거parent1.getChildren().clear(); 출처 : 자바 ORM 표준 JPA 프로그래밍 김영한","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"고급 매핑","slug":"jpa-basic-06","date":"2017-01-17T01:58:00.000Z","updated":"2021-04-02T02:38:07.049Z","comments":true,"path":"2017/01/17/jpa-basic-06/","link":"","permalink":"http://kji6252.github.io/2017/01/17/jpa-basic-06/","excerpt":"상속 관계 매핑: 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지 다룬다. @MappedSuperclass: 등록일, 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고 싶으면 이 기능을 사용하면 된다. 복합 키와 식별 관계 매핑: 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법을 다룬다. 그리고 데이터베이스 설계에서 이야기하는 식별 관계와 비식별 관계에 대해서도 다룬다. 조인 테이블: 테이블은 외래 키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결 테이블을 두는 방법도 있다. 여기서는 이 연결 테이블을 매핑하는 방법을 다룬다. 엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있다. 여기서는 이 매핑 방법을 다룬다.","text":"상속 관계 매핑: 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지 다룬다. @MappedSuperclass: 등록일, 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고 싶으면 이 기능을 사용하면 된다. 복합 키와 식별 관계 매핑: 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법을 다룬다. 그리고 데이터베이스 설계에서 이야기하는 식별 관계와 비식별 관계에 대해서도 다룬다. 조인 테이블: 테이블은 외래 키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결 테이블을 두는 방법도 있다. 여기서는 이 연결 테이블을 매핑하는 방법을 다룬다. 엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있다. 여기서는 이 매핑 방법을 다룬다. 7.1 상속관계 매핑 객체 상속 모델 JPA에서는 상속관계를 총 3가지로 제공 조인 전략 : @Inheritance(strategy=InheritanceType.JOINED) 단일 테이블 전략 : @Inheritance(strategy=InheritanceType.SINGLE_TABLE) 구현 클래스마다 테이블 전략 : @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS) 조인 전략 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략객체는 타입이 있지만 테이블은 없기에 DTYPE 이라는 컬럼을 구분 컬럼으로 사용해야함 단일 테이블 전략 전략을 싱글테이블로 바꾸면된다. 추가로 자식엔티티에서 기본키 칼럼명이 다르면 @PrimaryKeyJoinColumn을 쓴다. 구현 클래스마다 테이블 전략 이전략은 이름도 길어서 제일 안쓸거 같다.. 책에서는 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않은 전략이라고 함 7.2 @MappedSuperclass7.1에선 테이블과의 상속관계를 다뤘는데 이건 순수히 객체의 상속만을 할땐 @MappedSuperclass를 씀 추상 클래스와 비슷하다고 생각하면 됨 123456789101112131415161718192021@MappedSuperclasspublic class BaseEntity &#123;@Id @GeneratedValueprivate Long id;private String name;&#125;@Entitypublic class Member extends BaseEntity &#123;//ID 상속//NAME 상속private String email;&#125;@Entity@AttributeOverride(name=\"id\", column=@Column(\"MEMBER_ID\"))public class Seller extends BaseEntity &#123;//ID 상속//NAME 상속private String shopName;&#125; 12@AttributeOverride@AttributeOverrides 어노테이션을 통해 상속받은 칼럼명을 재정의 할수도 있음. 7.3 복합 키와 식별 관계 매핑 식별 관계 비식별 관계 @IdClass와 @EmbeddedId 방식 2가지가 존재 한다. @IdClass는 테이블 친화적이고 @EmbeddedId는 객체 친화적 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//식별관계 IdClass@Entitypublic class Parent &#123;@Id @Column(name=\"PARENT_ID\")private String id;private String name;&#125;@Entity@IdClass(ChildId.class)public class Child&#123;@Id@ManyToOne@JoinColumn(name=\"PARENT_ID\")public Parent parent;@Id @Column(name=\"CHILD_ID\")private String ChildId;private String name;&#125;//자식IDpublic class ChildId implements Serializable&#123;//Child.parent 매핑private String parent;//Child.childId 매핑private String childId;//equals, hashcode&#125;@Entitypublic class GrandChild&#123;@Id@ManyToOne@JoinColumns(&#123;@JoinColumn(name=\"PARENT_ID\"),@JoinColumn(name=\"CHILD_ID\")&#125;)private Child child;@Id @Column(name=\"GRANDCHILD_ID\")private String id;private String name;&#125;//손자 IDpublic class GrandChildId implements Serializable&#123;//GrandChild.child 매핑private ChildId child;//GrandChild.id 매핑private String Id;//equals, hashcode&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//식별관계 EmbeddedId@Entitypublic class Parent &#123;@Id @Column(name=\"PARENT_ID\")private String id;private String name;&#125;@Entitypublic class Child&#123;@EmbeddedIdprivate ChildId id;//ChildId.prentId 매핑@MapsId(\"prentId\")@ManyToOne@JoinColumn(name=\"PARENT_ID\")public Parent parent;private String name;&#125;//자식ID@Embeddablepublic class ChildId implements Serializable&#123;//@MapsId(\"parentId\")로 매핑private String parentId;@Column(name=\"CHILD_ID\")private String id;//equals, hashcode&#125;@Entitypublic class GrandChild&#123;@EmbeddedIdGrandChildId id;//GrandChildId.childId 매핑@MapsId(\"childId\")@ManyToOne@JoinColumns(&#123;@JoinColumn(name=\"PARENT_ID\"),@JoinColumn(name=\"CHILD_ID\")&#125;)private Child child;private String name;&#125;//손자 ID@Embeddablepublic class GrandChildId implements Serializable&#123;//@MapsId(\"childId\") 매핑private ChildId childId;@Column(name=\"GRANDCHILD_ID\")private String Id;//equals, hashcode&#125; 123456789101112131415161718192021222324252627282930313233343536//비식별 관계@Entitypublic class Parent &#123;@Id @GeneratedValue@Column(name=\"PARENT_ID\")private Long id;private String name;&#125;@Entitypublic class Child&#123;@Id @GeneratedValue@Column(name=\"CHILD_ID\")private Long id;//ChildId.prentId 매핑@ManyToOne@JoinColumn(name=\"PARENT_ID\")public Parent parent;private String name;&#125;@Entitypublic class GrandChild&#123;@Id @GeneratedValue@Column(name=\"GRANDCHILD_ID\")private Long id;@ManyToOne@JoinColumn(name=\"CHILD_ID\")private Child child;private String name;&#125; 식별 관계인 경우는 복합키가 필요함으로 키관련 클래스들도 생성해야 하지만 비식별관계는 키가 1개임으로 복합키클래스를 만들 필요가 없다. 참고로 키가 1개일 경우만 @GeneratedValue 를 사용할수 있다. 책에서는 비식별 관계를 사용하고 기본 키는 LONG 타입의 대리 키를 사용 하는것이 좋다고 소개 되어있습니다. 그 이유는 비즈니스와 관련이 없어 변경시에 유연한 대처가 가능 Long 타입의 경우 약 920경의 숫자를 담을수 있음. 나머지 조인테이블과 엔티티 하나에 여러 테이블 매핑이 있지만 비주류라서 소개 하지 않겠습니다. 출처 : 자바 ORM 표준 JPA 프로그래밍 김영한","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"엔티티의 연관관계 매핑시 고려할거 정리","slug":"jpa-basic-05","date":"2017-01-15T13:58:00.000Z","updated":"2021-04-02T02:38:07.048Z","comments":true,"path":"2017/01/15/jpa-basic-05/","link":"","permalink":"http://kji6252.github.io/2017/01/15/jpa-basic-05/","excerpt":"고려할건 크게 3가지다. 다중성 단방향, 양방향 연관관계의 주인 다중성 : 두 엔티티의 연관관계를 나타냄 (예: 일대다,다대일,일대일,다대다) 다중성을 판단하기 힘들땐 반대방향을 생각하면 됨 (일대다의 반대는 다대일) 다대일(@ManyToOne) 일대다(@OneToMany) 일대일(@OneToOne) 다대다(@ManyToMany)","text":"고려할건 크게 3가지다. 다중성 단방향, 양방향 연관관계의 주인 다중성 : 두 엔티티의 연관관계를 나타냄 (예: 일대다,다대일,일대일,다대다) 다중성을 판단하기 힘들땐 반대방향을 생각하면 됨 (일대다의 반대는 다대일) 다대일(@ManyToOne) 일대다(@OneToMany) 일대일(@OneToOne) 다대다(@ManyToMany) 단방향, 양방향 객체의 참조용필드를 한쪽만 가지고 조회하면 단방향 객체의 참조용필드를 양쪽에 가지고 조회하면 양방향 데이터베이스 테이블은 외래키로 조회를하기에 방향이 없다. 연관관계의 주인 : JPA는 두 객체 연관관계 중 하나를 정해서 데이터베이스 외래 키를 관리하는데 이것을 연관관계의 주인이라 한다. 외래 키를 가진 테이블과 매핑한 엔티티가 외래 키를 관리하는 게 효율적이므로 보통 이곳을 연관관계의 주인으로 선택한다. 연관관계의 주인이 아닌곳은 mappedBy를 써서 연관관계의 주인 필드 이름값을 입력해야 한다. 출처 : 자바 ORM 표준 JPA 프로그래밍 김영한","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"연관관계 기초","slug":"jpa-basic-04","date":"2017-01-15T00:14:00.000Z","updated":"2021-04-02T02:38:07.048Z","comments":true,"path":"2017/01/15/jpa-basic-04/","link":"","permalink":"http://kji6252.github.io/2017/01/15/jpa-basic-04/","excerpt":"객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표다.* 핵심 키워드 방향(Direction): [단방향, 양방향]이 있다. 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다. 다중성(Multiplicty): [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)] 다중성이 있다. 연관관계의 주인(Owner): 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.","text":"객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표다.* 핵심 키워드 방향(Direction): [단방향, 양방향]이 있다. 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다. 다중성(Multiplicty): [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)] 다중성이 있다. 연관관계의 주인(Owner): 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다. 5.1 단방향 연관관계 객체 연관관계 : 회원 객체는 Member.team 필드(멤버변수)로 팀 객체와 연관관계를 맺는다. (단방향) 테이블 연관관계 : 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺는다. (양방향) 객체 연관관계와 테이블 연관관계의 가장 큰 차이참조를 통한 연관관계는 언제나 단방향이다. 객체간에 연간관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다. 결국 연관관계를 하나 더 만들어야 한다. 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라 한다. 하지만 정확히 이야기하면 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개다. 반면에 테이블은 외래 키 하나로 양방향으로 조인할 수 있다. 5.1.3 객체 관계 매핑 객체 연관관계: 회원 객체의 Member.team 필드 사용 테이블 연관관계: 회원 테이블의 MEMBER.TEAM_ID 외래 키 컬럼을 사용 @ManyToOne: 이름 그대로(N:1) 관계라는 매핑 정보다. 회원과 팀은 다대일 관계다. 연관관계를 매핑할 때 이렇게 다중성을 나타내는 어노테이션을 필수로 사용해야 한다. @JoinColumn: 조인 컬럼은 외래 키를 매핑할 때 사용한다. name 속성에는 매핑할 외래 키 이름을 지정한다. 회원과 팀 테이블은 TEAM_ID 외래 키로 연관관계를 맺으므로 이 값을 지정하면 된다. 이 어노테이션은 생략할 수 있다. 5.3 양방향 연관관계 단방향 연관관계에서 Team 객체에 List members를 추가 하였다. Member에서는 @ManyToOne을 했으므로 반대편인 Team에서는 @OneToMany를 주어 양방향 연관관계를 지정 하였다. 엄밀히 이야기하면 양방향 연관관계 라는 것은 없다. 서로 다른 단방향 연관관계 2개를 잘 묶어 양방향인 것처럼 보이게 할 뿐이다. 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에 차이가 발생한다. 두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인 이라 한다. 연관관계 주인에 대해연관관계의 주인이 아닌쪽에 mappedBy 속성을 넣어줘서 주인이 아님을 표시 하면 된다. 연관관계의 주인은 외래키를 관리 하며 등록,수정,삭제가 가능하고 아닌쪽은 읽기만 가능하다. 기능\\연관관계 주인 주인X 읽기 O O 등록,수정,삭제 O X 외래키 O X 참고데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다. 다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다. 따라서 @ManyToOne에는 mappedBy 속성이 없다. 연관관계 기초 정리양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것뿐이다. 단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료 되었다. 단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가된다. 양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 한다. 출처 : 자바 ORM 표준 JPA 프로그래밍 김영한","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"엔티티 매핑","slug":"jpa-basic-03","date":"2016-08-10T03:02:00.000Z","updated":"2021-04-02T02:38:07.048Z","comments":true,"path":"2016/08/10/jpa-basic-03/","link":"","permalink":"http://kji6252.github.io/2016/08/10/jpa-basic-03/","excerpt":"객체와 테이블 매핑 : @Entity, @Table 기본 키 매핑 : @Id 필드와 컬럼 매핑 : @Column 연관관계 매핑 : @ManyToOne, @JoinColumn @Entity(클래스) : 테이블과 매핑할 클래스, JPA가 관리함 @Table(클래스) : 엔티티와 매핑할 테이블 (생략시 엔티티명으로 적용) uniqueConstraints(DDL) : DDL생성시 유니크 제약조건 만듬. @Column(필드) : 칼럼을 매핑한다.","text":"객체와 테이블 매핑 : @Entity, @Table 기본 키 매핑 : @Id 필드와 컬럼 매핑 : @Column 연관관계 매핑 : @ManyToOne, @JoinColumn @Entity(클래스) : 테이블과 매핑할 클래스, JPA가 관리함 @Table(클래스) : 엔티티와 매핑할 테이블 (생략시 엔티티명으로 적용) uniqueConstraints(DDL) : DDL생성시 유니크 제약조건 만듬. @Column(필드) : 칼럼을 매핑한다. nullable(DDL) : false 시 not null 기본값(true) length(DDL) : 문자 길이 제약조건, String 타입에만 사용한다. 기본값(255) precision,scale(DDL) : BigDecimal(BigInteger) 타입 사용 precision은 소수점 포함 전체길이, scale은 소수의 자릿수 double,float엔 적용 안됨 @Enumerated(필드) : 자바의 enum 타입을 매핑한다. EnumType.ORDINAL enum 순서를 DB 저장 (0,1,2,3) EnumType.STRING enum 이름을 DB 저장 (COUNT,ID,AGE) @Temporal(필드) : 날짜 타입을 매핑한다. TemporalType.DATE (yyyy-mm-dd) TemporalType.TIME (HH-MM-ss) TemporalType.TIMESTAMP (yyyy-mm-dd HH-MM-ss) @Lob(필드) : BLOB, CLOB 타입을 매핑한다.(속성없이 자바타입으로 결정) CLOB : String, char[], java.sql.CLOB BLOB : byte[], java.sql.BLOB @Transient(필드) : 특정 필드를 데이터베이스에 매핑하지 않는다. 데이터베이스 스키마 자동 생성persistence.xml 에 create, create-drop, update, validate, none 등의 값을 삽입 할수 있다. 개발이나 테스트에서 쉽게 디비스키마를 자동 생성할 수 있다. 1&lt;property name=\"hibernate.hbm2ddl.auto\" value=\"create\"/&gt; create : drop create 실행 create-drop : drop create drop 실행 update : 변경분만 적용 (테이블 추가, 칼럼추가, 제약조건 추가 등) validate : 디비정보와 비교하여 다를시 프로그램 종료 none : 아무일도 하지 않음 1&lt;property name=\"hibernate.ejb.naming_strategy\" value=\"org.hibernate.cfg.ImprovedNamingStrategy\"/&gt; 이 옵션 추가시 자바에선 카멜식 디비에선 언더스코어 표기법으로 매핑 된다. 엔티티 매핑 정리 이 장을 통해 객체와 테이블 매피으 기본키 매핑, 필드와 컬럼매핑에 대해 알아보았다. 그리고 데이터베이스 스키마 자동 생성하기 기능도 알아보았는데, 이 기능을 사용하면 엔티티 객체를 먼저 만들고 테이블은 자동으로 생성할 수 있다. JPA는 다양한 기본 키 매핑 전략을 지원한다. 기본 키를 애플리케이션에서 직접 할당하는 방법부터 데이터베이스가 제공하는 기본 키를 사용하는 SEQUENCE, IDENTITY, TABLE 전략에 대해서도 알아보았다. 이 장에서 다룬 회원 엔티티는 다른 엔티티와 관계가 없다. 회원이 특정 팀에 소속해야 한다면 어떻게 해야 할가? 다음 장을 통해 연관관계가 있는 엔티티들을 어떻게 매핑하는지 알아보자. 그 전에 다음 실전 예제를 꼭 따라해보자. 실전 예제는 이 장에서 학습한 내용을 소화할 수 있게 도와준다. 그리고 JPA를 사용해서 실제 엔티티를 어떻게 모델링해야 할지 감을 잡을 수 있게 해준다. 실전 예제의 도메인 모델은 각 장을 진행할 때마다 점진적으로 성장한다. 그리고 이렇게 완성한 도메인 모델로 11장의 웹 애플리케이션을 개발한다. 그러므로 실전 예제는 꼭 실행해보자. 출처 : 자바 ORM 표준 JPA 프로그래밍 (김영한)","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"영속성 관리","slug":"jpa-basic-02","date":"2016-08-10T02:42:00.000Z","updated":"2021-04-02T02:38:07.048Z","comments":true,"path":"2016/08/10/jpa-basic-02/","link":"","permalink":"http://kji6252.github.io/2016/08/10/jpa-basic-02/","excerpt":"개요 EntityManagerFactory : EntityManager를 만드는 공장. 애플리케이션에서 persistens.xml의 persistens-unit갯수 만큼만 있어야함 EntityManager : 요청이 올때마다 생성 해도 됨.(커넥션풀에서 커넥션 한개씩 이라고 생각해도 될듯) persistence context(영속성 컨텍스트) : ‘엔티티를 영구 저장하는 환경’ 특징 영속 상태인 엔티티는 식별자 값이 반드시 있어야 한다. (식별자 값이없으면 예외 발생) 트랜잭션 커밋 하는 순간 DB 반영힘 이를 플러시(flush)라 함","text":"개요 EntityManagerFactory : EntityManager를 만드는 공장. 애플리케이션에서 persistens.xml의 persistens-unit갯수 만큼만 있어야함 EntityManager : 요청이 올때마다 생성 해도 됨.(커넥션풀에서 커넥션 한개씩 이라고 생각해도 될듯) persistence context(영속성 컨텍스트) : ‘엔티티를 영구 저장하는 환경’ 특징 영속 상태인 엔티티는 식별자 값이 반드시 있어야 한다. (식별자 값이없으면 예외 발생) 트랜잭션 커밋 하는 순간 DB 반영힘 이를 플러시(flush)라 함 장점 1차 캐시 : 영속성 컨텍스트에서 맵형태로 id(식별자)와 엔티티를 관리 동일성 : 1차 캐시에 있는 같은 엔티티를 반환 함으로 동일성 보장(==) 트랜잭션을 지원 하는 쓰기 지연 : 커밋 전까지 inser,update,delete문을 쓰기 지연 SQL 저장소에 담아두고 한번에 내보낸다. 변경 감지 : 최초 상태를 복사(스냅샷) 해두는데 이를 비교하여 변경을 감지함 변경이 감지되면 해당 엔티티로 update 문을 DB에 보냄 지연 로딩 : 연관관계로 매핑된 엔티티의 경우 조회할때 데이터를 가져옴 엔티티 생명주기 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태 영속(managed) : 영속성 컨텍스트에 저장된 상태 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 삭제(removed) : 삭제된 상태 영속성 관리 정리 엔티티 매니저는 엔티티 매니저 팩토리에서 생성한다. 자바를 직접 다루는 J2SE환경에서는 엔티티 매니저를 만들면 그 내부에 영속성 컨텍스트도 함께 만들어진다. 이 영속성 컨텍스트는 엔티티 매니저를 통해서 접근할 수 있다. 영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다. 영속성 컨텍스트 덕분에 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연로딩 기능을 사용할 수 있다. 영속성 컨텍스트에 저장한 엔티티는 플러시 시점에 데이터베이스에 반영되는데 일반적으로 트랜잭션을 커밋할 때 영속성 컨텍스트가 플러시 된다. 영속성 컨텍스트가 관리하는 엔티티를 영속 상태의 엔티티라 하는데, 영속성 컨텍스트가 해당 엔티티를 더 이상 관리하지 못하면 그 엔티티는 준영속 상태의 엔티티라 한다. 준영속 상태의 엔티티는 더는 영속성 컨텍스트가 제공하는 1차 캐시, 동일성 보장 트랜잭션을 지원하는 쓰기 지연, 변경감지, 지연 로딩 같은 기능들을 사용할 수 없다. 출처 : 자바 ORM 표준 JPA 프로그래밍 (김영한)","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"JPA 소개 JPA 시작","slug":"jpa-basic-01","date":"2016-08-03T00:47:00.000Z","updated":"2021-04-02T02:38:07.048Z","comments":true,"path":"2016/08/03/jpa-basic-01/","link":"","permalink":"http://kji6252.github.io/2016/08/03/jpa-basic-01/","excerpt":"1. JPA 소개하이버네이트 오픈소스 ORM 프레임워크가 나온 후 자바빈이 버려지고 하이버네이트, 이클립스링크등의 ORM 프레임워크로 자바 ORM 표준을 정한것이 JPA 이다. JPA(Java Persistent API) : 관계형 데이터베이스에 접근하기 위한 표준 ORM 기술을 제공하며, 기존에 EJB에서 제공되던 엔터티 빈(Entity Bean)을 대체하는 기술이다. JPA는 JSR 220에서 정의된 EJB 3.0 스펙의 일부로 정의가 되어 있지만, JPA는 EJB 컨테이너에 의존하지 않으며 EJB, 웹 모듈 및 Java SE 클라이언트에서 모두 사용이 가능하다. 또한, JPA는 사용자가 원하는 퍼시스턴스 프로바이더 구현체를 선택해서 사용할 수 있다. ORM(Object Relational Mapping) : 관계형 데이터베이스를 객체에 매핑. 왜 JPA를 사용해야 하는가? 생산성 : 지루하고 반복적인 CRUD 코드를 직접 작성하지 않아도 된다. 유지보수 : 엔티티에 필드를 하나만 추가해줘도 등록, 수정, 조회 자동으로 매핑 된다. 패러다임의 불일치 해결 : 관계형 DB로 객체지향적인 코딩이 가능해 진다. 성능 : 한번 조회한건 캐시를 사용함으로 똑같은걸 2번 조회 하지 않는다.(1차캐시) 데이터 접근 추상화와 벤더 독립성 : 방언을 통해 자유자제로 다른 DB로 변경이 가능 하다. 표준 : 자바 진영의 ORM 표준이다.","text":"1. JPA 소개하이버네이트 오픈소스 ORM 프레임워크가 나온 후 자바빈이 버려지고 하이버네이트, 이클립스링크등의 ORM 프레임워크로 자바 ORM 표준을 정한것이 JPA 이다. JPA(Java Persistent API) : 관계형 데이터베이스에 접근하기 위한 표준 ORM 기술을 제공하며, 기존에 EJB에서 제공되던 엔터티 빈(Entity Bean)을 대체하는 기술이다. JPA는 JSR 220에서 정의된 EJB 3.0 스펙의 일부로 정의가 되어 있지만, JPA는 EJB 컨테이너에 의존하지 않으며 EJB, 웹 모듈 및 Java SE 클라이언트에서 모두 사용이 가능하다. 또한, JPA는 사용자가 원하는 퍼시스턴스 프로바이더 구현체를 선택해서 사용할 수 있다. ORM(Object Relational Mapping) : 관계형 데이터베이스를 객체에 매핑. 왜 JPA를 사용해야 하는가? 생산성 : 지루하고 반복적인 CRUD 코드를 직접 작성하지 않아도 된다. 유지보수 : 엔티티에 필드를 하나만 추가해줘도 등록, 수정, 조회 자동으로 매핑 된다. 패러다임의 불일치 해결 : 관계형 DB로 객체지향적인 코딩이 가능해 진다. 성능 : 한번 조회한건 캐시를 사용함으로 똑같은걸 2번 조회 하지 않는다.(1차캐시) 데이터 접근 추상화와 벤더 독립성 : 방언을 통해 자유자제로 다른 DB로 변경이 가능 하다. 표준 : 자바 진영의 ORM 표준이다. JPA 소개 정리지금까지 SQL을 직접 다룰 때 발생하는 다양한 문제와 객체지향 언어와 관계형 데이터베이스 사이의 패러다임 불일치 문제를 설명했다. 그리고 JPA가 각 문제를 어떻게 해결하는지 알아보았다. 마지막으로 JPA가 무엇인지 설명하고 JPA의 장점을 소개했다. JPA에 관한 자세한 내용은 책 전반에 걸쳐서 차근차근 살펴보기로 하고, 우선은 다음 장에서 테이블 하나를 등록/수정/삭제/조회하는 간단한 JPA 애플리케이션을 만들어보자. 2. JPA 시작============== 책에서는 이클립스로 하지만 이책의 마지막 예제가 스프링인만큼 미리 STS를 깔아서 시작하겠습니다. IDE : https://spring.io/tools/sts/allgithub : https://github.com/holyeye/jpabookH2 DB : http://www.h2database.com/html/download.htmlJDK : http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html JDK 가 없으신분들은 JDK 를 다운로드 받아서 설치 합니다. IDE를 다운로드 받아서 압축을 해제 한 후 퍼시펙티브에서 GIT를 열어줍니다. 메이븐 프로젝트로 추가 하면 됩니다. 그 후 H2 DB를 인스톨 한 후 H2 Consol 을 실행 합니다. 셋팅을 완료 후 Crtl + F11 키를 눌러서 실행 하여 콘솔창에 실행 된 예제를 확인 하실 수 있습니다. 아래의 예제 프로젝트 목록에서 공부 하고 싶은 부분의 프로젝트를 보면서 공부 하면 좋을거 같습니다.github : https://github.com/holyeye/jpabook 구분 예제 설명 시작하기 ch02-jpa-stat1 JPA시작 ch04-jpa-stat2 JPA 시작 예제에 매핑 추가 도메인 모델 설계 ch04-model1 테이블과 엔티티 기본 매핑 ch05-model2 일대다, 다대일 연관관계 매핑 ch06-model3 일대일, 다대다 연관관계 매핑 ch07-model4 상속 관계 매핑 ch08-model5 지연 로딩, 영속성 전이 설정 ch09-model6 값 타입 매핑 활용 ch11-jpa-shop JPA와 스프링 프레임워크를 사용해서 실제 동작하는 웹 애플리케이션 개발 ch12-springdata-shop 앞 예제에 스프링 데이터 JPA와 QueryDSL을 추가 JPA 시작 정리JPA를 사용하기 위한 개발 환경을 설정하고, JPA를 사용해서 객체 하나를 테이블에 등록/수정/삭제/조회하는 간단한 애플리케이션을 만들어 보았다. JPA가 반복적인 JDBC API와 결좌 값 매핑을 처리해준 덕분에 코드량이 상당히 많이 줄어든 것은 물론이고 심지어 SQL도 작성할 필요가 없었다. 하지만 코드량을 줄이고 SQL을 자동 생성하는 것은 JPA가 제공하는 전체 기능 중 일부에 불과하다. 다음 장을 통해 JPA의 핵심 기능인 영속성 관리에 대해 알아보자.","categories":[{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/categories/JPA/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"JPA","slug":"JPA","permalink":"http://kji6252.github.io/tags/JPA/"},{"name":"ORM","slug":"ORM","permalink":"http://kji6252.github.io/tags/ORM/"}]},{"title":"스프링부트 jre 2개 추가 오류","slug":"spring-boot-jre-error","date":"2016-06-11T20:42:00.000Z","updated":"2021-04-02T02:38:07.051Z","comments":true,"path":"2016/06/12/spring-boot-jre-error/","link":"","permalink":"http://kji6252.github.io/2016/06/12/spring-boot-jre-error/","excerpt":"최근에 스프링 부트 그래들 프로젝트를 생성시에 jre 2개가 잡히는 문제가 발생하였습니다. 그래서 jdk를 지웠다 다시 설치 해보기도 하였으며 결국 sts를 지우고 다시 깔았지만 동일한 현상이 지속되었습니다. 그러던중 .classpath에 들어가서 확인해보니 자바 라이브러리를 불러오는 부분에서","text":"최근에 스프링 부트 그래들 프로젝트를 생성시에 jre 2개가 잡히는 문제가 발생하였습니다. 그래서 jdk를 지웠다 다시 설치 해보기도 하였으며 결국 sts를 지우고 다시 깔았지만 동일한 현상이 지속되었습니다. 그러던중 .classpath에 들어가서 확인해보니 자바 라이브러리를 불러오는 부분에서 12345//변경 전&lt;classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8\"/&gt;//변경 후&lt;classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8/\"/&gt; 맨뒤 / 가 있고 없는 차이가 있길래 build.gradle에 들어가 이클립스 클래스 패스 설정해주는 부분에 /를 삽입하고 난 뒤 Refresh All 을 하였습니다. jre가 2개 에서 1개로 바뀌었습니다.","categories":[{"name":"스프링","slug":"스프링","permalink":"http://kji6252.github.io/categories/스프링/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://kji6252.github.io/tags/Spring-Boot/"}]},{"title":"이클립스 프로젝트 자바스크립트 플러그인 추천!","slug":"eclipse-plugin-recommend","date":"2016-05-27T18:52:00.000Z","updated":"2021-04-02T02:38:07.047Z","comments":true,"path":"2016/05/28/eclipse-plugin-recommend/","link":"","permalink":"http://kji6252.github.io/2016/05/28/eclipse-plugin-recommend/","excerpt":"이클립스에서 스프링 이나 JSP 프로젝트를 진행 하였을 경우 자바스크립트코딩을 할경우 컨트롤 + 스페이스 자동완성 기능을 사용하지 못하여서 불편함이 있었습니다. 그래서 찾은 플러그인 중에 추천해줄 만한 플러그인을 찾아 공유 하고 싶어 글을 작성 하게 되었습니다. 1. 설치 Tern Eclipse IDE 를 인스톨을 눌러서 설치 합니다. ※저는 느린 인터넷이라 그런지 설치시 20분이 소요 되었습니다… ㅠ","text":"이클립스에서 스프링 이나 JSP 프로젝트를 진행 하였을 경우 자바스크립트코딩을 할경우 컨트롤 + 스페이스 자동완성 기능을 사용하지 못하여서 불편함이 있었습니다. 그래서 찾은 플러그인 중에 추천해줄 만한 플러그인을 찾아 공유 하고 싶어 글을 작성 하게 되었습니다. 1. 설치 Tern Eclipse IDE 를 인스톨을 눌러서 설치 합니다. ※저는 느린 인터넷이라 그런지 설치시 20분이 소요 되었습니다… ㅠ 2. 적용하기 적용을 원하는 프로젝트에 우클릭 후 Configure &gt; Convert to Tern Project… 를 눌러 줍니다. 프로젝트에 자동완성으로 사용할 자바스크립트 라이브러리들을 추가 해줍니다.(자동완성 기능만 제공하지 실제 라이브러리를 추가 하는거 같진 않습니다…) 3. 사용하기 적용 후에 확인하기 위해 jQuery 라이브러리를 추가 한 뒤 $. 를 입력하고 컨트롤 + 스페이스를 눌러서 잘 적용 된걸 확인 하였습니다. 그리고 중간에 다른 라이브러리의 자동완성 기능을 추가 하기 위해선 프로젝트 우클릭 후Properties &gt; Tern &gt; Modules 에 가면 추가 추가 및 제거가 가능하며 그 이외에도 또다른 라이브러리 추가도 가능 한거 같습니다.","categories":[{"name":"이클립스","slug":"이클립스","permalink":"http://kji6252.github.io/categories/이클립스/"}],"tags":[{"name":"Plugin","slug":"Plugin","permalink":"http://kji6252.github.io/tags/Plugin/"}]},{"title":"오픈 그래프 프로토콜(Open Graph protocol)","slug":"open-graph-protocol","date":"2016-04-23T21:18:00.000Z","updated":"2021-04-02T02:38:07.051Z","comments":true,"path":"2016/04/24/open-graph-protocol/","link":"","permalink":"http://kji6252.github.io/2016/04/24/open-graph-protocol/","excerpt":"개요 오픈 그래프 프로토콜은 페이스북에서 정의된 메타 태그 프로토콜 이라고 한다.페이스북,트위터에서 링크 삽입시 해당사이트의 메타태그를 긁어와서 사이트정보를 미리 보여주는 정도의 용도로 생각하면 될거 같습니다.","text":"개요 오픈 그래프 프로토콜은 페이스북에서 정의된 메타 태그 프로토콜 이라고 한다.페이스북,트위터에서 링크 삽입시 해당사이트의 메타태그를 긁어와서 사이트정보를 미리 보여주는 정도의 용도로 생각하면 될거 같습니다.적용 예)1234&lt;meta property=\"og:title\" content=\"The Rock\" /&gt;&lt;meta property=\"og:type\" content=\"video.movie\" /&gt;&lt;meta property=\"og:url\" content=\"http://www.imdb.com/title/tt0117500/](http://www.imdb.com/title/tt0117500/\" /&gt;&lt;meta property=\"og:image\" content=\"http://ia.media-imdb.com/images/rock.jpg](http://ia.media-imdb.com/images/rock.jpg\" /&gt; 오픈 그래프 프로토콜 예시)예시 링크 : https://www.youtube.com/watch?v=B2z5C_Mesx0 트위터 예) 페이스북 예) 카카오톡 예) 위의 정보를 어떻게 가져와서 보여주는지 알아 보겠습니다. 오픈 그래프 프로토콜을 사용해 보자.http://ogp.me/ 사이트를 방문 하면 Implementations 메뉴에 디버깅 툴 및 플러그인 등 각종 링크가 있습니다. 여기서 Facebook Object Debugger - Facebook’s official parser and debugger 에 대해 알아보고 어떻게 적용할지 알아 보겠습니다. Facebook Object Debugger - Facebook’s official parser and debugger는 페이스북에서 제공하는 오픈 그래프 프로토콜이 어떤건지 알수 있는 디버깅 툴 입니다. 해당페이지에 접속하여서 url을 넣고 Debug버튼 페이스북의 링크 공유시 어떻게 나올지 나타내게 됩니다. Facebook Object Debugger 예) 간단한 정보만 필요함으로 직접 작성하였습니다. 12345678910111213141516171819202122232425Document doc;String url = \"[https://www.youtube.com/watch?v=B2z5C_Mesx0](https://www.youtube.com/watch?v=B2z5C_Mesx0)\";Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;String,List&lt;String&gt;&gt;();try &#123; doc = Jsoup.connect(url).get(); Elements ogElements = doc.select(\"meta[property^=og], meta[name^=og]\"); for (Element e : ogElements) &#123; String target=target = e.hasAttr(\"property\") ? \"property\":\"name\"; if(!result.containsKey(e.attr(target)))&#123; result.put(e.attr(target), new ArrayList&lt;String&gt;()); &#125; result.get(e.attr(target)).add(e.attr(\"content\")); &#125; for(String s : result.keySet()) System.out.println(s + \" : \" + result.get(s));&#125; catch (Exception e)&#123; e.printStackTrace();&#125; 실행결과123456789101112og:image : [[https://i.ytimg.com/vi/B2z5C_Mesx0/hqdefault.jpg](https://i.ytimg.com/vi/B2z5C_Mesx0/hqdefault.jpg)]og:type : [video]og:site_name : [YouTube]og:title : [SNL코리아7 - 인스턴트 LOVE &quot;3분 남친&quot; by 에릭남, 정이랑 (2016.04.16)]og:video:type : [text/html, application/x-shockwave-flash]og:video:height : [720, 720]og:video:url : [[https://www.youtube.com/embed/B2z5C_Mesx0](https://www.youtube.com/embed/B2z5C_Mesx0), [http://www.youtube.com/v/B2z5C_Mesx0?version=3&amp;autohide=1](http://www.youtube.com/v/B2z5C_Mesx0?version=3&amp;autohide=1)]og:url : [[https://www.youtube.com/watch?v=B2z5C_Mesx0](https://www.youtube.com/watch?v=B2z5C_Mesx0)]og:video:secure_url : [[https://www.youtube.com/embed/B2z5C_Mesx0](https://www.youtube.com/embed/B2z5C_Mesx0), [https://www.youtube.com/v/B2z5C_Mesx0?version=3&amp;autohide=1](https://www.youtube.com/v/B2z5C_Mesx0?version=3&amp;autohide=1)]og:video:tag : [SNL코리아7, 인스턴트 LOVE 3분 남친, 에릭남, 정이랑, 2016.04.16]og:description : [SNL코리아7 - 인스턴트 LOVE &quot;3분 남친&quot; by 에릭남, 정이랑 (2016.04.16) #일부 국가 차단으로 다시 업로드 했습니다 ^^]og:video:width : [1280, 1280] 추가로 자바스크립트 적용 소스도 올리겠습니다. 유튜브 비디오 처리랑 일반 웹사이트만 추가했습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546this.ajaxUrlConnet = function (data) &#123; $.ajax(&#123; url: '/tbbswrite/opengraph', method: \"GET\", async: false, cache: false, contentType: true, processData: true, data: &#123;'url': data&#125; &#125;).done(function(c) &#123; $.each(c, function(key,value)&#123; console.log(key + ' : ' + value); &#125;) var html=''; if('video'.indexOf(c['og:type'][0]) &gt;= 0)&#123; html+='&lt;pre style=\"width: 300px;overflow: hidden;\" onclick=\"location.href=\\''+c['og:url'][0]+'\\'\"&gt;'; if( !(c['og:video:secure_url'][0] === undefined))&#123; html+='&lt;object data=\"'+c['og:video:secure_url'][0]+'\"&gt;&lt;/object&gt;'; &#125; html+='&lt;h1&gt;&lt;b&gt;'+c['og:title'][0]+'&lt;/b&gt;&lt;/h1&gt;'; if( !(c['og:description'] === undefined))&#123; html+='&lt;p&gt;'+c['og:description']+'&lt;/p&gt;'; &#125; html+='&lt;p&gt;&lt;a href=\"'+c['og:url'][0]+'\"&gt;'+c['og:url'][0]+'&lt;/a&gt;&lt;/p&gt;'; html+='&lt;/pre&gt;'; context.invoke('editor.pasteHTML', html); &#125; else &#123; html+='&lt;pre style=\"width: 300px;overflow: hidden;\" onclick=\"location.href=\\''+c['og:url'][0]+'\\'\"&gt;'; if( !(c['og:image'][0] === undefined))&#123; html+='&lt;img src=\"'+c['og:image'][0]+'\" style=\"width: 100%;height: 100%;\" /&gt;'; &#125; html+='&lt;p&gt;&lt;h1&gt;&lt;b&gt;'+c['og:title'][0]+'&lt;/b&gt;&lt;/h1&gt;&lt;/p&gt;'; if( !(c['og:description'] === undefined))&#123; html+='&lt;p&gt;'+c['og:description']+'&lt;/p&gt;'; &#125; html+='&lt;p&gt;&lt;a href=\"'+c['og:url'][0]+'\"&gt;'+c['og:url'][0]+'&lt;/a&gt;&lt;/p&gt;'; html+='&lt;/pre&gt;'; context.invoke('editor.pasteHTML', html); &#125; &#125;).fail(function() &#123; alert('error = ' + data); &#125;);&#125; 해당 프로젝트는 github에 올려놓았습니다. 문제점이 있거나 잘못된 코딩습관이 있으면 코멘트 부탁드리겠습니다^^ github : https://github.com/kji6252/JsoupOpenGrahpTest","categories":[{"name":"최신 기술","slug":"최신-기술","permalink":"http://kji6252.github.io/categories/최신-기술/"}],"tags":[{"name":"URL","slug":"URL","permalink":"http://kji6252.github.io/tags/URL/"},{"name":"Open Graph","slug":"Open-Graph","permalink":"http://kji6252.github.io/tags/Open-Graph/"}]},{"title":"자바스크립트 쿠키 간단 사용법","slug":"javascript-cookie","date":"2016-03-21T01:54:00.000Z","updated":"2021-04-02T02:38:07.048Z","comments":true,"path":"2016/03/21/javascript-cookie/","link":"","permalink":"http://kji6252.github.io/2016/03/21/javascript-cookie/","excerpt":"개요쿠키를 사용할일이 있어 공부를 하다가 정리 할겸 블로그에 작성 합니다.document.cookie 를 자바스크립트 콘솔에 입력하면 해당 도메인의 쿠키값들이 나옵니다.문자열형태로 나오며 “키=벨유; 키=벨유; 키=벨유” 형식으로 존재합니다. W3Schools를 보고 참조 하였습니다.http://www.w3schools.com/js/js_cookies.asp 쿠키값은 총 3개의 파라미터로 구성되며 키=벨유 : MAP형식으로 키와 벨유를 저장 expires=Date타입값 : 쿠키 제한 시간을 정함 path:쿠키 생성 위치 : 쿠키 생성 위치를 지정","text":"개요쿠키를 사용할일이 있어 공부를 하다가 정리 할겸 블로그에 작성 합니다.document.cookie 를 자바스크립트 콘솔에 입력하면 해당 도메인의 쿠키값들이 나옵니다.문자열형태로 나오며 “키=벨유; 키=벨유; 키=벨유” 형식으로 존재합니다. W3Schools를 보고 참조 하였습니다.http://www.w3schools.com/js/js_cookies.asp 쿠키값은 총 3개의 파라미터로 구성되며 키=벨유 : MAP형식으로 키와 벨유를 저장 expires=Date타입값 : 쿠키 제한 시간을 정함 path:쿠키 생성 위치 : 쿠키 생성 위치를 지정 편안하게 cookie플러그인을 사용하면 좋겠지만 간단하게 작성하는법에 대해 설명해 보겠습니다. 쿠키 생성 123456789var valueDate = new Date();//Date를 활용하여 원하는 쿠키유지시간 조절 가능valueDate.setDate(valueDate.getDate()+추가값);valueDate.setHours(valueDate.getHours()+추가값);valueDate.setMinutes(valueDate.getMinutes()+추가값);valueDate.setSeconds(valueDate.getSeconds()+추가값);document.cookie = 'username=John Doe; expires='+valueDate.toGMTString()+'; path=/'; Date값을 활용하여 원하는 시간쿠키를 유지하는게 가능합니다. 쿠키 삭제12//간단하게 new Date(0)을 넣어서 쿠키값을 삭제document.cookie = 'username=John Doe; expires='+new Date(0).toGMTString()+'; path=/'; 쿠키는 유지기간보다 낮으면 되므로 간단하게 new Date(0)을 넣어 처리 하면 삭제 됩니다. 쿠키 검색1document.cookie.indexOf('찾을쿠키명') &gt; -1 쿠키도 문자열로 되어있기 때문에 문자열 탐색에 쓰이는 함수를 똑같이 사용-1이면 없음 0이상으면 해당 문자열의 첫번째 자리값 반환 쿠키 값 얻어오기12345var cookie = document.cookie;var startIndexOf = cookie.indexOf('찾을쿠키명 ');var endIndexOf = cookie.indexOf(';',startIndexOf);if(endIndexOf == -1)endIndexOf = cookie.length; //맨끝일경우;가 없으므로 맨마지막자리를 가져온다.cookie.substring(startIndexOf+'찾을쿠키명='.length, endIndexOf); 값을 가져 와서 쿠키값을 활용하면 될거 같습니다. 쿠키값 활용 예제하루 동안의 방문 횟수를 증가 시키는 로직을 짜보았습니다. 12345678910111213141516171819202122var cookie = document.cookie;var cookieName = 'VISIT_COUNT';var cookieNameIndexOf = cookie.indexOf(cookieName);var toDay = new Date();toDay.setHours(24);toDay.setMinutes(0);toDay.setSeconds(0);if(cookieNameIndexOf &gt; -1)&#123; var startIndexOf = cookieNameIndexOf; var endIndexOf = cookie.indexOf(';',startIndexOf); //-1일 경우 맨마지막에 위치 하므로 전체크기를 가져옴 if(endIndexOf == -1)endIndexOf = cookie.length; var bbsVisitCount = new Number(cookie.substring(startIndexOf + (cookieName+'=').length, endIndexOf)); cookie = cookieName + '=' + (++bbsVisitCount) + '; path=/; expires=' + toDay.toGMTString();&#125; else &#123; cookie = cookieName + '=0; path=/; expires=' + toDay.toGMTString();&#125;document.cookie = cookie; 적용된 스크린샷 F12키를 눌러 Resources &gt; Cookies 에서 직접 확인 할수 있습니다. 정리 자바스크립트 document.cookie 를 가져와 문자열 처리로 키=벨유 를 넣어 처리하면 되지만 저장된 쿠키의 쿠키유지시간을 가져오는방법은 모르겠음…","categories":[{"name":"자바스크립트","slug":"자바스크립트","permalink":"http://kji6252.github.io/categories/자바스크립트/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://kji6252.github.io/tags/Javascript/"},{"name":"Cookie","slug":"Cookie","permalink":"http://kji6252.github.io/tags/Cookie/"}]},{"title":"데이터 마이닝(빅 데이터?)","slug":"data-mining","date":"2016-02-10T18:43:00.000Z","updated":"2021-04-02T02:38:07.046Z","comments":true,"path":"2016/02/11/data-mining/","link":"","permalink":"http://kji6252.github.io/2016/02/11/data-mining/","excerpt":"데이터 마이닝(data mining)은 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아 내는 것이다. 다른 말로는 KDD(데이터베이스 속의 지식 발견, knowledge-discovery in databases)라고도 일컫는다. 데이터 마이닝은 통계학에서 패턴 인식에 이르는 다양한 계량 기법을 사용한다. 데이터 마이닝 기법은 통계학쪽에서 발전한 탐색적자료분석, 가설 검정, 다변량 분석, 시계열 분석, 일반선형모형 등의 방법론과 데이터베이스 쪽에서 발전한 OLAP (온라인 분석 처리:On-Line Analytic Processing), 인공지능 진영에서 발전한 SOM, 신경망, 전문가 시스템 등의 기술적인 방법론이 쓰인다. 데이터 마이닝의 응용 분야로 신용평점 시스템(Credit Scoring System)의 신용평가모형 개발, 사기탐지시스템(Fraud Detection System), 장바구니 분석(Market Basket Analysis), 최적 포트폴리오 구축과 같이 다양한 산업 분야에서 광범위하게 사용되고 있다.","text":"데이터 마이닝(data mining)은 대규모로 저장된 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아 내는 것이다. 다른 말로는 KDD(데이터베이스 속의 지식 발견, knowledge-discovery in databases)라고도 일컫는다. 데이터 마이닝은 통계학에서 패턴 인식에 이르는 다양한 계량 기법을 사용한다. 데이터 마이닝 기법은 통계학쪽에서 발전한 탐색적자료분석, 가설 검정, 다변량 분석, 시계열 분석, 일반선형모형 등의 방법론과 데이터베이스 쪽에서 발전한 OLAP (온라인 분석 처리:On-Line Analytic Processing), 인공지능 진영에서 발전한 SOM, 신경망, 전문가 시스템 등의 기술적인 방법론이 쓰인다. 데이터 마이닝의 응용 분야로 신용평점 시스템(Credit Scoring System)의 신용평가모형 개발, 사기탐지시스템(Fraud Detection System), 장바구니 분석(Market Basket Analysis), 최적 포트폴리오 구축과 같이 다양한 산업 분야에서 광범위하게 사용되고 있다.단점으로는, 자료에 의존하여 현상을 해석하고 개선하려고 하기 때문에 자료가 현실을 충분히 반영하지 못한 상태에서 정보를 추출한 모형을 개발할 경우 잘못된 모형을 구축하는 오류를 범할 수가 있다. 데이터마이닝은 데이터 분석을 통해 아래와 같은 분야에 적용하여 결과를 도출할 수 있다. 분류(Classification): 일정한 집단에 대한 특정 정의를 통해 분류 및 구분을 추론한다 (예: 경쟁자에게로 이탈한 고객) 군집화(Clustering): 구체적인 특성을 공유하는 군집을 찾는다. 군집화는 미리 정의된 특성에 대한 정보를 가지지 않는다는 점에서 분류와 다르다 (예 : 유사 행동 집단의 구분) 연관성(Association): 동시에 발생한 사건간의 관계를 정의한다. (예: 장바구니안의 동시에 들어 가는 상품들의 관계 규명) 연속성(Sequencing): 특정 기간에 걸쳐 발생하는 관계를 규명한다. 기간의 특성을 제외하면 연관성 분석과 유사하다 (예: 슈퍼마켓과 금융상품 사용에 대한 반복 방문) 예측(Forecasting): 대용량 데이터집합내의 패턴을 기반으로 미래를 예측한다 (예: 수요예측) 출처 : https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%A7%88%EC%9D%B4%EB%8B%9D http://www.dbguide.net/knowledge.db?cmd=view&amp;boardUid=177566 분류(Classification): 일정한 집단에 대한 특정 정의를 통해 분류 및 구분을 추론한다 그림 1. 신용도 분류 그림 2. 분류화 로직 출처 : http://www.slideshare.net/kwnam4u/01-41434457?from_action=save 모형의 평가 하나의 자료 분석시 여러가지 가능한 모형을 적합시키게 되는데 이중 최적의 모형 을 선택하기 위해 필요 모형의 평가 방법 – 예측력: 얼마나 잘 예측하는가 ? – 해석력: 모형이 입력/출력 변수간의 관계를 잘 설명하는가 ? – 효율성: 얼마나 적은 수의 입력변수로 모형을 구축했는가 ? – 안정성: 모집단의 다른 자료에 적용했을 때 같은 결과를 주는가 ? 모형의 평가: 어떤 모형이 랜덤하게 예측하는 모형보다 예측력이 우수한지, 그리 고 고려된 모형들 중 어느 모형이 가장 좋은 예측력을 보유하고 있는지를 비교 / 분석 출처 : http://datamining.dongguk.ac.kr/lectures/2011-1/dm/dm_notes_v0.5.pdf 의사결정트리(Decision Tree) 출처 : http://www.slideshare.net/kwnam4u/0601-41434770 http://datamining.dongguk.ac.kr/lectures/2011-1/dm/dm_notes_v0.5.pdf 연관성분석 데이터 안에 존재하는 항목간의 연관규칙 (association rule)을 발견하는 과정 연관규칙: 상품을 구매하거나 서비스를 받는 등의 일련의 거래나 사건들의 연관성 에 대한 규칙 연관성 분석을 마케팅에서 손님의 장바구니에 들어있는 품목간의 관계를 알아본다 는 의미에서 장바구니분석 (market basket analysis)이라고도 함 왜 연관성 분석을 하는가 ? 고객의 슈퍼마켓에서 구입한 물건들이 담겨져 있는 장바구니의 정보를 생각해보자. 연관성 분석은, 특정한 상품을 구입한 고객이 어떤 부류에 속하는지, 그들이 왜 그 런 구매를 했는지 알기 위해서 고객들이 구매한 상품에 대한 자료를 분석하는 것 이러한 분석을 통하여 효율적인 매장진열, 패키지 상품의 개발, 교차판매전략 구 사, 기획상품의 결정 등에 응용할 수 있음 연관성 분석의 응용 백화점이나 호텔에서 고객들이 다음에 원하는 서비스를 미리 알 수 있음 신용카드, 대출 등의 은행서비스 내역으로부터 특정한 서비스를 받을 가능성이 높 은 고객의 탐지 가능 입력층: 각 입력변수에 대응되는 노드로 구성. 노드의 수는 입력변수의 개수와 같 음 의료보험금이나 상해보험금 청구에서 특이한 형태를 보이는 경우 보험사기의 징조 가 될 수 있고 추가적인 조사 필요 환자의 의무기록에서 여러 치료가 같이 이루어진 경우 합병증 발생의 징후 탐지 출처 : http://datamining.dongguk.ac.kr/lectures/2011-1/dm/dm_notes_v0.5.pdf http://www.slideshare.net/kwnam4u/01-41434457?from_action=save http://daddycat.blogspot.kr/2011/06/blog-post_6849.html 추천시스템 출처 : http://www.slideshare.net/kwnam4u/02-41434707?related=1 데이터 마이닝 입문할때 이 PDF로 하면 좋을거 같다 찾아보니 경북대 대학원 교재 인거같음… http://datamining.dongguk.ac.kr/lectures/2011-1/dm/dm_notes_v0.5.pdf","categories":[{"name":"분류??","slug":"분류","permalink":"http://kji6252.github.io/categories/분류/"}],"tags":[{"name":"Data","slug":"Data","permalink":"http://kji6252.github.io/tags/Data/"},{"name":"Big Data","slug":"Big-Data","permalink":"http://kji6252.github.io/tags/Big-Data/"}]},{"title":"최신 메시지 큐(Messgae Queue) MQ 기술","slug":"message-quere","date":"2015-12-17T23:13:00.000Z","updated":"2021-04-02T02:38:07.050Z","comments":true,"path":"2015/12/18/message-quere/","link":"","permalink":"http://kji6252.github.io/2015/12/18/message-quere/","excerpt":"메시지 큐 란 무엇인가?메시지 지향 미들 웨어(Message Oriented Middleware: MOM)은 비 동기 메시지를 사용하는 다른 응용 프로그램 사이에서 데이터의 송수신을 의미 한다. MOM을 구현한 시스템을 메시지 큐(Message Queue: MQ)라 한다.메시지 큐는 별도의 공정 작업을 연기 할 수 있는 유연성을 제공하여 SOA (service-oriented architecture)의 개발에 도움을 줄 수 있다. 프로그래밍에서 MQ는 프로세스 또는 프로그램 인스턴스가 데이터를 서로 교환할때 사용하는 방법이다. 이때 데이터를 교환할때 시스템이 관리하는 메세지 큐를 이용하는 것이 특징이다. 이렇게 서로 다른 프로세스나 프로그램 사이에 메시지를 교환할때 AMQP(Advanced Message Queueing Protocol)을 이용한다. AMQP는 메세지 지향 미들웨어를 위한 open standard application layer protocol 이다. AMQP를 이용하면 다른 벤더 사이에 메세지를 전송하는 것이 가능한데 JMS (Java Message Service)가 API를 제공하는것과 달리 AMQP는 wire-protocol을 제공하는데 이는 octet stream을 이용해서 다른 네트워크 사이에 데이터를 전송할 수 있는 포멧인데 이를 사용한다. 그림 1 MOM 개념","text":"메시지 큐 란 무엇인가?메시지 지향 미들 웨어(Message Oriented Middleware: MOM)은 비 동기 메시지를 사용하는 다른 응용 프로그램 사이에서 데이터의 송수신을 의미 한다. MOM을 구현한 시스템을 메시지 큐(Message Queue: MQ)라 한다.메시지 큐는 별도의 공정 작업을 연기 할 수 있는 유연성을 제공하여 SOA (service-oriented architecture)의 개발에 도움을 줄 수 있다. 프로그래밍에서 MQ는 프로세스 또는 프로그램 인스턴스가 데이터를 서로 교환할때 사용하는 방법이다. 이때 데이터를 교환할때 시스템이 관리하는 메세지 큐를 이용하는 것이 특징이다. 이렇게 서로 다른 프로세스나 프로그램 사이에 메시지를 교환할때 AMQP(Advanced Message Queueing Protocol)을 이용한다. AMQP는 메세지 지향 미들웨어를 위한 open standard application layer protocol 이다. AMQP를 이용하면 다른 벤더 사이에 메세지를 전송하는 것이 가능한데 JMS (Java Message Service)가 API를 제공하는것과 달리 AMQP는 wire-protocol을 제공하는데 이는 octet stream을 이용해서 다른 네트워크 사이에 데이터를 전송할 수 있는 포멧인데 이를 사용한다. 그림 1 MOM 개념 메시지 큐의 장점 비 동기(Asynchronous) : Queue에 넣기 때문에 나중에 처리 할 수 있다. 비 동조(Decoupling) : 애플리케이션과 분리 할 수 있다. 탄력성(Resilience) : 일부가 실패 시 전체에 영향을 받지 않는다. 과잉(Redundancy): 실패 할 경우 재실행 가능 보증(Guarantees): 작업이 처리된 걸 확인 할 수 있다. 확장성(Scalable): 다수의 프로세스들이 큐에 메시지를 보낼 수 있다. Message Queueing은 대용량 데이터를 처리하기 위한 배치 작업이나, 체팅 서비스, 비동기 데이터를 처리할때 사용한다. 프로세스단위로 처리하는 웹 요청이나 일반적인 프로그램을 만들어서 사용하는데 사용자가 많아지거나 데이터가 많아지면 요청에 대한 응답을 기다리는 수가 증가하다가 나중에는 대기 시간이 지연되어서 서비스가 정상적으로 되지 못하는 상황이 오기 때문에 기존에 분산되어 있던 데이터 처리를 한곳으로 집중하면서 메세지 브로커를 두어서 필요한 프로그램에 작업을 분산 시키는 방법을 하고 싶었기 때문이다. 메시지 큐 사용처 다른 곳의 API로 부터 데이터 송수신 가능. 다양한 애플리케이션에서 비 동기 통신을 할 수 있음. 이 메일 발송 및 문서 업로드 가능 많은 양의 프로세스들을 처리 할 수 있다 JMS vs AMQP AMQP는 ISO 응용 계층의 MOM 표준이다. JMS는 MOM를 자바 에서 지원하는 표준 API 이다. (JMS ≠ AMQP) JMS는 다른 자바 애플리케이션들끼리 통신이 가능하지만 다른 MOM의 통신은 불가능하다. (AMQP, SMTP등) ActiveMQ의 JMS라이브러리를 사용한 자바 애플리케이션들 끼리 통신이 가능하다 그러나 다른 자바 애플리케이션(ActiveMQ를 사용 안함)의 JMS와는 통신 할 수 없다. AMQP는 프로토콜만 맞다만 다른 AMQP를 사용한 애플리케이션 끼리 통신이 가능하다 같은 라인인SMTP 하고도 가능. JMS 라이브러리엔 AMQP를 지원하지 않는다. 오픈 소스 메시지 큐RabbitMQ, ActiveMQ, ZeroMQ, Kafka 에 대해 소개 합니다. RabbitMQ AMQT 프로토콜을 구현 해놓은 프로그램 신뢰성 – 안정성과 성능을 충족할 수 있도록 다양한 기능 제공 유연한 라우팅 – Message Queue가 도착하기 전에 라우팅 되며 플러그인을 통해 더 복잡한 라우팅 가능 클러스터링 – 로컬네트워크에 있는 여러 RabbitMQ 서버를 논리적으로 클러스터링 할 수 있고 논리적인 브로커도 가능 하다. 관리 UI가 있어 편하게 관리 가능하다 거의 모든 언어와 운영체제 지원 오픈소스이며 상업적 지원 ActiveMQ아파치 ActiveMQ 는 풀 자바 메시지 서비스(JMS) 클라이언트와 함께 자바로 만든 오픈소스 메시지 브로커이다. 이 시스템은 “엔터프라이즈 기능” – 이 경우는 하나 이상의 클라이언트와 서버간의 커뮤니케이션을 증진시키는 – 을 제공한다. JMS 1.1 을 통해 자바 뿐만 아니라 다른 “교차언어”를 사용하는 클라이언트를 지원한다. 커뮤니케이션은 컴퓨터 클러스터링및 가상메모리, 캐쉬 그리고 저널 지속성을 제외한 어떤 데이터베이스를 JMS 지속성 제공자로 이용할 수 있는 등의 특징들을 통해 운영된다. 주요 특성들 다양한 언어 환경의 클라이언트들과 프로토콜을 지원하여, Java, C, C++, C#, Ruby, Perl, Python, 그리고 PHP 클라이언트들을 지원합니다. OpenWire를 통해 고성능의 Java, C, C++, C# 클라이언트 지원 Stomp를 통해 C, Ruby, Perl, Python, PHP 클라이언트가 다른 인기있는 메시지 브로커들과 마찬가지로 ActiveMQ에 접근할 수 있음. Message Groups, Virtual Destinations, Wildcards와 Composite Destinations 지원 JMS 1.1과 J2EE 1.4를 완벽하게 지원하며, transient, persistent, transactional, 그리고 XA 메시징을 지원 Spring 지원으로 ActiveMQ는 Spring 애플리케이션에 매우 쉽게 임베딩될 수 있으며, Spring의 XML 설정 메커니즘에 의해 쉽게 설정됨. Geronimo, JBoss 4, GlassFish, 그리고 WebLogic과 같은 인기있는 J2EE 서버들과 함께 테스트 됨. Inbound와 Outbound 메시징을 위한 JCA 1.5 Resource Adapter를 포함하여 ActiveMQ가 J2EE 1.4 호환 서버에 자동 배치됨. In-VM, TCP, SSL, NIO, UDP, Multicast, JGroups, 그리고 JXTA Transport들과 같은 플러그인 가능한 전송 프로토콜들을 지원 고성능의 저널을 사용할 때에 JDBC를 사용하여 매우 빠른 Persistence 지원 고성능의 클러스터링, 클라이언트-서버, 피어 기반 통신을 지원하기 위한 설계 REST API를 통해 웹 기반 메시징 API 지원 웹 브라우저가 메시징 도구가 될 수 있도록, Ajax를 통해 순수한 DHTML을 사용한 웹 스트리밍 지원 Axis를 지원하여, ActiveMQ가 Apache Axis 런타임에 쉽게 통합됨. In-memory JMS Provider로 사용될 수 있음. 이는 JMS를 사용한 단위 테스트에 적합한 솔루션 제공 STOMP, AMQP, MQTT, Openwire, SSL, and WebSockets ZeroMQZeroMQ는 메시징 라이브러리이다. 그것은 많은 수고를 들이지 않고도 복잡한 커뮤니케이션 시스템을 설계할 수 있도록 해준다. ZeroMQ는 스스로를 효율적으로 설명하기 위해 지금까지 많은 노력을 해왔다. 처음에는 ‘메시징 미들웨어’로 소개되었지만, 나중에는 ‘스테로이드를 맞은 TCP’ 그리고 이제는 ‘네트워크 스택의 새로운 레이어’라고 말한다. ØMQ (ZeroMQ, 0MQ, zmq)는 임베디드 네트워킹 라이브러리 이지만, 동시성 프레임 워크와 같은 역할을 합니다. 이것은 in-process, inter-process, TCP, and multicast 처럼 다양한 방식으로 메시지를 전송하는 소켓을 제공합니다. 당신은 fanout, pub-sub, task distribution, and request-reply와 같은 패턴으로 N-to-N 소켓을 연결할 수 있습니다. 이것은 클러스터 구조에서 충분한 속도를 제공합니다. 비동기 I/O 모델은 비동기 메시지 처리를 제공하는 확장 멀티 코어 애플리케이션을 제공합니다. 이것은 language API를 제공하며 대부분의 운영 체제에서 실행됩니다. ØMQ는 iMatix에서 만들어 졌으며, LGPL 오픈소스 소프트웨어입니다. 퍼포먼스ZeroMQ는 정말 빠르다. 그것은 대부분의 AMQP들 보다 단위가 다를 정도로 빠르다. 이러한 퍼포먼스는 다음과 같은 테크닉들 때문에 가능하다: AMQP처럼 과도하게 복잡한 프로토콜이 없다. 신뢰성 있는 멀티캐스트나 Y-suite IPC 전송 같은 효율적인 전송을 활용한다. 지능적인 메시지 묶음을 활용한다. 이것은 0MQ로 하여금 프로토콜 오버헤드뿐만 아니라 시스템 호출을 줄여서 TCP/IP를 효율적으로 활용하게 한다. 단순성API는 믿을 수 없을 정도로 간단하다. 그렇기에 소켓 버퍼에 계속 ‘값을 채워’ 주어야 하는 생 소켓 방식에 비교하면 메시지를 보내는 것이 정말로 단순하다. ZeroMQ에서는 그냥 비동기 send 호출을 부르기만 하면, 메시지를 별도의 스레드의 큐에 넣고 필요한 모든 일을 해준다. 이러한 비동기 특성이 있기에 당신의 애플리케이션은 메시지가 처리되기를 기다리며 시간 낭비하지 않아도 된다. 0MQ의 비동기 특성은 이벤트 중심의 프레임웍에도 최적이다. ZeroMQ의 단순한 와이어 프로토콜은 다양한 전송 프로토콜이 사용되는 요즘에 적합하다. AMQP를 쓴다면 그 위에 또 다른 프로토콜 레이어를 쓴다는 것은 좀 이상하게 느껴진다. 0MQ는 메시지를 그냥 Blob으로 보기에 당신이 메시지를 어떻게 인코드하든 상관없다. 단순히 JSON 메시지들을 보내던지, 아니면 BSON, Protocol Buffers나 Thrift 같은 바이너리 방식 메시지들도 괜찮다. 확장성ZeroMQ 소켓들은 저수준처럼 보이지만 사실은 다양한 기능들을 제공한다. 예를 들어 하나의 ZeroMQ 소켓은 복수의 접점을 가질 수 있으며 그들 간에 자동으로 메시지 부하 분산을 수행한다. 또는 하나의 소켓으로 복수의 소스에서 메시지들을 받아들이는 게이트 역할을 할 수도 있다. Kafka 대용량의 실시간 로그 처리에 특화되어 설계된 메시징 시스템으로써 기존 범용 메시징 시스템대비 TPS가 매우 우수하다. 단, 특화된 시스템이기 때문에 범용 메시징 시스템에서 제공하는 다양한 기능들은 제공되지 않는다. 분산 시스템을 기본으로 설계되었기 때문에, 기존 메시징 시스템에 비해 분산 및 복제 구성을 손쉽게 할 수 있다. AMQP 프로토콜이나 JMS API를 사용하지 않고 단순한 메시지 헤더를 지닌 TCP기반의 프로토콜을 사용하여 프로토콜에 의한 오버헤드를 감소시켰다. Producer가 broker에게 다수의 메시지를 전송할 때 각 메시지를 개별적으로 전송해야하는 기존 메시징 시스템과는 달리, 다수의 메시지를 batch형태로 broker에게 한 번에 전달할 수 있어 TCP/IP 라운드트립 횟수를 줄일 수 있다. 메시지를 기본적으로 메모리에 저장하는 기존 메시징 시스템과는 달리 메시지를 파일 시스템에 저장한다. 파일 시스템에 메시지를 저장하기 때문에 별도의 설정을 하지 않아도 데이터의 영속성(durability)이 보장된다. 기존 메시징 시스템에서는 처리되지 않고 남아있는 메시지의 수가 많을 수록 시스템의 성능이 크게 감소하였으나, Kafka에서는 메시지를 파일 시스템에 저장하기 때문에 메시지를 많이 쌓아두어도 성능이 크게 감소하지 않는다. 또한 많은 메시지를 쌓아둘 수 있기 때문에, 실시간 처리뿐만 아니라 주기적인 batch작업에 사용할 데이터를 쌓아두는 용도로도 사용할 수 있다. Consumer에 의해 처리된 메시지(acknowledged message)를 곧바로 삭제하는 기존 메시징 시스템과는 달리 처리된 메시지를 삭제하지 않고 파일 시스템에 그대로 두었다가 설정된 수명이 지나면 삭제한다. 처리된 메시지를 일정 기간동안 삭제하지 않기 때문에 메시지 처리 도중 문제가 발생하였거나 처리 로직이 변경되었을 경우 consumer가 메시지를 처음부터 다시 처리(rewind)하도록 할 수 있다. 기존의 메시징 시스템에서는 broker가 consumer에게 메시지를 push해 주는 방식인데 반해, Kafka는 consumer가 broker로부터 직접 메시지를 가지고 가는 pull 방식으로 동작한다. 따라서 consumer는 자신의 처리능력만큼의 메시지만 broker로부터 가져오기 때문에 최적의 성능을 낼 수 있다. 기존의 push 방식의 메시징 시스템에서는 broker가 직접 각 consumer가 어떤 메시지를 처리해야 하는지 계산하고 어떤 메시지를 처리 중인지 트랙킹하였는데, Kafka에서는 consumer가 직접 필요한 메시지를 broker로부터 pull하므로 broker의 consumer와 메시지 관리에 대한 부담이 경감되었다. 메시지를 pull 방식으로 가져오므로, 메시지를 쌓아두었다가 주기적으로 처리하는 batch consumer의 구현이 가능하다. 큐의 기능은 기존의 JMS나 AMQP 기반의 RabbitMQ(데이타 기반 라우팅,페데레이션 기능등)등에 비해서는 많이 부족하지만 대용량 메세지를 지원할 수 있는 것이 가장 큰 특징이다. 특히 분산 환경에서 용량 뿐 아니라, 복사본을 다른 노드에 저장함으로써 노드 장애에 대한 장애 대응 성을 가지고 있기 때문에 용량에는 확실하게 강점 마이크로소프트 社의 엔지니어가 쓴 논문을 보면 http://research.microsoft.com/en-us/um/people/srikanth/netdb11/netdb11papers/netdb11-final12.pdf Producer 성능 (이미지 출처: Kafka: A distributed messaging system for log processing) 붉은 색 그래프는 메시지를 한 번에 50개씩 batch로 전송한 결과이고 연두색 그래프는 한 번에 하나씩 전송한 결과이다. Consumer 성능 (이미지 출처: Kafka: A distributed messaging system for log processing) 카프카의 경우 10만 TPS 이상의 성능을 RabbitMQ는 2만 TPS 정도의 성능을 내는 것으로 나와 있는데, 여기서 생각해볼 문제가 큐는 비동기 처리 솔루션이다. 즉 응답 시간에 그렇게 민감 하지 않다는 것이다. 그리고 일반적인 웹 시스템의 성능이 1500~2000 TPS (엔터프라이즈 시스템의 경우) 내외인 것이 일반적이기 때문에, Rabbit MQ의 2만 TPS의 성능은 충분하다고 볼 수 있지 않을까 한다. 결론대용량 CEP 엔진에서는 kafka를 사용해서 처리하고 그이외에 자잘한 메시지큐 같은경우는 다양한 기능이 있는 ActiveMQ를 사용 하는것이 좋을거 같다. ※ 추가 내용Spring에서는 Spring AMQP 가 서브프로젝트로 존재 하며 기본 예제는 RabbitMQ로 되어 있습니다. 최근에 AMQP는 아니지만 빠른 속도를 내세우며 엄청난 인기몰이를 하는 Kafka가 있는데 Spring 서브프로젝트 Spring Kafka도 있어서 빠른 메시징 큐를 사용시에 활용 할수 있을거 같습니다. https://trends.google.com/trends/explore?q=%2Fm%2F0zmynvd,%2Fm%2F0264f96,%2Fm%2F0bhc0tk 2017년 4월 27일 검색 기준으로 구글 트렌드 검색결과 1위 Kafka이며 2위 RabbitMQ, 3위 ActiveMQ는 입니다. Kafka의 인기몰이 중 하나는 메시징 전송시에 헤더의 크기가 작아 오버헤드를 감소시키며 기존의 메시징 시스템에서는 broker가 consumer에게 메시지를 push해 주는 방식인데 반해, Kafka는 consumer가 broker로부터 직접 메시지를 가지고 가는 pull 방식으로 동작한다. 따라서 consumer는 자신의 처리능력만큼의 메시지만 broker로부터 가져오기 때문에 최적의 성능을 낼 수 있다. 각각의 오픈 소스 메시징 큐 의 지원 프로토콜과 지원하는 클라이언트 이다. 출처 https://docs.oracle.com/cd/E19148-01/820-0532/6nc919fag/index.html https://docs.microsoft.com/ko-kr/azure/service-bus-messaging/service-bus-amqp-overview https://www.predic8.com/activemq-hornetq-rabbitmq-apollo-qpid-comparison.htm http://projects.spring.io/spring-amqp/ https://dzone.com/articles/jms-vs-rabbitmq","categories":[{"name":"최신 기술","slug":"최신-기술","permalink":"http://kji6252.github.io/categories/최신-기술/"}],"tags":[{"name":"Message Queue","slug":"Message-Queue","permalink":"http://kji6252.github.io/tags/Message-Queue/"}]},{"title":"KSUG Growing Application 애플리케이션 아키텍처 안티 패턴 후기","slug":"ksug-anti-pattern","date":"2015-12-16T03:59:00.000Z","updated":"2021-04-02T02:38:07.050Z","comments":true,"path":"2015/12/16/ksug-anti-pattern/","link":"","permalink":"http://kji6252.github.io/2015/12/16/ksug-anti-pattern/","excerpt":"개요2015년 11월 28일 KSUG(한국 스프링 사용자 모임) 에서 주최 하는 세미나를 다녀 왔습니다. http://www.ksug.org/seminar/20151128/ 세미나의 전체적인 내용은 부제목에 나와 있듯이 도메인 모델(객체지향)과 객체 설계를 통해 애플리케이션을 작성 하면 어떠한 장점이 있는지 결국 이 장점들이 Spring Framework에 다 스며 들어 있어서 결국 Spring Framework를 쓰면 될것 처럼 보였습니다. 첫번째 시간 SK planet 박성철님께서 애플리케이션 아키텍처 안티 패턴이라는 주제로 세미나를 진행해 주셨습니다. http://www.slideshare.net/gyumee/ss-55616001 우리 업계에서 인식하지 못하는 사이에 학습되어 반복되는 애플리케이션 아키텍처 안티 패턴을 규명하고 이것들이 우리에게 어떤 고통을 주는지, 왜 이런 패턴을 우리 코드에 스며들어 사라지지 않는지 이야기해 봅니다. 안티패턴 총 6가지로 구성되어 있으며 짧게 다루겠습니다.","text":"개요2015년 11월 28일 KSUG(한국 스프링 사용자 모임) 에서 주최 하는 세미나를 다녀 왔습니다. http://www.ksug.org/seminar/20151128/ 세미나의 전체적인 내용은 부제목에 나와 있듯이 도메인 모델(객체지향)과 객체 설계를 통해 애플리케이션을 작성 하면 어떠한 장점이 있는지 결국 이 장점들이 Spring Framework에 다 스며 들어 있어서 결국 Spring Framework를 쓰면 될것 처럼 보였습니다. 첫번째 시간 SK planet 박성철님께서 애플리케이션 아키텍처 안티 패턴이라는 주제로 세미나를 진행해 주셨습니다. http://www.slideshare.net/gyumee/ss-55616001 우리 업계에서 인식하지 못하는 사이에 학습되어 반복되는 애플리케이션 아키텍처 안티 패턴을 규명하고 이것들이 우리에게 어떤 고통을 주는지, 왜 이런 패턴을 우리 코드에 스며들어 사라지지 않는지 이야기해 봅니다. 안티패턴 총 6가지로 구성되어 있으며 짧게 다루겠습니다. 안티패턴 연통 배관(Stovepiping) : 애플리케이션의 각 모듈이 독립적으로 개발되어 다른 모듈과 로직이나 데이터를 공유하지도 않고 상호 작용 하지도 않는다. 스마트 DAO : 대부분의 비지니스 로직을 프로그래밍 언어가 아닌 SQL에 담고 프로그래밍 언어는 이 SQL를 준비하고 실행하고 결과를 받는 작업만 수행하는데 사용 뒤범벅 아키텍처 : 애플리케이션의 횡적인 설계 요소와 종적인 설계 요소가 혼합되어서 변경에 취약한 아키텍처가 만들어짐 긴 공개 메서드 : 클래스에 공개 메서드 뿐, 각 메서드의 크기가 너무 길다. 하는 놈 따로, 아는 놈 따로 : OOP 언어를 사용하고 클래스를 만들지만 사실은 여전히 구조적으로 프로그래밍을 하므로 로직과 데이터가 애플리케이션 전체적으로 분리되어 있다. 단일 객체 서비스(Single Class Service) : 서비스가 객체 하나로 구성되어 있고 적절하게 분화하지 않음 1. 연통 배관(Stovepiping) : 애플리케이션의 각 모듈이 독립적으로 개발되어 다른 모듈과 로직이나 데이터를 공유하지도 않고 상호 작용 하지도 않는다. 관심사에 따른 계층 설계관심사 분리 원칙에 따라 계층도 각 계층의 관심사에 따라 설계 같은이름의 Service,Controller,DAO를 생성해서 만드는것보단 관심사로 나누어서 설계하는게 핵심 2. 스마트 DAO : 대부분의 비지니스 로직을 프로그래밍 언어가 아닌 SQL에 담고 프로그래밍 언어는 이 SQL를 준비하고 실행하고 결과를 받는 작업만 수행하는데 사용중복, 한방 쿼리재사용 할 수 없는 1회용 (ad-hoc)쿼리 사용으로 로직의 중복이 발생하고 유지보수성이 떨어짐 SQL로 표현되는 비지니스 로직 배제 해야함 1SELECT username, secword FROM users WHERE uid = 1; 12SELECT uid, username, secword, firstname, lastname, regidateFROM users WHERE UID = 1; SQL에 모든 로직을 담는건 안좋다고 말씀하셨습니다. 그래서 데이터 가공은 애플리케이션에서 하고 데이터 입출력을 SQL로 쓰는게 좋아 보임 SQL 추상화 기술을 추천 (ORM, Active Record, Query Builder, Table Data Gateway) 3. 뒤범벅 아키텍처 : 애플리케이션의 횡적인 설계 요소와 종적인 설계 요소가 혼합되어서 변경에 취약한 아키텍처가 만들어짐사용자의 요구사항과 여러 기능에 공통적으로 적용되어야 하는 모듈등에 대해서 괴리감 발생 해법1파이프 &amp; 필터 패턴 : 여러 단위 처리 모듈(필터)을 순서대로 나열하고 한 필터에 데이터를 입력해 얻은 출력을 그 다음 필터의 입력으로 삼도록 구성하는 아키텍처 패턴(데코레이션 패턴과 비슷) 해법2관점 지향 프로그래밍(AOP) : 기능에 직교적인 횡적 관심사를 분리해 모듈화 수준을 높이는 기술 4. 긴 공개 메서드 : 클래스에 공개 메서드 뿐, 각 메서드의 크기가 너무 길다.미미한 기능분화, 낮은 유지보수성, 중복 다량 발생, 단일 책임 원칙 위반 함수 작성법 공개 메서드는 이야기(의도, 작업 흐름) 흐름을 나타내라 비공개 메서드는 이야기의 의미를 정의하라 작게 만들고 한가지만 하라(SRP) 함수내 동일한 추상화 수준 유지 서술적인 이름 사용 명령/조회의 분리 조차 함수를 사용함 함수 수준 추상화(람다식) 클린코드 라는 책에서 나온 함수 작성법 이라고 말씀하셨습니다. 자바8의 람다식을 통해 함수도 추상화가 가능하시다고 말씀! 5. 하는 놈 따로, 아는 놈 따로 : OOP 언어를 사용하고 클래스를 만들지만 사실은 여전히 구조적으로 프로그래밍을 하므로 로직과 데이터가 애플리케이션 전체적으로 분리되어 있다.DB의존적 애플리케이션 : 모든 상태를 DB에만 보관, 상태 조작은 SQL로 처리, 애플리케이션 코드는 단순히 인자와 SQl결과를 전달 이를 해결하기 위해 도메인 모델을 도입 도메인 모델 : 행위와 데이터를 포함하는 비지니스 영역의 객체 모델(ORM사용) 도메인 모델 도입시 메모리에서 관리가 가능함으로 메모리상에서 상태의 영속화 개념으로 바뀜 DB를 거치는것 보다 훨씬 빠른 속도로 처리 가능 6. 단일 객체 서비스(Single Class Service) : 서비스가 객체 하나로 구성되어 있고 적절하게 분화하지 않음낮은 응집도 높은 결합코드의 중복이 많고 추상화 수준이 낮아서 코드를 수정함으로서 발생하는 영향을 예측하기 어렵고 단일 요구사항으로 인한 변경 지점이 흩어져 있다. 클래스 추가 공포증으로 부터 벗어나자! 높은 응집도 낮은 결합 지역적 변경(SRP) 중복 최소화(DRY) 로직과 데이터 근거리 보관 변경 주기에 따른 응집 메시지 = 인터페이스 여기서 말하는 높은 응집도 낮은 결합이란 같은 관심사 끼리 모듈화 해놓고 서로에 대한 연결은 인터페이스로 하라는 뜻인거 같다. AOP를 사용해서 종적 관심사와 횡적 관심사 분리 조합 메서드를 활용하고 DSL을 개발하라 도메인 모델을 도입하라 큰 서비스를 작은 클래스로 분해하고 위임하라 높은 응집도와 낮은 결합도를 갖도록 설계하라 기타과잉 일반화(Over Generalizing) : Object, 문자열, Map 같이 지나치게 일반적인 타입의 과용 하나님 객체(God Object) : 과도한 재사용시도, Super~ , 모든 로직이 한 객체에 다 담겨져 있음;; 편의 객체 상속 : 편의 객체를 상속함으로써 소중한 상속의 기회 낭비 인터페이스를 사용하자! 과잉 최신 기술 준수 : 온갖 최신 기술로 도배된 아키텍처, 검증되지 않은 위험한 기술, 교육비용 발생, 고객의 잘못된 요구를 무비판적으로 수용, 프로젝트 수행여력이 부족해짐(왠지 내얘기 인거같기도…) 이상 SK planet 박성철님의 애플리케이션 아키텍처 안티 패턴 이였습니다.","categories":[{"name":"세미나","slug":"세미나","permalink":"http://kji6252.github.io/categories/세미나/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://kji6252.github.io/tags/Java/"},{"name":"Anti Pattern","slug":"Anti-Pattern","permalink":"http://kji6252.github.io/tags/Anti-Pattern/"},{"name":"Object","slug":"Object","permalink":"http://kji6252.github.io/tags/Object/"}]}]}