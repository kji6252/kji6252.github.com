<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>종인의 기술 블로그</title>
  
  <subtitle>Jongin&#39;s Home</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kji6252.github.io/"/>
  <updated>2021-04-04T09:51:50.211Z</updated>
  <id>http://kji6252.github.io/</id>
  
  <author>
    <name>Jongin Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot + Spring Cloud 를 경험 하자</title>
    <link href="http://kji6252.github.io/2020/06/06/Spring-Boot-+-Spring-Cloud-%EB%A5%BC-%EA%B2%BD%ED%97%98-%ED%95%98%EC%9E%90/"/>
    <id>http://kji6252.github.io/2020/06/06/Spring-Boot-+-Spring-Cloud-를-경험-하자/</id>
    <published>2020-06-06T05:00:00.000Z</published>
    <updated>2021-04-04T09:51:50.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-Spring-Cloud-를-경험-하자"><a href="#Spring-Boot-Spring-Cloud-를-경험-하자" class="headerlink" title="Spring Boot + Spring Cloud 를 경험 하자"></a>Spring Boot + Spring Cloud 를 경험 하자</h1><p>Spring 에서 제공 해주는 MSA 환경 구축 가이드를 경험하여 실력을 향상해 보자!</p><p><a href="https://spring.io/guides" target="_blank" rel="noopener">https://spring.io/guides</a></p><p><img src="https://user-images.githubusercontent.com/6037055/113374794-efafd980-93a8-11eb-903d-1ff96a90627c.png" alt="Untitled"><br><a id="more"></a><br><strong><a href="https://spring.io/guides/gs/service-registration-and-discovery/" target="_blank" rel="noopener">Service Registration and Discovery</a></strong></p><p>Learn how to register and find services with Eureka</p><p><strong><a href="https://spring.io/guides/gs/centralized-configuration/" target="_blank" rel="noopener">Centralized Configuration</a></strong></p><p>Learn how to manage application settings from an external, centralized source</p><p><strong><a href="https://spring.io/guides/gs/routing-and-filtering/" target="_blank" rel="noopener">Routing and Filtering</a></strong></p><p>Learn how to route and filter requests to a microservice using Netflix Zuul</p><p><strong><a href="https://spring.io/guides/gs/circuit-breaker/" target="_blank" rel="noopener">Circuit Breaker</a></strong></p><p>Learn how to degrade gracefully services using Hystrix</p><p><strong><a href="https://spring.io/guides/gs/client-side-load-balancing/" target="_blank" rel="noopener">Client Side Load Balancing with Ribbon and Spring Cloud</a></strong></p><p>Dynamically support services coming up and going down without interrupting the client</p><p>5가지 가이드를 학습하여 차례대로 Spring Cloud를 경험해 보자</p><p><img src="https://user-images.githubusercontent.com/6037055/113374792-ede61600-93a8-11eb-9c09-c3bd008b774d.png" alt="Untitled 1"></p><p>스프링에서 제공하는 가이드를 학습하면서 github에 commit별로 정리 하였습니다.</p><p>학습하다가 막힐 경우 commit내역을 참고 하면서 학습 하시길 바랍니다.</p><p>각 단계를 실시한 후 확인하기 위해 http/check-config.http로 확인 하였습니다.</p><p><a href="https://github.com/kji6252/study-spring-cloud" target="_blank" rel="noopener">https://github.com/kji6252/study-spring-cloud</a></p><h1 id="1-Service-Registration-and-Discovery"><a href="#1-Service-Registration-and-Discovery" class="headerlink" title="1.Service Registration and Discovery"></a>1.<strong><a href="https://spring.io/guides/gs/service-registration-and-discovery/" target="_blank" rel="noopener">Service Registration and Discovery</a></strong></h1><p>가이드대로 진행 한 후 eureka baseurl을 넣어 대비하는게 좋을거 같다</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#discovery client의 application.yml에 추가</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><h1 id="2-Centralized-Configuration"><a href="#2-Centralized-Configuration" class="headerlink" title="2.Centralized Configuration"></a>2.<strong><a href="https://spring.io/guides/gs/centralized-configuration/" target="_blank" rel="noopener">Centralized Configuration</a></strong></h1><p>Eureka Server와 충돌을 피하기 위해 <code>spring.cloud.config.server.prefix=/config</code>를 추가</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.config.server.prefix=/config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># study-springboot-eureka/config/example-app.properties 에 추가 한 뒤</span><br><span class="line"># cd study-springboot-eureka/config/</span><br><span class="line"># git init &amp;&amp; git add. &amp;&amp; git commit 하기</span><br><span class="line"></span><br><span class="line">message=Remote Config!</span><br></pre></td></tr></table></figure><h1 id="3-Routing-and-Filtering"><a href="#3-Routing-and-Filtering" class="headerlink" title="3.Routing and Filtering"></a>3.<strong><a href="https://spring.io/guides/gs/routing-and-filtering/" target="_blank" rel="noopener">Routing and Filtering</a></strong></h1><h1 id="4-Circuit-Breaker"><a href="#4-Circuit-Breaker" class="headerlink" title="4.Circuit Breaker"></a>4.<strong><a href="https://spring.io/guides/gs/circuit-breaker/" target="_blank" rel="noopener">Circuit Breaker</a></strong></h1><p>study-springboot-discoveryclient를 stop 한 후에 실행하면 hystrixcommand에 명시된 fallback을 실행</p><h1 id="5-Client-Side-Load-Balancing-with-Ribbon-and-Spring-Cloud"><a href="#5-Client-Side-Load-Balancing-with-Ribbon-and-Spring-Cloud" class="headerlink" title="5.Client Side Load Balancing with Ribbon and Spring Cloud"></a>5.<strong><a href="https://spring.io/guides/gs/client-side-load-balancing/" target="_blank" rel="noopener">Client Side Load Balancing with Ribbon and Spring Cloud</a></strong></h1><p>ribbon은 더이상 관리하지 않으므로 Spring Cloud Load Balancer로 예제가 바뀜</p><p><a href="https://spring.io/guides/gs/spring-cloud-loadbalancer/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-cloud-loadbalancer/</a></p><p>eureka와 통합하여 service discovery부분을 생략함</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot-Spring-Cloud-를-경험-하자&quot;&gt;&lt;a href=&quot;#Spring-Boot-Spring-Cloud-를-경험-하자&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot + Spring Cloud 를 경험 하자&quot;&gt;&lt;/a&gt;Spring Boot + Spring Cloud 를 경험 하자&lt;/h1&gt;&lt;p&gt;Spring 에서 제공 해주는 MSA 환경 구축 가이드를 경험하여 실력을 향상해 보자!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/guides&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://spring.io/guides&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/6037055/113374794-efafd980-93a8-11eb-903d-1ff96a90627c.png&quot; alt=&quot;Untitled&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://kji6252.github.io/categories/Spring/"/>
    
    
      <category term="Java, Spring, Spring Boot, Spring Cloud" scheme="http://kji6252.github.io/tags/Java-Spring-Spring-Boot-Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>PC에서 안드로이드폰 크롬 디버깅 하기</title>
    <link href="http://kji6252.github.io/2018/12/27/PC%EC%97%90%EC%84%9C-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C%ED%8F%B0-%ED%81%AC%EB%A1%AC-%EB%94%94%EB%B2%84%EA%B9%85-%ED%95%98%EA%B8%B0/"/>
    <id>http://kji6252.github.io/2018/12/27/PC에서-안드로이드폰-크롬-디버깅-하기/</id>
    <published>2018-12-27T04:00:43.000Z</published>
    <updated>2021-04-02T02:38:07.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>평소 Web개발을 하시는 분들은 빠른 속도와 편리한 도구들이 많은 Chrome devtools를 이용하여 개발 하게 됩니다. </p><p>그중 모바일 페이지를 개발 할때 우리는 2가지 방법을 사용하게 됩니다.<br><img src="https://user-images.githubusercontent.com/6037055/50465815-08b4cd80-09dd-11e9-9109-e64f6383950d.png" alt="2018-12-27 1 18 05"></p><ol><li>devtools &gt; Toggle device Toolbar</li><li>크롬 확장 프로그램 <code>User-Agent Swicher</code></li></ol><p>위에 소개 된 방식 이외에도 devtools &gt; Remote devicese를 사용 하면 자신의 안드로이드폰의 크롬App을 PC에서 디버깅을 할 수 있습니다.<br><a id="more"></a></p><h1 id="준비-할것"><a href="#준비-할것" class="headerlink" title="준비 할것"></a>준비 할것</h1><p>USB 디버깅 활성화 된 안드로이드폰, PC와 연결할 USB케이블, PC</p><blockquote><p>USB 디버깅 활성은 안드로이드폰 개발자 옵션 활성 후 <code>개발자 옵션 &gt; USB 디버깅</code>을 활성 하시면 됩니다.</p></blockquote><h1 id="사용-방법"><a href="#사용-방법" class="headerlink" title="사용 방법"></a>사용 방법</h1><p><img src="https://developers.google.com/web/tools/chrome-devtools/remote-debugging/imgs/remote-debugging.png" alt="PC Connected Android Phone"><br>안드로이드폰과 USB케이블을 PC에 연결을 합니다.</p><p><code>크롬 &gt; devtools &gt; ⋮(More Options) &gt; more Tools &gt; Remote devices</code> 로 실행 하면 됩니다.</p><p><img src="https://user-images.githubusercontent.com/6037055/50466872-33098980-09e3-11e9-976e-8ff2c145bebd.png" alt="2018-12-27 2 23 35"></p><p>이 후엔 <code>폰기종 Connected</code>를 클릭 후 안드로이드폰에서 크롬App을 실행 하면  Intercept를 클릭 하시면 안드로이드폰과 PC에 동일한 화면을 공유 하며 디버깅이 가능 합니다.</p><p><img src="https://user-images.githubusercontent.com/6037055/50467229-3a319700-09e5-11e9-89fa-e04d87af75d1.png" alt="2018-12-27 2 32 13"></p><p><img src="https://user-images.githubusercontent.com/6037055/50467411-39e5cb80-09e6-11e9-8596-936fca931838.png" alt="2018-12-27 2 37 01"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;평소 Web개발을 하시는 분들은 빠른 속도와 편리한 도구들이 많은 Chrome devtools를 이용하여 개발 하게 됩니다. &lt;/p&gt;
&lt;p&gt;그중 모바일 페이지를 개발 할때 우리는 2가지 방법을 사용하게 됩니다.&lt;br&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/6037055/50465815-08b4cd80-09dd-11e9-9109-e64f6383950d.png&quot; alt=&quot;2018-12-27 1 18 05&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;devtools &amp;gt; Toggle device Toolbar&lt;/li&gt;
&lt;li&gt;크롬 확장 프로그램 &lt;code&gt;User-Agent Swicher&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에 소개 된 방식 이외에도 devtools &amp;gt; Remote devicese를 사용 하면 자신의 안드로이드폰의 크롬App을 PC에서 디버깅을 할 수 있습니다.&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://kji6252.github.io/categories/Web/"/>
    
    
      <category term="Chrome, devtools, Android, Web Debug" scheme="http://kji6252.github.io/tags/Chrome-devtools-Android-Web-Debug/"/>
    
  </entry>
  
  <entry>
    <title>JHipster MSA 구축</title>
    <link href="http://kji6252.github.io/2018/08/11/JHipster-MSA-%EA%B5%AC%EC%B6%95/"/>
    <id>http://kji6252.github.io/2018/08/11/JHipster-MSA-구축/</id>
    <published>2018-08-11T05:53:44.000Z</published>
    <updated>2021-04-02T02:38:07.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>Mricroservice는 수많은 장점을 가지고 있지만 구축하는건 생각보다 쉽지 않습니다. JHipster와 함께 MSA구축을 하면 한층 쉽게 다가갈수 있다고 생각 되어 글을 작성 하게 되었습니다.</p><p>본 글에서는 크게</p><ul><li>개발 MSA 환경 구축</li><li>Docker Compose를 활용한 Service Mash</li></ul><p>나뉘며 프로젝트 생성부터 Microservice Gateway와 Microservice Application생성과 더불어 상용 배포를 위한 Docker Compose 설정까지 알아 보겠습니다.</p><h1 id="개발-MSA-환경-구축"><a href="#개발-MSA-환경-구축" class="headerlink" title="개발 MSA 환경 구축"></a>개발 MSA 환경 구축</h1><p><img src="https://www.jhipster.tech/images/microservices_architecture_detail.001.png" alt="MSA diagram"><br><a id="more"></a></p><ul><li>Gateway 생성<ul><li>Registry 실행</li><li>Gateway 실행</li></ul></li><li>Application 생성<ul><li>Application 실행</li></ul></li></ul><p>여기에선 이 구조로 프로젝트를 생성 해 보겠습니다.<br><img src="https://user-images.githubusercontent.com/6037055/43988352-c1192640-9d6e-11e8-9723-d77ee7674fb1.png" alt="directory"></p><h2 id="Gateway-생성"><a href="#Gateway-생성" class="headerlink" title="Gateway 생성"></a>Gateway 생성</h2><p>Gateway를 생성한 뒤 먼저 JHipster Registry를 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Gateway로 프로젝트 생성</span><br><span class="line">$ <span class="built_in">cd</span> gateway</span><br><span class="line">$ jhipster</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/6037055/43988345-bfed690c-9d6e-11e8-9c47-0fb1dd3b1516.png" alt="gateway_generate"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Registry 실행</span><br><span class="line">$ docker-compose -f src/main/docker/jhipster-registry.yml up</span><br></pre></td></tr></table></figure></p><p><img src="https://user-images.githubusercontent.com/6037055/43988350-c0b8cbce-9d6e-11e8-86b4-98b644cfc333.png" alt="registry_run"><br>JHipster Registry는 <code>Spring Cloud Config</code>와 <code>Eureka Server</code>로 이루어져 있으며 Microservice의 Config관리 및 서버 발견 역할을 한다.</p><p>registry가 셋팅 된후에 gateway를 실행 시킨다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Gateway 실행</span><br><span class="line">$ ./gradlew</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/6037055/43988346-c021a9ba-9d6e-11e8-9ad7-e797411cdbb9.png" alt="gateway_run"></p><h2 id="Application-생성"><a href="#Application-생성" class="headerlink" title="Application 생성"></a>Application 생성</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Application로 프로젝트 생성 (member, wallet 각각 실행)</span><br><span class="line">$ <span class="built_in">cd</span> member</span><br><span class="line">$ jhipster</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/6037055/43988348-c05189b4-9d6e-11e8-8b74-86da2dd6425a.png" alt="member_generate"><br><img src="https://user-images.githubusercontent.com/6037055/43988351-c0eb1688-9d6e-11e8-90e8-0d0a7a825fe9.png" alt="wallet_generate"><br>생성 후 별도의 비즈니스로직 추가 후 애플리케이션을 실행 하시면 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Gateway 실행</span><br><span class="line">$ ./gradlew</span><br></pre></td></tr></table></figure><h2 id="개발-MSA-환경-실행"><a href="#개발-MSA-환경-실행" class="headerlink" title="개발 MSA 환경 실행"></a>개발 MSA 환경 실행</h2><p>지금까지 잘 따라오셨으면</p><ul><li>Registry</li><li>Gateway</li><li>Application</li></ul><p>3개의 서비스들이 잘 실행 되어 있고 Gateway에서 각각의 Application의 API를 호출하면 정상적으로 동작하는걸 확인 하실 수 있습니다.</p><p><img src="https://user-images.githubusercontent.com/6037055/43988349-c08271aa-9d6e-11e8-9e30-80feec06d61a.png" alt="registry_check"><br><img src="https://user-images.githubusercontent.com/6037055/43988355-c1a150f6-9d6e-11e8-8c77-b38491c25a79.png" alt="gateway_check"><br><img src="https://user-images.githubusercontent.com/6037055/43988353-c1499aaa-9d6e-11e8-9a1f-ad028fc7361b.png" alt="gateway_app_check_1"><br><img src="https://user-images.githubusercontent.com/6037055/43988354-c17b96e0-9d6e-11e8-831e-49487bc1052d.png" alt="gateway_app_check_2"></p><p>swagger를 통해 Gateway에서 각각의 member와  wallet Service의 API를 확인하고 개발 할 수 있습니다.</p><h1 id="Docker-Compose를-활용한-Service-Mash"><a href="#Docker-Compose를-활용한-Service-Mash" class="headerlink" title="Docker Compose를 활용한 Service Mash"></a>Docker Compose를 활용한 Service Mash</h1><p>Docker Compose를 실행하기전 각각의 애플리케이션의 Dokcer Image가 필요하여 아래의 명령어를 실행 해줘야 합니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew bootWar -Pprod buildDocker</span><br></pre></td></tr></table></figure></p><p><code>docker images</code>로 Docker Image를 확인 하실 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure></p><p><img src="https://user-images.githubusercontent.com/6037055/43988576-e06f3f48-9d73-11e8-97e9-42f814005407.png" alt="docker_images"></p><p>필요한 모든 준비가 완료 되었습니다. 이제 docker-compose로 서비스들을 묶은 뒤 실행만 하면 됩니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> wallet-app-compose</span><br><span class="line">$ jhipster docker-compose</span><br></pre></td></tr></table></figure></p><p><img src="https://user-images.githubusercontent.com/6037055/43988578-e25a1c4c-9d73-11e8-9d9b-86288ad38cb7.png" alt="docker-compose_generate"></p><p>생성을 완료 한 후 실행을 해봅니다.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure></p><p><img src="https://user-images.githubusercontent.com/6037055/43988579-e2fdcd2e-9d73-11e8-810f-423e7461d370.png" alt="docker-compose_up"></p><p>이외 compose사용시 유용한 명령어들 입니다.</p><ul><li><code>docker-compose up -d</code> - 컨테이너들 생성과 동시에 실행</li><li><code>docker-compose down</code> - 컨테이너들 종료와 동시에 삭제</li><li><code>docker-compose start</code> - 컨테이너들 실행</li><li><code>docker-compose stop</code> - 컨테이너들 종료</li></ul><p>docker로 실행 시 몇가지 유용한 명령어를 정리 해 보았습니다.</p><ul><li><code>docker stats</code> - 컨테이너의 cpu, memory, I/O 등</li><li><code>docker images</code> - 이미지 확인</li><li><code>docker ps</code> - 컨테이너 확인</li><li><code>docker rmi</code> - 이미지 삭제</li><li><code>docker rm</code> - 컨테이너 삭제</li></ul><p><img src="https://user-images.githubusercontent.com/6037055/43988577-e0bbab3a-9d73-11e8-8d1e-733ba811f815.png" alt="docker_stats"></p><p>자세한 사용법은 명령어 뒤에 <code>--help</code> 를 넣어 확인 바랍니다.</p><p>JHipster Console도 설치 하여 MSA관리를 수월할 수 있게 도와 줍니다.<br><img src="https://user-images.githubusercontent.com/6037055/43988583-efa2428a-9d73-11e8-9dcf-a49e5cee3901.png" alt="console_dashboard"><br><img src="https://user-images.githubusercontent.com/6037055/43988604-4267cec2-9d74-11e8-94e0-ad09e3a3b3b2.png" alt="console_log"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;Mricroservice는 수많은 장점을 가지고 있지만 구축하는건 생각보다 쉽지 않습니다. JHipster와 함께 MSA구축을 하면 한층 쉽게 다가갈수 있다고 생각 되어 글을 작성 하게 되었습니다.&lt;/p&gt;
&lt;p&gt;본 글에서는 크게&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;개발 MSA 환경 구축&lt;/li&gt;
&lt;li&gt;Docker Compose를 활용한 Service Mash&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;나뉘며 프로젝트 생성부터 Microservice Gateway와 Microservice Application생성과 더불어 상용 배포를 위한 Docker Compose 설정까지 알아 보겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;개발-MSA-환경-구축&quot;&gt;&lt;a href=&quot;#개발-MSA-환경-구축&quot; class=&quot;headerlink&quot; title=&quot;개발 MSA 환경 구축&quot;&gt;&lt;/a&gt;개발 MSA 환경 구축&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://www.jhipster.tech/images/microservices_architecture_detail.001.png&quot; alt=&quot;MSA diagram&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JHipster" scheme="http://kji6252.github.io/categories/JHipster/"/>
    
    
      <category term="JHipster" scheme="http://kji6252.github.io/tags/JHipster/"/>
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://kji6252.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JHipster란?</title>
    <link href="http://kji6252.github.io/2018/07/29/JHipster%EB%9E%80/"/>
    <id>http://kji6252.github.io/2018/07/29/JHipster란/</id>
    <published>2018-07-29T08:25:17.000Z</published>
    <updated>2021-04-02T02:38:07.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JHipster란"><a href="#JHipster란" class="headerlink" title="JHipster란?"></a>JHipster란?</h1><p><img src="https://i2.wp.com/keyholesoftware.com/wp-content/uploads/jHipster.jpg?fit=700%2C400&amp;ssl=1" alt="제이힙스터"><br>간단히 정의 하면 <code>자바 기반 생성(generate) 개발 플랫폼</code> 이라고 말씀 드릴 수 있습니다.</p><p>기존 뛰어난 생산성으로 흥한 개발 플랫폼인 Ruby의 <code>Ruby on Ralse</code>나 Node.js의 <code>Meteor.js</code>등 애플리케이션 개발을 생성 도구 활용으로 인기를 었습니다.</p><p>그동안 Spring 진영에서도 생성 도구를 활용한 개발이 없어 생산성에서 뒤쳐졌지만, JHipster에서 만들게 되어 Spring에서도 빠른 생산성을 확보하게 되었습니다.</p><p>생성 도구는 Yeoman이라는 기존 웹 보일러플레이트 프로젝트 생성 도구인데 JHipster에서 Yeoman기반으로 만들어 활용 하였습니다.<br><a id="more"></a></p><h1 id="Yeoman이란"><a href="#Yeoman이란" class="headerlink" title="Yeoman이란?"></a>Yeoman이란?</h1><p><img src="https://cdn-images.threadless.com/threadless-media/artist_shops/shops/yeoman/products/633217/shirt-1529592223-b157e98a44b27cc571605d6297f9f9e9.png?v=3&amp;d=eyJvbmx5X21ldGEiOiBmYWxzZSwgImZvcmNlIjogZmFsc2UsICJvcHMiOiBbWyJ0cmltIiwgW2ZhbHNlLCBmYWxzZV0sIHt9XSwgWyJyZXNpemUiLCBbXSwgeyJ3aWR0aCI6IDk5Ni4wLCAiYWxsb3dfdXAiOiBmYWxzZSwgImhlaWdodCI6IDk5Ni4wfV0sIFsiY2FudmFzX2NlbnRlcmVkIiwgWzEyMDAsIDEyMDBdLCB7ImJhY2tncm91bmQiOiAiZmZmZmZmIn1dLCBbInJlc2l6ZSIsIFs4MDBdLCB7fV0sIFsiY2FudmFzX2NlbnRlcmVkIiwgWzgwMCwgODAwLCAiI2ZmZmZmZiJdLCB7fV0sIFsiZW5jb2RlIiwgWyJqcGciLCA4NV0sIHt9XV19" alt="요맨"></p><p>웹 개발을 프레임워크 및 라이브러리들을 통합하여 쉽게 프로젝트를 생성 할 수 있는 Tool 입니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g yo</span><br><span class="line">$ npm i -g generator-원하는도구</span><br></pre></td></tr></table></figure><p>기본적으로 Node.js가 설치 되어 있어야 하며, <code>yo</code>를 설치 후 원하는 도구를 설치 하면 됩니다.</p><p>Yeoman에서 제공하는 API를 활용하면 쉽게 CLI기반 Generate가 가능 하므로 관심 있으신 분들은<br><a href="http://yeoman.io/authoring/index.html" target="_blank" rel="noopener">http://yeoman.io/authoring/index.html</a><br>이 URL을 참조 하셔서 개발 하시면 됩니다.</p><h1 id="JHipster-Sample-Project"><a href="#JHipster-Sample-Project" class="headerlink" title="JHipster Sample Project"></a>JHipster Sample Project</h1><h2 id="준비"><a href="#준비" class="headerlink" title="준비"></a>준비</h2><p>JHipster를 사용하기 전 필수로 설치할 프로그램을 소개 합니다.</p><ul><li>Java</li><li>Git</li><li>Node.js</li><li>Yarn</li><li>Yeoman</li></ul><p>Java와 Git, Node.js는 OS에 맞추어 설치 하시고 Yarn과 Yeoman은 Node.js와 함께 설치된 npm으로 설치 하시면 됩니다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g yarn</span><br><span class="line">$ yarn global add generator-jhipster</span><br></pre></td></tr></table></figure><p><a href="https://www.jhipster.tech" target="_blank" rel="noopener">https://www.jhipster.tech</a> 에 접속 하여 Quick Start를 보고<br>샘플 프로젝트 생성을 진행 하겠습니다.</p><p>JHipster 문서 보실때 헷갈릴까봐 한가지 짚고 넘어 가겠습니다.<br>명령어 사용 시 옛날 방식과 최근 방식에 차이점이 있는데 yo를 쓰고 안쓰고 차이 입니다. 입맛에 맞게 골라서 사용하시면 될거 같습니다.</p><ul><li><p>프로젝트 생성 시</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//옛날 방식</span><br><span class="line">$ yo jhipster</span><br><span class="line"></span><br><span class="line">//최근 방식</span><br><span class="line">$ jhipster</span><br></pre></td></tr></table></figure></li><li><p>추가 기능 사용 시</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//옛날 방식</span><br><span class="line">$ yo jhipster:추가기능</span><br><span class="line"></span><br><span class="line">//최근 방식</span><br><span class="line">$ jhipster 추가기능</span><br></pre></td></tr></table></figure></li></ul><h2 id="생성"><a href="#생성" class="headerlink" title="생성"></a>생성</h2><p>샘플프로젝트 생성 시 선택 가능한 내역 입니다.<br><strong>굵게</strong> 표시한건 이번 프로젝트 생성 시 선택한 것 입니다.</p><ul><li>어떤 타입의 프로젝트를 생성하는가?<ul><li><strong>모놀로식 애플리케이션</strong></li><li>마이크로서비스 애플리케이션</li><li>마이크로서비스 게이트웨이</li><li>JHipster UAA Server</li></ul></li><li>어떤 인증을 사용 할 것인가?<ul><li><strong>JWT</strong></li><li>Oauth2 / OIDC</li><li>HTTP Sesstion Authentication</li></ul></li><li>어떤 DB를 사용 할 것인가?<ul><li><strong>SQL(H2, MySQL, MariaDB, PostgreSQL, Oracle, MSSQL)</strong></li><li>MongoDB</li><li>Couchbase</li><li>Cassandra</li></ul></li><li>(SQL 선택시 나옴) dvelopment와 production에 사용할거 선택</li><li>Spring Cache를 사용할 것인가?<ul><li>Ehcach</li><li>Hazelcast</li><li>Memcached</li><li><strong>사용안함</strong></li></ul></li><li>어떤 빌드 도구를 쓸 것인가?<ul><li>Maven</li><li><strong>Gradle</strong></li></ul></li><li>다른 기술을 사용할 것인가?(모두 선택 가능)<ul><li>엘라스틱서치 기반 검색</li><li>웹소켓</li><li>OpenAPI-generator</li><li>Kafka</li></ul></li><li>어떤 Front를 사용 할 것인가?<ul><li>Angular 6</li><li><strong>React</strong></li></ul></li><li>추가 테스트 프레임워크를 사용할 것인가?(모두 선택 가능)<ul><li>Gatling</li><li>Cucumber</li><li>Protractor</li></ul></li><li>어떤 기본 언어를 선택 할 것인가?<ul><li><strong>한국어</strong></li><li>영어</li><li>기타 등등</li></ul></li><li>추가로 지원할 언어는?(모두 선택 가능)<ul><li><strong>영어</strong></li><li>나머지 선택지는 위와 동일</li></ul></li></ul><p>본격적으로 생성을 해보겠습니다.</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\a\jhipsterProjects&gt; mkdir myApp; cd myApp</span><br><span class="line">PS C:\Users\a\jhipsterProjects\myApp&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/6037055/43363131-6739432a-9338-11e8-88ab-e67f65f64b9d.png" alt="jg01"><br><img src="https://user-images.githubusercontent.com/6037055/43363132-6772ba7e-9338-11e8-9d92-7373b8dfce3c.png" alt="jg02"><br><img src="https://user-images.githubusercontent.com/6037055/43363133-67ae6d12-9338-11e8-972a-3eaacf0252ab.png" alt="jg03"><br><img src="https://user-images.githubusercontent.com/6037055/43363134-68561d00-9338-11e8-898c-d3e064410f55.png" alt="jg04"><br><img src="https://user-images.githubusercontent.com/6037055/43363135-68837304-9338-11e8-8567-1c57306f30d0.png" alt="jg05"><br><img src="https://user-images.githubusercontent.com/6037055/43363136-68b06cba-9338-11e8-9b85-4e598c6b5100.png" alt="jg06"><br><img src="https://user-images.githubusercontent.com/6037055/43363137-68dacd16-9338-11e8-9219-6b28739e03df.png" alt="jg07"><br><img src="https://user-images.githubusercontent.com/6037055/43363138-6906a3d2-9338-11e8-964b-0f321ad0a7d0.png" alt="jg08"><br><img src="https://user-images.githubusercontent.com/6037055/43363130-670d28f8-9338-11e8-92f0-0ae781eaaec9.png" alt="jg09"></p><p>Spring Boot + React앱이 만들어 졌고 다음시간엔 JDL과 CLI을 통한 Entity+Controller+Service생성을 알아 보겠습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JHipster란&quot;&gt;&lt;a href=&quot;#JHipster란&quot; class=&quot;headerlink&quot; title=&quot;JHipster란?&quot;&gt;&lt;/a&gt;JHipster란?&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i2.wp.com/keyholesoftware.com/wp-content/uploads/jHipster.jpg?fit=700%2C400&amp;amp;ssl=1&quot; alt=&quot;제이힙스터&quot;&gt;&lt;br&gt;간단히 정의 하면 &lt;code&gt;자바 기반 생성(generate) 개발 플랫폼&lt;/code&gt; 이라고 말씀 드릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;기존 뛰어난 생산성으로 흥한 개발 플랫폼인 Ruby의 &lt;code&gt;Ruby on Ralse&lt;/code&gt;나 Node.js의 &lt;code&gt;Meteor.js&lt;/code&gt;등 애플리케이션 개발을 생성 도구 활용으로 인기를 었습니다.&lt;/p&gt;
&lt;p&gt;그동안 Spring 진영에서도 생성 도구를 활용한 개발이 없어 생산성에서 뒤쳐졌지만, JHipster에서 만들게 되어 Spring에서도 빠른 생산성을 확보하게 되었습니다.&lt;/p&gt;
&lt;p&gt;생성 도구는 Yeoman이라는 기존 웹 보일러플레이트 프로젝트 생성 도구인데 JHipster에서 Yeoman기반으로 만들어 활용 하였습니다.&lt;br&gt;
    
    </summary>
    
      <category term="JHipster" scheme="http://kji6252.github.io/categories/JHipster/"/>
    
    
      <category term="JHipster" scheme="http://kji6252.github.io/tags/JHipster/"/>
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://kji6252.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>해외판 전자정부프레임워크? JHipster에 대해 알아 보자!</title>
    <link href="http://kji6252.github.io/2018/07/29/%ED%95%B4%EC%99%B8%ED%8C%90-%EC%A0%84%EC%9E%90%EC%A0%95%EB%B6%80%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-JHipster%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84-%EB%B3%B4%EC%9E%90/"/>
    <id>http://kji6252.github.io/2018/07/29/해외판-전자정부프레임워크-JHipster에-대해-알아-보자/</id>
    <published>2018-07-29T08:23:45.000Z</published>
    <updated>2021-04-02T02:38:07.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>우리나라에서 공공기관과 민간기업에서 많이 사용하는 전자정부프레임워크가 있습니다. 업데이트도 느리거니와 생성도 불편하다고 생각 됩니다. 그에 반해 해외에서는 Yeoman을 가지고 쉽게 Spring Boot 개발 환경을 만들 수 있고 더불어 편한 유지 보수를 할 수 있게 도와주는 JHipster를 소개 합니다.</p><p>해외에서 자바 개발 플랫폼으로 핫한 프로젝트 입니다.</p><p><img src="https://user-images.githubusercontent.com/6037055/43363798-c1e66ce4-9347-11e8-9c80-5d0f75f53d36.png" alt="제이힙스터깃허브"><br><a id="more"></a><br>다양한 기업들에서도 JHipster를 사용하고 있습니다.</p><p><img src="https://user-images.githubusercontent.com/6037055/43364341-4d914e8e-9353-11e8-8ea5-c0d427a04592.png" alt="제이힙스터사용기업들"></p><p>프로젝트 셋팅부터 시작해서 귀찮은 일은 JHipster가 도 맡아 하고 개발자는 <code>비즈니스 로직에만 집중</code> 할 수 있습니다.</p><p>JHipster로 할 수 있는것</p><ul><li>Spring Boot + Angular/React 프로젝트</li><li>UML을 통한 Entity+Controler+Service 자동 생성</li><li>MSA 환경 구축</li><li>Docker Image 생성</li><li>Cloud와 통합 기능 제공(Kubernetis, Heroku, AWS 등)</li></ul><p>이외에도 여러 오픈소스들을 사용할 수 있게 셋팅이 되어 있으며 입맛이 맞게 골라서 사용 하실 수 있습니다.</p><h1 id="개인적으로-마음에-드는-부분"><a href="#개인적으로-마음에-드는-부분" class="headerlink" title="개인적으로 마음에 드는 부분"></a>개인적으로 마음에 드는 부분</h1><p>Spring Project들을 사용 하면서 공부 할 때 구조를 잘 잡는게 중요하다고 생각 됩니다. 물론 샘플 프로젝트만으로도 만족 할 수 있겠지만, 여러 프로젝트들을 융합 하였을때 복잡성이 증가하고 문맥과 명칭들이 뒤죽박죽 섞여 있어 통일성을 잃기 쉽습니다. 그래서 JHipster의 생성된 프로젝트를 봤을 때 깔끔한 설정과 generator를 사용 하여 일관된 개발을 할 수 있게 도와 줍니다.</p><h1 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h1><p>소개는</p><ul><li>JHipster란? With Sample Project</li><li>JHipster와 생성 도구</li><li>JHipster와 오픈소스</li><li>JHipster MSA With Docker Compose</li></ul><p>4 단계로 나눠서 소개를 할까 싶습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;우리나라에서 공공기관과 민간기업에서 많이 사용하는 전자정부프레임워크가 있습니다. 업데이트도 느리거니와 생성도 불편하다고 생각 됩니다. 그에 반해 해외에서는 Yeoman을 가지고 쉽게 Spring Boot 개발 환경을 만들 수 있고 더불어 편한 유지 보수를 할 수 있게 도와주는 JHipster를 소개 합니다.&lt;/p&gt;
&lt;p&gt;해외에서 자바 개발 플랫폼으로 핫한 프로젝트 입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/6037055/43363798-c1e66ce4-9347-11e8-9c80-5d0f75f53d36.png&quot; alt=&quot;제이힙스터깃허브&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JHipster" scheme="http://kji6252.github.io/categories/JHipster/"/>
    
    
      <category term="JHipster" scheme="http://kji6252.github.io/tags/JHipster/"/>
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://kji6252.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>2018 Ahea 세미나 - Server에서 만남을 추구하면 안되는 걸까</title>
    <link href="http://kji6252.github.io/2018/07/09/2018-Ahea-%EC%84%B8%EB%AF%B8%EB%82%98-Server%EC%97%90%EC%84%9C-%EB%A7%8C%EB%82%A8%EC%9D%84-%EC%B6%94%EA%B5%AC%ED%95%98%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EA%B1%B8%EA%B9%8C/"/>
    <id>http://kji6252.github.io/2018/07/09/2018-Ahea-세미나-Server에서-만남을-추구하면-안되는-걸까/</id>
    <published>2018-07-09T13:07:23.000Z</published>
    <updated>2021-04-02T02:38:07.045Z</updated>
    
    <content type="html"><![CDATA[<p>강진우님의 리눅스 커널 이야기를 읽고 직접 실습을 하며 정리한 내용 입니다.</p><h1 id="도입"><a href="#도입" class="headerlink" title="도입"></a>도입</h1><p>사람과 사람사이 예의가 정말 중요 합니다. 서버에서 동작하는 서비스들 한테도 마찬가지인데요. 이 글에서는서버에서 돌아가는 서비스들의 관계와 사람의 관계를 비교해 가면서 설명 하겠습니다.</p><p><img src="https://ahea.files.wordpress.com/2018/04/null.png" alt=""><br><a id="more"></a></p><h1 id="1차-웹서비스"><a href="#1차-웹서비스" class="headerlink" title="1차 웹서비스"></a>1차 웹서비스</h1><p><img src="https://ahea.files.wordpress.com/2018/04/null1.png" alt=""> 예제에서 쓰인 웹 서비스는 파이썬 웹 프레임워크인 Flask를 썻으며 DB로는 Key/Value store인 redis를 사용 하였습니다.</p><ol><li><a href="http://localhost:5000/test/1" target="_blank" rel="noopener">http://localhost:5000/test/1</a> 접속</li><li>Flask에서 Redis에 접속하여 Set(1,155030303)를 실행(redis에 데이터 주입)</li><li>Flask에서 Redis에 Get(1)을 하여 데이터 가져오기</li><li>사용자에게 전달</li></ol><p>해당 서비스의 플로우는 총 4단계로 구성 되며 이 예제를 가지고 사용자에게 서비스 가능한 웹서비스를 튜닝 하겠습니다. 사과를 구입할 경우엔 이런식의 플로우로 흘러간다고 예를 들겠습니다. <img src="https://ahea.files.wordpress.com/2018/04/null2.png" alt=""> Flask와 Redis의 사이도 마찬가지인데요</p><p><img src="https://ahea.files.wordpress.com/2018/04/null3.png" alt=""></p><p>위의 그림과 같이 3way-handshake 후에 데이터셋팅을 하고 데이터를 가져오며 4way-handshake를 통해 연결을 끊습니다. 만약에 이작업을 1000명 혹은 10000명이 요청할 경우 <img src="https://ahea.files.wordpress.com/2018/04/null4.png" alt=""> 2가지 문제점이 발생하게 됩니다.</p><ol><li>TCP 연결과 종료에 대한 오버헤드</li><li>local port에 대한 고갈</li></ol><h2 id="여기서-잠깐-local-port란"><a href="#여기서-잠깐-local-port란" class="headerlink" title="여기서 잠깐!!! local port란?"></a>여기서 잠깐!!! local port란?</h2><p><img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-1.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (1)"> <img src="https://ahea.files.wordpress.com/2018/04/null5.png" alt=""> Client가 TCP 소켓 연결시 필요한 port, OS에서 정의 해놓은 local port 범위 안에서 할당 보통 http Request를 날리거나 다른 TCP연결을 할시에 OS에서 ‘IP주소:로컬포트’를 가지고 통신을 하게 됨</p><h2 id="문제점-2가지"><a href="#문제점-2가지" class="headerlink" title="문제점 2가지"></a>문제점 2가지</h2><h3 id="TCP-통신-오버헤드"><a href="#TCP-통신-오버헤드" class="headerlink" title="TCP 통신 오버헤드"></a>TCP 통신 오버헤드</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null6.png" alt=""> 3way-handshake와 4way-handshake를 1000번 10000번 하게 되면 그만큼의 네트워크 자원 낭비가 되기 때문에 계속 연결 되어 있는 상태여야 합니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-9.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (9)"> 아까의 사과 구매 프로세스를 대입해 보면 사과 1000개를 구매 할 때에도 똑같이 1000번을 인사해야 하는 불상사가 생깁니다.</p><h3 id="local-port-고갈의-문제"><a href="#local-port-고갈의-문제" class="headerlink" title="local port 고갈의 문제"></a>local port 고갈의 문제</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null7.png" alt=""> Flask에서 Client가 되므로 지속적으로 local_port를 만들어 내어 나중엔 고갈이 되어 버리는 현상까지 오게 됩니다. 그리고 다시 사용할시엔 timewait지속 시간이 60초 이므로 60초가 지나야 다시 사용 가능 합니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까"> netstat 명령어를 통해 현재 OS의 소켓 상태를 확인 할수 있으며 Flask가 local_port를 무지막지하게 사용한 모습을 보실수 있습니다. <img src="https://ahea.files.wordpress.com/2018/04/null5.png" alt=""> 우분투에서 할당 해 줄수 있는 포트를 ‘sysctl -a | grep local_port’ 명령어로 확인 할수 있습니다. 위의 문제점을 해결할 방법도 2가지가 됩니다.</p><ol><li>net.itv4.tcp_tw_reuse 활성화</li><li>Connection Pool</li></ol><h2 id="해결법-2가지"><a href="#해결법-2가지" class="headerlink" title="해결법 2가지"></a>해결법 2가지</h2><h3 id="net-ipv4-tcp-tw-reuse-활성화"><a href="#net-ipv4-tcp-tw-reuse-활성화" class="headerlink" title="net.ipv4.tcp_tw_reuse 활성화"></a>net.ipv4.tcp_tw_reuse 활성화</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null8.png" alt=""> ‘sysctl -a | grep reuse’명령어를 통해 확인 할수 있으며 0이면 비활성 1이면 활성화 입니다. ‘sysctl -w net.ipv4.tcp_tw_reuse=1’명령어를 입력시 활성화 되며 이 기능은 패킷 소실의 위험이 있습니다. 지금과 같은 형태에서는 비추천 하지만 다른서버에 접속하는 Cilent용 서버일 경우에는 필요 할 수도 있습니다.</p><h3 id="Connection-Pool"><a href="#Connection-Pool" class="headerlink" title="Connection Pool"></a>Connection Pool</h3><p><img src="https://ahea.files.wordpress.com/2018/04/null9.png" alt=""> 다른 해결 방법인 Connection Pool을 만들어 사용 하는 것입니다. 미리 Pool을 만들어 놓고 사용자들이 http Request를 사용시엔 <img src="https://ahea.files.wordpress.com/2018/04/null10.png" alt=""> 이런 식으로 3way-handshake와 4way-handshake가 사라지기 때문에 TCP 맺고 끊음에 대한 오버헤드가 사라지게 됩니다. <img src="https://ahea.files.wordpress.com/2018/04/null11.png" alt=""> 그리고 계속 연결 상태 이므로 로컬 포트도 고정적으로 사용하게 되어서 고갈을 방지 할 수 있습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-10.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (10)"> 사과 구매를 할때에도 인사를 한번만 할수 있으므로 인사(TCP 연결과 종료)할 수 있으므로 오버헤드를 감소 할수 있습니다.</p><h1 id="2차-웹서비스-Nginx를-추가-해보자"><a href="#2차-웹서비스-Nginx를-추가-해보자" class="headerlink" title="2차 웹서비스 Nginx를 추가 해보자"></a>2차 웹서비스 Nginx를 추가 해보자</h1><p>실질적으로 외부에 서비스하는 웹서비스들은 대부분 앞에 Web Server를 두게 되는데 그이유는 크게 Virtual Host, resource cache, Route등의 이유가 있어 약간의 지연이 있어도 3tier(WebServer-App-DB)로 구성을 하게 됩니다. <img src="https://ahea.files.wordpress.com/2018/04/null12.png" alt=""> 그런데 바로 추가시엔 위와 동일한 현상이 발생하게 됩니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-2.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (2)"> 다시 나타난 2가지 문제점</p><ol><li>TCP 연결과 종료에 대한 오버헤드</li><li>local port에 대한 고갈</li></ol><p><img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-3.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (3)"> <img src="https://ahea.files.wordpress.com/2018/04/null13.png" alt=""> Nginx가 Cilent이며 Flask가 Server인 입장이 되어 위와 동일한 현상이 발생하게 됩니다. 이 문제점도 동일하게 해결법이 2가지가 있습니다.</p><ol><li>net.ipv4.tcp_tw_reuse 활성화</li><li><span style="color: #ff0000;">Keepalive Connections</span></li></ol><h2 id="Keepalive-Connections-추가"><a href="#Keepalive-Connections-추가" class="headerlink" title="Keepalive Connections 추가"></a>Keepalive Connections 추가</h2><p><img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-4.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (4)"> nginx 설정에서 keepliave만 추가 해주면 됩니다. 자세한 설정은 기본 예제도 많으므로 nginx example을 참조해서 keepalive만 추가 해 줍시다. <img src="https://ahea.files.wordpress.com/2018/04/null14.png" alt=""> 위와 같은 구성도가 되며 Nginx에서 Keepalive Connections를 만들어 관리하게 됩니다. 참고로 time_out 값도 줄수 있어 한번 연결 후에는 몇초 후에 Keepalive를 없앨지 정할 수 있습니다. keepalive를 추가 할때와 안할때의 플로우는 아래와 같습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-5.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (5)"> <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-6.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (6)"> 보통 한번 http연결시 6~8번의 요청을 하게 된다고 하여 keepalive로 TCP 연결과 종료에 대한 오버헤드를 줄일 수 있습니다. Keepalive 설정 전후의 테스트 결과 입니다. 스트레스 테스트 툴은 <a href="https://www.joedog.org/siege-home/" target="_blank" rel="noopener">siege</a>를 사용 하였습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-7.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (7)"> TPS가 200이나 차이가 났습니다. <img src="https://ahea.files.wordpress.com/2018/04/2018-ec84b8ebafb8eb8298-serverec9790ec849c-eba78ceb82a8ec9d84-ecb694eab5aced9598eba9b4-ec9588eb9098eb8a94-eab1b8eab98c-8.png" alt="2018 세미나 - Server에서 만남을 추구하면 안되는 걸까 (8)"> netstat를 통해 테스트 후의 time_wait소켓을 살펴보니 8300개의 차이가 발생 하였습니다.</p><h1 id="최종-정리"><a href="#최종-정리" class="headerlink" title="최종 정리"></a>최종 정리</h1><ul><li>서비스 대 서비스로 연결시에는 <span style="color: #ff0000;">Connection Pool</span>을 고려해 보자!</li><li>Nginx 사용시 <span style="color: #ff0000;">Keepalive</span>사용을 고려해 보자!</li><li><span style="color: #ff0000;">time_wait소켓</span>이 많다는건 나쁘진 않지만 <span style="color: #ff0000;">지나치게 많을 경우</span> 살펴 보자!</li></ul><p>출처</p><ul><li>책 ‘리눅스 커널 이야기’ 강진우 지음</li><li>nginx keepalive - <a href="https://www.nginx.com/blog/http-keepalives-and-web-performance/" target="_blank" rel="noopener">https://www.nginx.com/blog/http-keepalives-and-web-performance/</a></li><li>TCP Flags - <a href="http://www.dbguide.net/knowledge.db?cmd=view&amp;boardUid=183652&amp;boardConfigUid=21" target="_blank" rel="noopener">http://www.dbguide.net/knowledge.db?cmd=view&amp;boardUid=183652&amp;boardConfigUid=21</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;강진우님의 리눅스 커널 이야기를 읽고 직접 실습을 하며 정리한 내용 입니다.&lt;/p&gt;
&lt;h1 id=&quot;도입&quot;&gt;&lt;a href=&quot;#도입&quot; class=&quot;headerlink&quot; title=&quot;도입&quot;&gt;&lt;/a&gt;도입&lt;/h1&gt;&lt;p&gt;사람과 사람사이 예의가 정말 중요 합니다. 서버에서 동작하는 서비스들 한테도 마찬가지인데요. 이 글에서는서버에서 돌아가는 서비스들의 관계와 사람의 관계를 비교해 가면서 설명 하겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ahea.files.wordpress.com/2018/04/null.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="세미나" scheme="http://kji6252.github.io/categories/%EC%84%B8%EB%AF%B8%EB%82%98/"/>
    
    
      <category term="Nginx" scheme="http://kji6252.github.io/tags/Nginx/"/>
    
      <category term="TIME_WAIT" scheme="http://kji6252.github.io/tags/TIME-WAIT/"/>
    
      <category term="Server" scheme="http://kji6252.github.io/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://kji6252.github.io/2018/06/13/hello-world/"/>
    <id>http://kji6252.github.io/2018/06/13/hello-world/</id>
    <published>2018-06-13T01:21:00.000Z</published>
    <updated>2021-04-02T02:38:07.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="소감"><a href="#소감" class="headerlink" title="소감"></a>소감</h2><p>블로그를 github pages로 옮기게 되었습니다. 여러가지 이유가 있지만</p><ul><li>Markdown으로 블로깅</li><li>github의 안정적인 호스팅</li><li>손쉬운 테마 변경</li></ul><p>3가지의 이유가 있어서 사용하게 되었습니다.<br><a id="more"></a></p><h2 id="사용-이유"><a href="#사용-이유" class="headerlink" title="사용 이유"></a>사용 이유</h2><p>그리고 github pages를 편리하게 사용하기 위해 필요한 Tool인 Static Web Generator를 <a href="https://www.staticgen.com/" target="_blank" rel="noopener">StaticGen</a>에서 조사해본 결과</p><p><img src="https://user-images.githubusercontent.com/6037055/41322746-adba4b36-6ee5-11e8-9d5f-e0ab432e9393.png" alt="image"></p><p>여러가지 종류의 Static Web Generator가 있었고 Hexo가 엄청나게 밀려 있지만 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo Temes</a>에 예쁜 테마를 발견하여 결국 쓰게 되었습니다.<br>추 후 다른 예쁜 테마를 발견하게 되면 Static Web Generator 상관없이 테마 기준으로 Static Web Generator를 선택 할 예정 입니다.</p><p>현재 테마의 github 주소는 맨밑을 확인해 주세요.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;소감&quot;&gt;&lt;a href=&quot;#소감&quot; class=&quot;headerlink&quot; title=&quot;소감&quot;&gt;&lt;/a&gt;소감&lt;/h2&gt;&lt;p&gt;블로그를 github pages로 옮기게 되었습니다. 여러가지 이유가 있지만&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Markdown으로 블로깅&lt;/li&gt;
&lt;li&gt;github의 안정적인 호스팅&lt;/li&gt;
&lt;li&gt;손쉬운 테마 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3가지의 이유가 있어서 사용하게 되었습니다.&lt;br&gt;
    
    </summary>
    
      <category term="이모저모" scheme="http://kji6252.github.io/categories/%EC%9D%B4%EB%AA%A8%EC%A0%80%EB%AA%A8/"/>
    
    
      <category term="Blog" scheme="http://kji6252.github.io/tags/Blog/"/>
    
      <category term="Tool" scheme="http://kji6252.github.io/tags/Tool/"/>
    
      <category term="Hexo" scheme="http://kji6252.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>가상화폐? 암호화폐?</title>
    <link href="http://kji6252.github.io/2017/12/25/bitcoin-summary/"/>
    <id>http://kji6252.github.io/2017/12/25/bitcoin-summary/</id>
    <published>2017-12-25T01:03:00.000Z</published>
    <updated>2021-04-02T02:38:07.046Z</updated>
    
    <content type="html"><![CDATA[<p>최근 인기를 끌고 있는 블록체인(blockchain)기술과 그 기술을 활용한 가상화폐에 대해서 알아 봅시다.</p><p>블록체인은 사토시 나카모토가 2009년 처음 블록체인 기반 암호화폐 비트코인이 처음 등장하면서 세상에 나오게 되었습니다.</p><p>블록체인이란 거래내역을 블록이라는 단위로 묶고 다음에 발생한 블록을 끝에 붙이는 Linked List방식으로 연결 하는걸 체인이라고 하여 블록체인 이라고 합니다.</p><p>이 기술이 나온 2009년부터 현재 2017년 동안 거래내역이 변조 없이 잘 보존되어있다는걸로 증명 되어 보안에도 강하다는 강점이 나타나면서 획기적인 기술로 인정 받게 되었습니다.</p><p>그 후 비탈릭 부테린이 만든 이더리움이라는 가상화폐가 나오게 되었는데 기존 블록체인을 가상화폐 교환에서만 사용한걸 스마트 컨트렉트 라는 기능을 추가 함으로써 탈중앙화 앱(decentralized application = DAPP)을 제작할수 있는 환경을 제공 하게 되었습니다. 그 후 이더리움 스마트컨트렉트를 활용한 크립토키티스 라는 게임이 나오게 되었으며 이더리움의 가능성과 한계성을 알게 되었습니다.<br><a id="more"></a><br>크립토키티스라는 게임 출시때에는 엄청난 트래픽으로 인하여 이더리움 환경에서 돌아가는 모든 행위들이 수행속도가 현저히 낮아졌다고 하여 이로 인해 아직도 갈길이 멀었다는 생각을 하게 되었습니다.</p><p>이더리움은 DDos를 막고자 gas라는 수수료가 있는데 이더리움 환경을 이용시 이 gas가 필요 하기 때문에 크립토키티스 게임 행동하나하나가 비용이 필요한 게임이 되었습니다. 간단히 말해서 모든 행동이 캐시템이 필요하다고 보시면 될거 같습니다.</p><p>그래도 가상화폐를 가장 잘 활용한 플랫폼은 스팀인거 같습니다.(게임 스팀 아닙니다.)</p><p>스팀잇 이라는 SNS 플랫폼이 있는데 글작성도 블록으로 저장된다고 하고 글작성자는 보팅기능으로 돈도 벌수 있다고 합니다.</p><p>다른 가상화폐 진영에서는 이 단점을 없애고자 3세대 라고 주장하면서 나온 EOS라는 코인이 있으며 ADA 코인 등 앞으로 많은 코인이 등장 하면서 다음 3세대 코인은 1세대 2세대 단점들을 극복하면서 나올지 기대 됩니다.</p><p>특징을 정리해보면</p><ul><li>개인간 거래가 가능하다 (Peer To Peer = P2P)</li><li>보안에 강하다 (노드가 많을 수록 안정됨)</li><li>여러 분야에 활용이 가능 하다.(스마트 컨트렉트로 인한 다양한 곳에 활용 가능 ex: <a href="https://steemit.com/" target="_blank" rel="noopener">steemit</a>(voting), <a href="https://www.cryptokitties.co/" target="_blank" rel="noopener">CryptoKitties</a> 등)</li></ul><p>현재 알고 있는걸 간략하게 설명 하였고 앞으로는 DAPP 예제도 작성하면서 조금더 블록체인에 대해 접근해보면서 공부 하고자 합니다.</p><p>암호화폐라는 용어는 가상화폐라는 단어 대신에 암호화폐 라는 단어를 사용함으로써 부정적인 인식을 개선하고자 최근에 나온 단어로 알고 있습니다. 저도 이제부터는 암호화폐라고 불러보도록 노력 하겠습니다.</p><p>앞으로 진행할 개념 설명 및 예제는 이더리움 기준으로 해볼까 합니다. 공부하면서 도움이 되었던 사이트를 아래에 남겼습니다.</p><p><a href="http://goodjoon.tistory.com/230?category=632200" target="_blank" rel="noopener">http://goodjoon.tistory.com/230?category=632200</a> - 이더리움 프로젝트 설명 및 예제</p><p><a href="https://www.etherchain.org/" target="_blank" rel="noopener">https://www.etherchain.org/</a> - 이더리움 익스플로러(최근 블록과 통계를 보여줌)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;최근 인기를 끌고 있는 블록체인(blockchain)기술과 그 기술을 활용한 가상화폐에 대해서 알아 봅시다.&lt;/p&gt;
&lt;p&gt;블록체인은 사토시 나카모토가 2009년 처음 블록체인 기반 암호화폐 비트코인이 처음 등장하면서 세상에 나오게 되었습니다.&lt;/p&gt;
&lt;p&gt;블록체인이란 거래내역을 블록이라는 단위로 묶고 다음에 발생한 블록을 끝에 붙이는 Linked List방식으로 연결 하는걸 체인이라고 하여 블록체인 이라고 합니다.&lt;/p&gt;
&lt;p&gt;이 기술이 나온 2009년부터 현재 2017년 동안 거래내역이 변조 없이 잘 보존되어있다는걸로 증명 되어 보안에도 강하다는 강점이 나타나면서 획기적인 기술로 인정 받게 되었습니다.&lt;/p&gt;
&lt;p&gt;그 후 비탈릭 부테린이 만든 이더리움이라는 가상화폐가 나오게 되었는데 기존 블록체인을 가상화폐 교환에서만 사용한걸 스마트 컨트렉트 라는 기능을 추가 함으로써 탈중앙화 앱(decentralized application = DAPP)을 제작할수 있는 환경을 제공 하게 되었습니다. 그 후 이더리움 스마트컨트렉트를 활용한 크립토키티스 라는 게임이 나오게 되었으며 이더리움의 가능성과 한계성을 알게 되었습니다.&lt;br&gt;
    
    </summary>
    
      <category term="가상화폐" scheme="http://kji6252.github.io/categories/%EA%B0%80%EC%83%81%ED%99%94%ED%8F%90/"/>
    
    
      <category term="Bitcoin" scheme="http://kji6252.github.io/tags/Bitcoin/"/>
    
  </entry>
  
  <entry>
    <title>java data access</title>
    <link href="http://kji6252.github.io/2017/07/06/java-data-access/"/>
    <id>http://kji6252.github.io/2017/07/06/java-data-access/</id>
    <published>2017-07-06T01:39:00.000Z</published>
    <updated>2021-04-02T02:38:07.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>자바에서 데이터베이스에 접속 할수 있는 API를 제공하는데 그게 <a href="https://ko.wikipedia.org/wiki/JDBC" target="_blank" rel="noopener"> JDBC(Java Database Connectivity)</a> 입니다.<br><img src="https://lh6.googleusercontent.com/0YTTqDJ6t6cUvCIh2DsCCptnyvx-0N7NuaM560euJStFCwRbaHvQhQ2KgNiohS0rID21jJ6Kppfjp0_bM_MqqMsp7ItnkiwEcGAy3W6480MJlbD20GkOEbLWgyI4GyuPZmYiCPrR" alt="JDBC흐름도"><br><a id="more"></a></p><h1 id="자바-JDBC와-DB벤더들"><a href="#자바-JDBC와-DB벤더들" class="headerlink" title="자바 JDBC와 DB벤더들"></a>자바 JDBC와 DB벤더들</h1><p>아래 표는 JDBC를 사용시의 불편함점 개선과 기능추가가된 라이브러리 및 프레임워크들 이다.</p><table><thead><tr><th></th><th>자바</th><th>스프링</th></tr></thead><tbody><tr><td>JDBC</td><td><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/" target="_blank" rel="noopener">Plane JDBC</a></td><td><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html" target="_blank" rel="noopener">Spring JDBC</a></td></tr><tr><td></td><td><a href="http://www.mybatis.org/mybatis-3/ko/" target="_blank" rel="noopener">Mybatis</a></td><td><a href="http://www.mybatis.org/spring/" target="_blank" rel="noopener">Mybatis-Spring</a></td></tr><tr><td></td><td><a href="http://commons.apache.org/proper/commons-dbutils/" target="_blank" rel="noopener">Apache commons DbUtils</a></td><td>　</td></tr><tr><td></td><td><a href="https://github.com/aaberg/sql2o" target="_blank" rel="noopener">sql2o</a></td><td>　</td></tr><tr><td></td><td><a href="http://jdbi.org/" target="_blank" rel="noopener">JDBI</a></td><td>　</td></tr><tr><td></td><td><a href="http://ormlite.com/" target="_blank" rel="noopener">ORMLite</a></td><td>　</td></tr><tr><td>JPA(ORM)</td><td><a href="http://www.oracle.com/technetwork/java/javaee/tech/persistence-jsp-140049.html" target="_blank" rel="noopener">Plane JPA</a></td><td><a href="http://projects.spring.io/spring-data-jpa/" target="_blank" rel="noopener">Spring Data JPA</a></td></tr><tr><td>JPA provider</td><td><a href="http://hibernate.org/" target="_blank" rel="noopener">Hibernate</a>, <a href="http://eclipse.org/eclipselink/" target="_blank" rel="noopener">EclipseLink</a>, <a href="http://www.oracle.com/technetwork/middleware/toplink/overview/index-089172.html" target="_blank" rel="noopener">TopLink</a></td><td>　</td></tr><tr><td></td><td><a href="https://db.apache.org/jdo/index.html" target="_blank" rel="noopener">JDO</a></td><td>　</td></tr><tr><td>TpyeSafe Builder</td><td><a href="https://www.jooq.org/" target="_blank" rel="noopener">jOOQ</a> , <a href="http://www.querydsl.com/" target="_blank" rel="noopener">QueryDSL</a></td><td>　</td></tr></tbody></table><h1 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h1><p>JDBC API는 Java에서 가장 로우레벨의 데이터베이스 API 입니다. 그래서 SQL을 실행하는 데도 매우 번잡한 코드가 필요하고 DB에 따라 일관성없는 예외체크를 해야 하며 SQL은 코드 내에서 문자로 제공해야 하는 불편을 감수해야 한다. 커넥션과 같은 공유 리소스를 제대로 처리하지 않으면 시스템의 자원이 바닥나는 심각한 버그를 심어놓을 수도 있다.</p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>MyBatis는  first class persistence framework with support라고 소개 되어 있는데 말그대로 클래스 중심으로 프로그램을 개발 할 수 있게 도움을 준다는 프레임워크 지원 하는 기능은 커스텀SQL, 스토어프로시저, 고급매핑을 지원한다.</p><p>어떤곳에서는 ORM매퍼 라고 하는데 공식홈페이지를 가보면 ORM이라는 단어는 없고 first class persistence framework 가 맞는거 같다.</p><p><a href="http://blog.mybatis.org/p/products.html" target="_blank" rel="noopener">http://blog.mybatis.org/p/products.html</a></p><p>들어가면 마이바티스부터 시작해서 코드자동생성 제너레이터, 이클립스개발시 도움을 주는 플러그인, 스칼라버전 마이바티스, 닷넷버전 마이바티스 등등 JDBC를 직접 사용하는것 보다 편의 기능이나 각종 툴이 제공되어서 생산성을 높일수 있다.</p><h1 id="JPA-ORM"><a href="#JPA-ORM" class="headerlink" title="JPA(ORM)"></a>JPA(ORM)</h1><p>JPA(Java Persistence API)는 관계형 <a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4" target="_blank" rel="noopener">데이터베이스</a>에 접근하기 위한 표준 <a href="https://ko.wikipedia.org/wiki/ORM" target="_blank" rel="noopener">ORM</a> 기술을 제공 한다.</p><p>2006년 java 1.5버전 이상부터  JPA1.0이 정의 되었으며 현재버전은 2013년에 정의된 JPA2.1버전이 최신이다.</p><p>JPA는 구현체를 함께 사용해야 하는데 주로 사용되는 구현체의 점유율은 이러하다.</p><p><img src="https://lh4.googleusercontent.com/eSdG9B0TsjMhv0Ab3_3JmMhiv2DUUseC7dR2ey7k8JSPfP189DDSOklZGqWlRmSmAZSQUPzsOzVb-U0OEOmy3br_lmLz99D_iEX-ku0mq-aBdPvCJRmrFY5gaNPMJajoHR93j8xI" alt="JPA구현체트랜드차트"></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring-JDBCTemplate"><a href="#Spring-JDBCTemplate" class="headerlink" title="Spring JDBCTemplate"></a>Spring JDBCTemplate</h2><p>spring 에서는 jdbc를 확장해서 만든 jdbcTemplate을 이용하여 데이터베이스에 접근을 합니다.</p><p>jdbcTemplate은 JDBC API를 가지고 템플릿콜백패턴을 통해 간결함과 리소스 처리를 함으로써 비즈니스로직에 집중할수 있게 하였고 데이터베이스마다 다른 exception핸들링을 통하여 데이터베이스 예외처리를 획일화 하였습니다.</p><p><img src="https://lh6.googleusercontent.com/X1A8cV7QO_Jl7L7VyIKUpQ0Q_LaJz5mjUg4utCSNwKf0vmnraNppOXlKpVjzPfRKjACu4EfK-zaUOqfxg2tzu6ZLAE6ExYt9J3VeR7kxPUHqob9a6WBo06HFU5m8Uh-7JxbE8R4_" alt="익셉션구성도"></p><p>스프링 SQLException 핸들링</p><h2 id="Spring-Data와-서브-프로젝트들"><a href="#Spring-Data와-서브-프로젝트들" class="headerlink" title="Spring Data와 서브 프로젝트들"></a>Spring Data와 서브 프로젝트들</h2><p><img src="https://lh5.googleusercontent.com/yI5316iTK5dqoF-ofsDIjtDd1-ea6hbOrjmYYFMnRdjAwm9ul8XYfDiAX7AwyuJnCeVGT20TucmuEm1DJwPqPFvBWMcRzucsz3Dp101CdE39ZDLtEyv0Z8Ba_sy3WmYwm9t8oePx" alt="스프링데이타프로젝트들"></p><p>spring data 는 JDBC뿐만 아니라 JPA와 각각의 클라이언트를 제공하던 NoSQL들도 제공 함으로써 Spring에서 가장 대표적으로 사용하는 Dao Access 프레임워크가 되었습니다.</p><p>Repositories, Templates, Object Mapping과 트랜잭션동시지원, 간편한 설정등의 기능을 더하고 확장 하였습니다.</p><p>spring data 서브프로젝트 중에서는 Repository만 구현해도 자동으로 CRUD및 Paging, sort 기능을 자동으로 생성되는 프로젝트들도 있습니다.</p><p>spring data의 기능은 Repository에 crud, paging, sort 기능을 함유 커스텀 Repository 하고 있고 각종 유틸과 QueryDSL에 관련된 서포트툴이 있어</p><p>QueryDSL의 TypeSafe한 쿼리문을 작성하기에 용이 합니다.</p><h1 id="TpyeSafe-Builder"><a href="#TpyeSafe-Builder" class="headerlink" title="TpyeSafe Builder"></a>TpyeSafe Builder</h1><h2 id="QueryDSL"><a href="#QueryDSL" class="headerlink" title="QueryDSL"></a>QueryDSL</h2><p><a href="http://www.querydsl.com/static/querydsl/4.0.1/reference/ko-KR/html_single/" target="_blank" rel="noopener">QueryDSL</a>은 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있는 프레임워크다. 문자열이나 XML에 쿼리를 작성하는 대신 QueryDSL이 제공하는 플루언트(Fluent) API를 이용해서 쿼리를 생성할 수 있다.</p><ul><li>IDE의 코드 자동 완성 기능 사용</li><li>컴파일 시점에서 잘못된 쿼리를 허용하지 않음</li><li>도메인 타입과 프로퍼티를 안전하게 참조할 수 있음</li><li>도메인 타입의 리팩토링을 더 잘 할 수 있음</li></ul><h2 id="jOOQ"><a href="#jOOQ" class="headerlink" title="jOOQ"></a>jOOQ</h2><p>처음엔 JPA를 공부할때는 QueryDSL을 먼저 알았지만 타입세이프빌더쪽에서는 jOOQ가 더 오래된걸 알게 되었습니다. 아무래도 유료이다 보니 QueryDSL보다 덜 활성화 된게 아닐까 싶습니다. jOOQ의 장점은 돈을 내고 지원을 받을수 있다는 점인거 같습니다.</p><p>흥미로운건 jOO로 시작하는 프로젝트들인</p><ul><li><a href="https://github.com/jOOQ/jOOX" target="_blank" rel="noopener">jOOX</a> : jquery 문법을 자바에서 사용가능하게 해줌</li><li><a href="https://github.com/jOOQ/jOOR" target="_blank" rel="noopener">jOOR</a> : 자바 리플렉션 랩퍼 라이브러리</li><li><a href="https://github.com/jOOQ/jOOL" target="_blank" rel="noopener">jOOL</a> : 자바에 람다 기능 보강(?)</li><li><a href="https://github.com/jOOQ/jOOU" target="_blank" rel="noopener">jOOU</a> : unsigned 타입을 지원</li></ul><p>등 재미 있는 프로젝트들이 있어서 뭔가 새로운걸 도전하는 팀같아서 좋게 보였습니다.</p><p>작성 하다보니 쓸모 있는 내용이 없어서 죄송합니다. 안바쁠때 예제와 함께 올릴예정이였지만 이직과 이리저리 많은일이 있어서 간단하게 나마 남겨 봅니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h1&gt;&lt;p&gt;자바에서 데이터베이스에 접속 할수 있는 API를 제공하는데 그게 &lt;a href=&quot;https://ko.wikipedia.org/wiki/JDBC&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; JDBC(Java Database Connectivity)&lt;/a&gt; 입니다.&lt;br&gt;&lt;img src=&quot;https://lh6.googleusercontent.com/0YTTqDJ6t6cUvCIh2DsCCptnyvx-0N7NuaM560euJStFCwRbaHvQhQ2KgNiohS0rID21jJ6Kppfjp0_bM_MqqMsp7ItnkiwEcGAy3W6480MJlbD20GkOEbLWgyI4GyuPZmYiCPrR&quot; alt=&quot;JDBC흐름도&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="자바" scheme="http://kji6252.github.io/categories/%EC%9E%90%EB%B0%94/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://kji6252.github.io/tags/Spring/"/>
    
      <category term="DB" scheme="http://kji6252.github.io/tags/DB/"/>
    
  </entry>
  
  <entry>
    <title>윈도우 에서 도커(Docker)와 Kitematic 설치</title>
    <link href="http://kji6252.github.io/2017/04/03/windows-docker-install/"/>
    <id>http://kji6252.github.io/2017/04/03/windows-docker-install/</id>
    <published>2017-04-03T02:22:00.000Z</published>
    <updated>2021-04-02T02:38:07.051Z</updated>
    
    <content type="html"><![CDATA[<p>저같이 도커를 잘모르는 사람에게 쉽게 접근할수있게 제공해주는 GUI툴 Kitematic이 있습니다. 클릭 몇번으로 이미지를 다운로드 받아서 컨테이너 생성까지 정말 간편하게 사용하고 로그도 출력되며 웹포트가 열려있으면 웹도 쉽게 띄울수있습니다. 도커를 처음 입문 하시는 분들을 위해 설치법을 공유 합니다.</p><p><img src="https://lh5.googleusercontent.com/UHmV5WSHhvRlKaAmvdguxMez7h5m-04p88NRKNJam0Djet7ruQ3J9JzjfC85aMB8bkX2Dxvhf1Vr21jal0BD_s1zERPg-cgTdozqFDqiLpnz1P4NT3xlWW_fIhkzQJsCbKKMnFEJ" alt=""></p><p>윈도우에서 도커를 깔기 위해 메인페이지의 다운로드를 사용하여 설치하였습니다.</p><p><img src="https://lh6.googleusercontent.com/ebsAUwtoRySMs0YOoWc4UkepSaDRkXXmDH_XhrKDYOA8aZCj3tTLfYYBKS8UEjSovRJx5cdo1yma16UAj70T2vMegwmL-qNBthjPstKA2Ge6zoZyu25rJyfeD-G_G79AroQR2lE5" alt=""><br><a id="more"></a><br>이화면이 계속 나오고…</p><p><img src="https://lh6.googleusercontent.com/2uY_SPP9eZsOy_yGU7VYxfKKp_xoxXDnkv0qPXVLdsI-jvemOY1CVwcuqHO1yaV8HUJMI8Etr3gfXHWkC5mLHOR8uo7jvVoFOp2jLKJ1yGl08zL8dMSoOP0FQOvWIFdUj5ADBSxK" alt=""></p><p>아무리 진행을 해도 안되더군요… 좌절을 하였습니다.</p><p>해결방법을 검색 하던중 어느한 커뮤니티에서 다른 페이지에 있는걸 다운 받아 설치하라고 하더군요.</p><p><img src="https://lh5.googleusercontent.com/rH3s5lDU4oP-jFU4wcl8KIxxFy1dbaN3dzTbovClrNUysr3l-Ga5723b3-f2Fq-x4UkHRpotBlksGZdXOwvsqKFC3DLrw_oYVIlngTUBkC_qP0i8hh0s28h_nAji-5ZR_UPtI511" alt=""></p><p>도커 docs에 있는 다른 설치 파일을 찾았습니다. 기존껀 지우고 설치해 보죠.</p><p><a href="https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows</a></p><p>여기서 잠깐!!!</p><p>Windows10 pro 이상이신 분들은 Hyper-v 를 활성화 하시는걸 추천드립니다.</p><p>윈도우10에서부터 탑재된 Hyper-v는 오라클 버추얼박스나 vm웨어보다 성능이 더 좋다고 하더군요.</p><p><img src="https://lh5.googleusercontent.com/QMwKlDilT1HsrkCgEtAO7OH-oQuHY-_KuXxN88__gLzAMi7xUUto7Ye9BYvS59RJ08P5QRE5hSZ9F_PPBE4VstWZ3aO0CUW0lQCJhaRAan_KDrLhWAkAb9EXvTjRMwHzL7K5-IIq" alt=""></p><p>제어판 &gt; 모든 제어판 항목 &gt; 프로그램 및 기능 > Windows 기능 &gt; Hyper-V 체크</p><p><img src="https://lh4.googleusercontent.com/vl0hPYYhVAlVXQhTs36RKv8JINMHy7hko5Lr4nSiyHMeKO6rKhNpp-LhczkKbg4PJc5VjL75VgHhiy7A55aQev1j1H6Cp4yjsU47a1-ZtUf9zmImRNqrXsEhhP3jUbCLwjV2kyW4" alt=""></p><p><img src="https://lh5.googleusercontent.com/fWEe0WKHzEw3EnEK7zOZuUc6_YBAH9Iq0k_BvJYb74X_NVYkOk4Dgc78Rfl0U9enIISSPRtl-raUewQ8cau2Lcb6QGGJF-V3NGibC5nSB727PFjC0Qp8ZFs9F8Ee8WDu35LJ5fk-" alt=""></p><p>이 창이 뜨면서 작업표시줄엔 아름다운 고래 마스코트가 뜨게 됩니다.</p><p>설치후엔 PowerShell 에서 직접 도커 명령어로도 실행 할수있지만 GUI툴도 제공 함으로 같이 설치 해보겠습니다.</p><p><img src="https://lh4.googleusercontent.com/JIKrsZiVQNq7OvxtICSOZZMeBeR_3mDKlx_-rqFgi_2q98QNHVnY4aYMhLz5ODwMAR889mpbl9EiePv_FGhqH6-_rw_cDCrMWWW3qVmJIKQS7pd67kndRsbifFCbSzMKZW3UxybL" alt=""></p><p>고래를 우클릭 후 Kitematic을 클릭합니다.</p><p><img src="https://lh6.googleusercontent.com/jkjkJG84j11jZuWJAesHsOBYFaCnIYw0bwkitnOBUdAGMgP-rlZnu5AXp5k7D0a0wtga4h_SwIAKL-QNJSa2qAFEZqa9CDbM0RcUmL4NCBt64AGgTdY0rfZkyEKWz-ELhOQldyV5" alt=""></p><p>보시면 다운로드하고 난 뒤 압축을 푼 후 C:\Program Files\Docker\Kitematic 이 디렉토리에 삽입하라는 뜻 같습니다.(압축푼 후 폴더명이 Kitematic-Windows 이므로 Kitematic으로 이름변경)</p><p><img src="https://lh6.googleusercontent.com/RwQEpzbTHa9GzVn0w_Cg7tcZ3yRpHt8uNB-wb4VIBsgJAngy1DZKgJnW6Vi06rfwuPCtS2gKXmUoV6dt3QjsS43Z8HFvAFwI3MeJ8teS424NjkfdpE-uaUHRIcZ63ScMNzs-dKpy" alt=""></p><p>이 위치에 이동 한 후 다시 고래를 우클릭하여 Kitematic을 클릭 합니다.</p><p><img src="https://lh6.googleusercontent.com/2ZMc0mpOOHPJadlWk9eziOCWcrcljvDclaCYtNWJmCJlnZH2zpMqEI_Ulq9jhKZhIiGXBGCcUIMXJwusQgpvfR_Lo4t18EM80koGgNtnQ-SHyJwAxgiWkCq_nM0sIz8CKQQZ00Hn" alt=""></p><p><img src="https://lh6.googleusercontent.com/rUKFGuZZXE418k3te9H_vtQoyUaqrtIRZioISdWBCmMXnfECkNigSlTX2xTiuRVgHB4QcFjT09D9_iJEv3o7oGU6ljheSAF8zgigMyUAm61CG3FXbBrY17u2hA-LAzgQPtVot5Xo" alt=""></p><p>GUI로 편하게 다운로드하고 실행 할수 있습니다. 이걸로 로컬에서 텐서플로우나 젠킨스를 설치해서 연습 해보는것도 좋을거 같습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;저같이 도커를 잘모르는 사람에게 쉽게 접근할수있게 제공해주는 GUI툴 Kitematic이 있습니다. 클릭 몇번으로 이미지를 다운로드 받아서 컨테이너 생성까지 정말 간편하게 사용하고 로그도 출력되며 웹포트가 열려있으면 웹도 쉽게 띄울수있습니다. 도커를 처음 입문 하시는 분들을 위해 설치법을 공유 합니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh5.googleusercontent.com/UHmV5WSHhvRlKaAmvdguxMez7h5m-04p88NRKNJam0Djet7ruQ3J9JzjfC85aMB8bkX2Dxvhf1Vr21jal0BD_s1zERPg-cgTdozqFDqiLpnz1P4NT3xlWW_fIhkzQJsCbKKMnFEJ&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;윈도우에서 도커를 깔기 위해 메인페이지의 다운로드를 사용하여 설치하였습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh6.googleusercontent.com/ebsAUwtoRySMs0YOoWc4UkepSaDRkXXmDH_XhrKDYOA8aZCj3tTLfYYBKS8UEjSovRJx5cdo1yma16UAj70T2vMegwmL-qNBthjPstKA2Ge6zoZyu25rJyfeD-G_G79AroQR2lE5&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="도커" scheme="http://kji6252.github.io/categories/%EB%8F%84%EC%BB%A4/"/>
    
    
      <category term="Docker" scheme="http://kji6252.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>오브젝트 매핑과 슈퍼 타입 토큰</title>
    <link href="http://kji6252.github.io/2017/02/26/obj-map-super-type-token/"/>
    <id>http://kji6252.github.io/2017/02/26/obj-map-super-type-token/</id>
    <published>2017-02-26T05:49:00.000Z</published>
    <updated>2021-04-02T02:38:07.050Z</updated>
    
    <content type="html"><![CDATA[<p>자바 프로젝트를 진행 하면서 외부 데이터를 가지고 VO클래스에 매핑하고 여러가지 연산작업을들 합니다. 그중에서도 VO클래스의 정보를 가져와 매핑하는 방법에 대해서 궁금하게 되었고 자바에서 제공하는 리플렉션API와 간단한 예제들을 통해서 오브젝트 매핑에 대해 알아 보겠습니다.</p><h1 id="클래스-정보-가져오기"><a href="#클래스-정보-가져오기" class="headerlink" title="클래스 정보 가져오기"></a>클래스 정보 가져오기</h1><p><img src="https://lh3.googleusercontent.com/zTxL5DggFKxHZLneUwRJK5YdQIy_LnyqIY3mBw7AfODKK8IPvXFPyKpcR_v6ubLWJNE9A0X98wRd3dh8BTzVWNiyUoW-gZ05M4u7u438Hs64zYh8oAF9agQssXweD0UXqrWDbcrO" alt=""></p><p><img src="https://lh5.googleusercontent.com/7MuU11r2J8S1R1ovuTe_YtDUQUrEm6Jpw3OaMC3EXkAVFbnXa7VKuly2VVItV1R_mszHCYefqlSgCpyUB7H6KisADLcSRcBewc2eNKx7GuH7BDqhUMjKxMco3UtECaZLoFw7R-8r" alt=""></p><p><img src="https://lh4.googleusercontent.com/xmWa-9ga69f3_nZPt-xnKffPO1f6QUuZ3_sHoQ9ndUWEB3S1njE5HItEUzPulcwIMbwWEAnUL498QmOUjx1MmarJLMZZ4cUbimmij0s6DNw07tjhCrRtsw7ZY4TT2ttGeS7YFoa1" alt=""></p><p>자바는 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html" target="_blank" rel="noopener">java.lang.reflect패키지의 API</a>를 가지고 클래스의 정보와 필드 어노테이션 정보까지 모두 가져 올수 있는 리플렉션을 제공 합니다.</p><p>그래서 이렇게 구할수 있는 정보를 가지고 외부에서 가져오는 json 데이터나 sql문을 가져올시 매핑을 하여서 해당 오브젝트로 값을 삽입해 넘겨줄수 있습니다.<br><a id="more"></a></p><h1 id="조금더-편리한-API"><a href="#조금더-편리한-API" class="headerlink" title="조금더 편리한 API"></a>조금더 편리한 API</h1><p>리플렉션 API로도 훌륭하게 매핑이 가능하지만 조금더 사용하기 편리하고 안전하게 매핑할수 있도록 자바에서 제공하는 <a href="http://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html" target="_blank" rel="noopener">java.beans</a>  에서 제공하는 API를 사용 하겠습니다.</p><p><img src="https://lh3.googleusercontent.com/8xNkymsQkfBX-TmoQ2RO0W5fdUuqgKCEfJl4R1Uawq7HBpiEK6eaEuDBZaYlkLT6dwx7PCWPg8BPAXzN6zPsTq2blXEvyfC-DWbqySgAdf2LVYaEOI4kICZTpbbx8DTKQ0crgE72" alt=""></p><p><img src="https://lh6.googleusercontent.com/wPHO2g0WHhg3S21KPk2yyypIqz82MZYkd4QDRRgA533A8AyMzRnbu1cerZoq7Cy8AgVMBTvMbm83NOsz2gZCS7JRixxFxFQkGZkr2giJ-r6VyfRWvaGTrLFIr1NIAnjBtiFhc3is" alt=""></p><p>BeanInfo 객체를 생성할 땐 Introspector.getBeanInfo라는 static factory methode를 이용하여 빈정보를 생성한뒤 각각의 BeanDescriptor, PropertyDecriptors, MethodDescriptors를 가져와서 리플렉션보다는 편리하게 클래스 정보를 가져 올수 있습니다.</p><p>여기에서 map형태나 json형태의 값을 가져 왔을때 오브젝트 매핑을 해야 하는데 PropertyDecriptors의 출력결과를 자세히 보시면  각각의 property에 대해서 redeMethod와 writeMethod정보를 보여주고 있습니다. 이걸 활용하여 맵에 프로퍼티이름과 값을 넣어두고 간단하게 매핑하는 예제를 보여드리겠습니다.</p><h1 id="심플-매핑"><a href="#심플-매핑" class="headerlink" title="심플 매핑"></a>심플 매핑</h1><p><img src="https://lh3.googleusercontent.com/ixgFYKAHCtiIy3oCTGPYLWDlGyzEf1Qnn5MxaiaBqV7aQi0mAUWFaWB8es5FJSEWQFlNk5p0W9owbpiF-Ed6nxzijCj2ylwkB6uuXFrYL5ft7rSEU0VKZayX1_CmNSkpAgPsNkRH" alt=""><img src="https://lh6.googleusercontent.com/AuVpSJA-exBvOs3jNI4zBdUAFZYHhoHbw9ejh8kmP1ZpqE3TNfW8cHn3h9flzBDpRJCkA9T7qzByUMQbXrF_XDK_HNR3mCN3_Bagpnjac3pbFhDzliPUAyzTB0xNxY3QsLmUyJ-B" alt=""></p><p>Map에 프로퍼티 이름과 동일하게 값을 셋팅해주고 List에 한개씩 담았습니다.</p><p><img src="https://lh6.googleusercontent.com/lXysD5r5KMvR4KrA-4o4TzYUFbT1fY9p9L3FUGVzWbQY25OswG6QLc-57KqmhnWclxu23wBTdZfKrJNZHB-HCvKhZY2byWUeFAxX7Y3Fs-S-OKJ5oaUGkjbWINykikAoPQydIzio" alt=""></p><p><img src="https://lh5.googleusercontent.com/AIAKcveEE9SqB6K814sY0cxC9z-7T1jRR2yJhPLlajwOdOEhFYqT20BG2fneRpVsMD42jdGITSU3RzEe072OhmFugCJAT_he_wG5Kl-1vIq25coVuyjWtSQh9-G1XTgSdpa-3-Fl" alt=""></p><p>소스를 보시면 셋팅된 데이터로 forEach문을 돌리면서 Map을 한개씩 가져옵니다 그러면서 데이터를 셋팅될 오브젝트를 생성하고(User u = new User();) forEach문 안에 property를 한개씩 꺼내오면서 property의 이름을 으로  Map의 키값을 검색하여 Map의 Value를 가져와 propertyDescriptor.getWriteMethod를 이용하여 값을 셋팅 해줍니다. 보기엔 복잡해 보이지만 하나씩 따라가보면 비교적 쉽게 느껴 지실수 있습니다.</p><h1 id="타입-토큰"><a href="#타입-토큰" class="headerlink" title="타입 토큰"></a>타입 토큰</h1><p>예제 소스 코드중에서 Introspector.getBeanInfo(User.class)가 있는데 보통 User.class를 타입 토큰 이라고 합니다. 그런데 자바에서는 아쉽게도 타입 토큰에는 컴파일시 제너릭정보를 담을수가 없어서 class정보만을 가져올수가 있습니다.(C#은 자바와는 다르게 제너릭정보를 바로 가져올 수 있다고 하네요…)</p><p><img src="https://lh6.googleusercontent.com/cpaRAc9n-IR87kuFPxIG9tPazuf_MAom9eB4P28zI1UX0nB_RsLKF5TBmTEWUBXI9p77T3X0-hsxz32MewZXWc7gQqqf_oI-_HTp_zPfjIgdBTF-H_moctetQiO8AiLgqLM85E8M" alt=""></p><p>그래서 이걸 해결하기 위해 나온것이 슈퍼 타입 토큰 이라고 합니다.</p><h1 id="슈퍼-타입-토큰"><a href="#슈퍼-타입-토큰" class="headerlink" title="슈퍼 타입 토큰"></a>슈퍼 타입 토큰</h1><p>슈퍼 타입 토큰은 클래스의 제너릭 정보까지 가져오는 방식 입니다. 익명클래스를 작성하여 상속하면 상속된 정보는 컴파일시 지워지지가 않는다고 하여 익명클래스 상속방식으로 슈퍼 타입 토큰을 가져옵니다.</p><p><img src="https://lh5.googleusercontent.com/GK_Ln1HE0_E76nWJ_iI0GosG3zu42pQlEODP_inwXj59rgHLZW9pcdD-P_jDFStl0plIjyZFM4z3SOjKb4gEotzQV3xeqr1rD7uiSq5aF2KDs4rmL4jmErWksojPAWVFbSbJearE" alt=""></p><p><img src="https://lh3.googleusercontent.com/esqJ7eEkJus5ULjV1qLJS-ExMCZh0DL35V-T8MOugvu7cJ9sL41OkXaxtqKbnpfxb-rCRr1GgAr1scS-Xvp-E87_Td3hCaAQEq5roYfui3l21yXNu4Pg04Zb7HLnVZ1ToZa74Z_l" alt=""></p><p>예제 소스를 보시면 extends가 된 클래스(슈퍼 클래스)는 가져오지만 List의 String정보는 못가져오고 있습니다. 이를 이용하여 슈퍼 타입 토큰을 이용하면 제너릭 정보를 가져올수가 있습니다.</p><p>위의 예제에서 슈퍼 타입 토큰을 사용하기 편하게 클래스를 정의해 보겠습니다.</p><h1 id="타입-토큰과-슈퍼-타입-토큰-비교"><a href="#타입-토큰과-슈퍼-타입-토큰-비교" class="headerlink" title="타입 토큰과 슈퍼 타입 토큰 비교"></a>타입 토큰과 슈퍼 타입 토큰 비교</h1><p>슈퍼 타입 토큰을 사용을 간소화 하기 위해서 클래스를 작성하였습니다.</p><p><img src="https://lh5.googleusercontent.com/vvUtMfd0ahq6gexc7qxtJ_QnIF_EltH2E1DSpMwwUO4ILA0GPj3pYQj721asJI8OY2fwvreDN0NEZxdx85eLuAKvCcKH0sMJWGfCrnhgba6UUiWD81Hxrocd8F5BI2dQeOW7mq0n" alt=""></p><p><img src="https://lh5.googleusercontent.com/MFcCZF1gnE9P39DXHt72O2milkUhFWw6QggdcMIwtdHl45RvsN6u5xxGwUdd8yLuZyLglwcUet0wX7pLEAtMz3CyCSk-BUxZnUbQRmd4pbwSksx4a8xpv6F9KFBhA5s0GVFH7Ggk" alt=""></p><p>ParametertizedType은 파라미터형의 타입을 표현하는 인터페이스 입니다.</p><p><img src="https://lh4.googleusercontent.com/yKpVaNrNA46PntfeVXqsSRVf-235XVgOdSuq626O92BQvFMxt2ns71lh1ihPmIo36Aeo81HrDbzbQgiBDLZJOjvQa1BOC9ow1vdVcOLDr2qEiMASAiv50nqjzxyVbGaqpw2YEEJk" alt=""></p><p><img src="https://lh6.googleusercontent.com/V3cwFZb8eTXCLPg2krzvc34xGM6kiheju95JdAK26g2nPSw98U_megoVlc_5pxd9tQ5DwvIfG7GROwbwBjtoPw9XAlnIs9ONsf6xdc4nh6LcnNXnhBFijuoAUYvhBLCjeXY53exq" alt=""></p><p>슈퍼 타입 토큰의 경우 제너릭정보를 모두 불러오지만 타입 토큰은 제너릭정보를 담을수가 없어 제한적일수바께 없습니다.</p><h1 id="예제1-JDBC-예제"><a href="#예제1-JDBC-예제" class="headerlink" title="예제1. JDBC 예제"></a>예제1. JDBC 예제</h1><p>GitHub : <a href="https://github.com/kji6252/ORM-example2.git" target="_blank" rel="noopener">https://github.com/kji6252/ORM-example2.git</a></p><p>앞에서 알아본 클래스정보를 가져올수있는 BeanInfo와 슈퍼타입 토큰을 활용한 JDBC 오브젝트 매핑 예제를 작성 했습니다.</p><p><img src="https://lh4.googleusercontent.com/Inrvu8Q5cyxn6uUflGwUWooTSMzcEmF836jshhhVbjiKSFL2cfiCD1xLQ3GFyf_QvIe7Jv-mtDiDCQROMhrpE7dDi5R4HZMYmGYUK3KXZxTBz6z3n1WBYw5VULSkq1-QuM1ndN3j" alt=""></p><p>그림. JDBC 예제 구성도</p><p><img src="https://lh3.googleusercontent.com/5VxKu7uQT5E8aS27pza4EqO3cEaS6nfb3vl6ajm7UiQqihF97uk2xoqGjOTKvYIfC862RreaPZkClp9NvUK383apblt_jYZrVK1RolngYjfBtRo2hTFHnggWZbaxcHHMho5-EM2j" alt=""></p><p>그림. JDBC 예제 메인</p><p><img src="https://lh6.googleusercontent.com/6Kl-RbXeNRpR1XoLYU-bFEn1adOyeoXO7DjVVK4m49Uc1iTEI7TB83c39KBPLsWCPNOHmMpUWwOHBYiZ_rsvN5L1Pk8j8xEnUF4R33aS98AuTyamxjkpZ3RvkidO-NeYeTR4TD8Y" alt=""></p><p>OMMaper에서는 query메서드 에서 각각 원하는 결과를 리턴 할 수 있는 classQuery,listQuery,mapQuery 로 분기 한다음 ResultSet과 BeanInfo의 PropertyDescriptor로 매핑하여 최종 결과를 리턴 하게 됩니다.</p><p><img src="https://lh6.googleusercontent.com/0z2WdYBfAitNB7i_TLlnDtwosZ88xGfcxtclxh6Cl_aqO_R0Y_2BvaQx_UMS5fwXN75dbO-arWYRwxij8Jg4BvvPyntwcspZqEBToTKu5id9a0uFpCO5zf8sfnyLZczktV1jz3Sg" alt=""></p><h1 id="예제2-Spring-JDBC-예제"><a href="#예제2-Spring-JDBC-예제" class="headerlink" title="예제2. Spring JDBC 예제"></a>예제2. Spring JDBC 예제</h1><p><img src="https://lh5.googleusercontent.com/Rf1_7lZUrZrRZGsWz6F5j6ksmMVhOuA71twmpDXjBFX3CDKpYPyVTXmS5ZBcPRlexkF1-UnZZW809SDMaTSBQ77chQCS4zG1Yj_vRPkj3DLUn3RgeF7OG_FRw8y3RrdfcOldCfv1" alt=""></p><p>스프링에서 제공하는 SqlQuery를 상속받으면 protected abstract RowMapper<t> newRowMapper(Object[] parameters, Map&lt;?, ?&gt; context); 메서드를 구현해야 합니다.</t></p><p>스프링 JDBC예제에서도 예제1과 동일한 방식으로 매핑을 하였습니다.</p><p><img src="https://lh3.googleusercontent.com/W_yVyNZImegA-RvhkmR4VgLkTxH27iHc668FrDQ1rVXX-Oxjj71dTnpdSWmSDe__To5p_QN55-IaxhJldjqOH_X1AVRup6-FkwhGd6MipZY8cunmBJKNccYug5JXVKILOwdvj_UU" alt=""></p><p>예제 1과 동일하게 구성 하였습니다.</p><p><img src="https://lh4.googleusercontent.com/Ful9Fo8IaHCglYFUsEgmZJh1sbedNFkAdQ9GSLiGRQIxcYm8p8dQ1K0UTR_sG45GIR2nhcOQQ7_1ZOnGkUL9FcLpkBtVkESxWEHKaiFYGZs8F_dfYYZ7ao9QkutBDkCPTgockuxU" alt=""></p><p>SqlQuery에서 아이디값으로 sql문을 실행하여 RowMapper로 매핑하여 결과를 가져 옵니다.</p><p><img src="https://lh6.googleusercontent.com/F82h6abhGSpL58CIuTZKNDr07P3ptcGM0hqGqj3BR4xuorELhlslqArA7mzUc_1CEnSeacflICkLipcwZ1_m45nUCXr9gzus9z9xyCXQsnQgjhUB26OMxN5NnuTLi8R3AmagW3PB" alt=""></p><p>예제 : <a href="https://github.com/kji6252/ORM-example2" target="_blank" rel="noopener">https://github.com/kji6252/ORM-example2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;자바 프로젝트를 진행 하면서 외부 데이터를 가지고 VO클래스에 매핑하고 여러가지 연산작업을들 합니다. 그중에서도 VO클래스의 정보를 가져와 매핑하는 방법에 대해서 궁금하게 되었고 자바에서 제공하는 리플렉션API와 간단한 예제들을 통해서 오브젝트 매핑에 대해 알아 보겠습니다.&lt;/p&gt;
&lt;h1 id=&quot;클래스-정보-가져오기&quot;&gt;&lt;a href=&quot;#클래스-정보-가져오기&quot; class=&quot;headerlink&quot; title=&quot;클래스 정보 가져오기&quot;&gt;&lt;/a&gt;클래스 정보 가져오기&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/zTxL5DggFKxHZLneUwRJK5YdQIy_LnyqIY3mBw7AfODKK8IPvXFPyKpcR_v6ubLWJNE9A0X98wRd3dh8BTzVWNiyUoW-gZ05M4u7u438Hs64zYh8oAF9agQssXweD0UXqrWDbcrO&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh5.googleusercontent.com/7MuU11r2J8S1R1ovuTe_YtDUQUrEm6Jpw3OaMC3EXkAVFbnXa7VKuly2VVItV1R_mszHCYefqlSgCpyUB7H6KisADLcSRcBewc2eNKx7GuH7BDqhUMjKxMco3UtECaZLoFw7R-8r&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lh4.googleusercontent.com/xmWa-9ga69f3_nZPt-xnKffPO1f6QUuZ3_sHoQ9ndUWEB3S1njE5HItEUzPulcwIMbwWEAnUL498QmOUjx1MmarJLMZZ4cUbimmij0s6DNw07tjhCrRtsw7ZY4TT2ttGeS7YFoa1&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;자바는 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/package-summary.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java.lang.reflect패키지의 API&lt;/a&gt;를 가지고 클래스의 정보와 필드 어노테이션 정보까지 모두 가져 올수 있는 리플렉션을 제공 합니다.&lt;/p&gt;
&lt;p&gt;그래서 이렇게 구할수 있는 정보를 가지고 외부에서 가져오는 json 데이터나 sql문을 가져올시 매핑을 하여서 해당 오브젝트로 값을 삽입해 넘겨줄수 있습니다.&lt;br&gt;
    
    </summary>
    
      <category term="스프링" scheme="http://kji6252.github.io/categories/%EC%8A%A4%ED%94%84%EB%A7%81/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="http://kji6252.github.io/tags/Spring/"/>
    
      <category term="JDBC" scheme="http://kji6252.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>QueryDSL</title>
    <link href="http://kji6252.github.io/2017/01/23/jpa-basic-10/"/>
    <id>http://kji6252.github.io/2017/01/23/jpa-basic-10/</id>
    <published>2017-01-23T00:53:00.000Z</published>
    <updated>2021-04-02T02:38:07.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-QueryDSL-소개"><a href="#1-QueryDSL-소개" class="headerlink" title="1 QueryDSL 소개"></a>1 QueryDSL 소개</h1><ul><li>JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API</li><li>JPA 크리테리아에 비해서 편리하고 실용적임</li><li>쿼리를 문자가 아닌 코드로 작성해도, 쉽고 간결하며 그 모양도 쿼리와 비슷하게 개발 할 수 있는 프로젝트가 바로 QueryDSL 이다.</li><li><p>오픈소스</p><a id="more"></a><h1 id="1-1-장점"><a href="#1-1-장점" class="headerlink" title="1.1 장점"></a>1.1 장점</h1></li><li><p>문자가 아닌 코드로 작성</p></li><li>컴파일 시점에 오류 발견</li><li>코드 자동완성</li><li>단순함, 쉬움: 코드 모양이 JPQL과 거의 흡사.</li><li>동적 쿼리</li></ul><h1 id="1-2-작동-방식"><a href="#1-2-작동-방식" class="headerlink" title="1.2 작동 방식"></a>1.2 작동 방식</h1><p><img src="https://lh5.googleusercontent.com/AVfAUXPSxor45lTvSanV-IkKLYRLndp7qXOe2dWBKnZjZ8N0PBckegjWNpvXWS3SPj9QpwWMLvl7U7cUj8KM7mY8X4ykbYx2zppPEKfMAe7dRen-Ew4CtUZA2evYtg8GLimWSm5M" alt=""></p><h1 id="1-3-maven-셋팅"><a href="#1-3-maven-셋팅" class="headerlink" title="1.3 maven 셋팅"></a>1.3 maven 셋팅</h1><p><img src="https://lh6.googleusercontent.com/YdriXl8A1rZH7--lMIoXIcmU6fPPy7JbEsGSKno86ZDLv30joetRMJyeC20hI-EpuM-Bl13kj3clgsQ2bwwIitOaSeks1TqjXppMSVG6Rg8B1OEbmyOQNyEmaly311jAP_PzKUky" alt=""></p><p><img src="https://lh6.googleusercontent.com/6oCoJka5d-3cKXoyYdczF7JsamRj1q9H8OzuVgI_AILRrX4jeeddlS2asWCLX1BkBRD1aTFpVx6Mt0c8EOnvd2efe8XAp52whdGbsiDn09uVomS7xHkC6ImkrosW0_8BXb0xNB4N" alt=""></p><h1 id="1-4-쿼리-타입-생성"><a href="#1-4-쿼리-타입-생성" class="headerlink" title="1.4 쿼리 타입 생성"></a>1.4 쿼리 타입 생성</h1><p><img src="https://lh5.googleusercontent.com/L-gnSon8L1sD9oD9VT-WeghP-ATZN_8YWuZ8-vinQUAmdQvkx0fsoVSLJsGP8HOLklEbxNHIW94JNQYEWrEbJPZJM6umLzlNVkWGv5ZURG2V_nnL012ZyIyMeEgCsYlB76zuLwOm" alt=""></p><p>메이븐 QueryDSL 설정을 하고 나서 mvn compile 명령어를 실행 하면</p><p>QueryDSL에서 사용할수 있는 Q타입 생성</p><p>JPQL - Entity</p><p>QueryDSL - QEntity</p><p>자동 생성된 쿼리 타입(Q)</p><p><img src="https://lh4.googleusercontent.com/0s2eVZ3ruiRy-E49StfPhuWafTfjthFXcfdzdlBMwZO8IKbNCq5n6LpvmTExW-sRnSx-2Tl2nZGFTrjBj42F2EOdr7JNTfdmPY4XEZmgUj7BkGwSXZF1gFSFNlOsm4ZOI2JhqiBk" alt=""></p><h1 id="1-5-쿼리-사용"><a href="#1-5-쿼리-사용" class="headerlink" title="1.5 쿼리 사용"></a>1.5 쿼리 사용</h1><p><img src="https://lh6.googleusercontent.com/gXyE-X1dZwfMK_Sf9B_nYyV8hDqF-udj7HNQLT9PQbGAE_daH_PGz0snVs1f646YvbyUM5tye8Opa3_49xFA2bfWsx_BQcZeJHIAKwhxuDjd9XuTe0KpzLNjNnib25voOUXzQKD8" alt=""></p><p>조인</p><p><img src="https://lh6.googleusercontent.com/c7P0-fsN_Xb6d3Td5zEXbFZ5s22S9Tn6xdw37WQlYmUzsjVoGYPLILOx77VWmnc0RiUTy39WcsftCVG3Go5YwQjk4g84_qzTwk1C53GezScGev1-T_UiO_YtffkFbj0ARYGkx-pr" alt=""></p><p>페이징</p><p><img src="https://lh3.googleusercontent.com/lQ1Ws8hnmbUY0RmO6RXvMPK-MFeqyLWxHzxNA9kw4nQDTs-hjlIV2IRe21R_OfNKaIZrRaw0BJJMHb2FmeBURro0ZiT1evP227f2XaJ83EYxtip7_rNVG6SfIQuUkgbuli65N_92" alt=""></p><p>동적쿼리</p><p><img src="https://lh3.googleusercontent.com/o5KMcCgJpWk5rBbLJLCLXk8ny7BDaeoPhveBsHSiuYKVvUhFh1SeRkjcELOYueRODsq7nyylqEv1eJD7kcWItSdc6ICQFiIgIVkM4ugna2kdlBJyoeIgXfsp1Tucg7fV6-V9nmCA" alt=""></p><h1 id="1-6-기능-정리"><a href="#1-6-기능-정리" class="headerlink" title="1.6 기능 정리"></a>1.6 기능 정리</h1><ul><li>from</li><li>innerJoin, join, leftJoin, fullJoin, on</li><li>where (and, or, allOf, anyOf)</li><li>groupBy</li><li>having</li><li>orderBy (desc, asc)</li><li>limit, offset, restrict(limit + offset) (Paging)</li><li>list</li><li>listResults (list + Paging Info(totalCount))</li><li>iterate</li><li>count</li><li>singleResult, uniqueResult</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-QueryDSL-소개&quot;&gt;&lt;a href=&quot;#1-QueryDSL-소개&quot; class=&quot;headerlink&quot; title=&quot;1 QueryDSL 소개&quot;&gt;&lt;/a&gt;1 QueryDSL 소개&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;JPQL을 코드로 작성할 수 있도록 도와주는 빌더 API&lt;/li&gt;
&lt;li&gt;JPA 크리테리아에 비해서 편리하고 실용적임&lt;/li&gt;
&lt;li&gt;쿼리를 문자가 아닌 코드로 작성해도, 쉽고 간결하며 그 모양도 쿼리와 비슷하게 개발 할 수 있는 프로젝트가 바로 QueryDSL 이다.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;오픈소스&lt;/p&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>객체지향 쿼리 언어</title>
    <link href="http://kji6252.github.io/2017/01/23/jpa-basic-09/"/>
    <id>http://kji6252.github.io/2017/01/23/jpa-basic-09/</id>
    <published>2017-01-23T00:47:00.000Z</published>
    <updated>2021-04-02T02:38:07.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-JPQL-소개"><a href="#1-JPQL-소개" class="headerlink" title="1 JPQL 소개"></a>1 JPQL 소개</h1><p>JPQL(Java Persistence Query Language) : 엔티티 객체를 조회하는 객체지향 쿼리.</p><ul><li>JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.</li><li>JPQL은 객체지향 쿼리 언어다. 테이블X 엔티티O</li><li>JPQL은 결국 SQL로 변환된다.<a id="more"></a>1.1 기본문법</li></ul><hr><p>JPQL도 SQL과 비슷하게 SELECT, UPDATE, DLEETE 문을 사용(INSERT는 EntityManager.persist() 사용)</p><ul><li>대소문자 구분 : 엔티티와 속성은 대소문자 구분(ex : Member, username). 반면 SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않음</li><li>엔티티 이름 : @Entity(name=”XXX”)로 지정하거나 지정안할시 클래스명을 기본으로 사용</li><li>별칭은 필수 JPQL 표준은 필수 HQL(Hibernate Query Language)는 생략 가능.</li></ul><h2 id="1-2-쿼리-API"><a href="#1-2-쿼리-API" class="headerlink" title="1.2 쿼리 API"></a>1.2 쿼리 API</h2><p>반환타입을 명확히 할수 있는 TypeQuery와</p><p><img src="https://lh3.googleusercontent.com/8vfqOwI1AcjZ4HwAX6534UrU5EOT35F91gNfO524aKqinMIy6h7FbqmG0x2mKNlfn53S23uMvnPcMXtTFGkLcVkiW3BsTaEg9xJkU5-6Yyz6rBAgTTAbO4Y8FRotdn1KxNs2H5N8" alt=""></p><p>명확히 지정할 수 없을땐 Query를 사용하면 됨</p><p><img src="https://lh4.googleusercontent.com/RsoMfsdIw5B9kO6nFfXKIw_AxvFRZmU_BqmxdXyGZNkUKPM-8blAmPkG2QyNN4ye2C9TriJ_aTLZReIiuLvVD7MQPIHNUE4cf6TOwknfikyn-Ady5zzWAZOCY-GZtGWMVIwlUf0o" alt=""></p><h2 id="1-3-파라미터-바인딩"><a href="#1-3-파라미터-바인딩" class="headerlink" title="1.3 파라미터 바인딩"></a>1.3 파라미터 바인딩</h2><p>이름 기준</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT m FROM Member m where m.username=:username</span><br><span class="line"></span><br><span class="line">query.setParameter(&quot;username&quot;, usernameParam);</span><br></pre></td></tr></table></figure><p>위치 기준</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT m FROM Member m where m.username=?1</span><br><span class="line"></span><br><span class="line">query.setParameter(1, usernameParam);</span><br></pre></td></tr></table></figure><h2 id="1-4-페이징-API"><a href="#1-4-페이징-API" class="headerlink" title="1.4 페이징 API"></a>1.4 페이징 API</h2><p><img src="https://lh5.googleusercontent.com/sUJy0ndiig55APOeS5LrAyEwVEUVsn6yJzvlcZbCN8fGhyH4iP1VKhTMO6BriUV20gizfNbGMT5U2V5_HMUAcRglLn84hMvbk35s-ehvgcsleiJX6qE0wGhMyCtfrtI-7gBkabaj" alt=""></p><p>페이징 API - MySQL 방언</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">M.ID <span class="keyword">AS</span> <span class="keyword">ID</span>,</span><br><span class="line">M.AGE <span class="keyword">AS</span> AGE,</span><br><span class="line">M.TEAM_ID <span class="keyword">AS</span> TEAM_ID,</span><br><span class="line">M.NAME <span class="keyword">AS</span> <span class="keyword">NAME</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">MEMBER</span> M</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">M.NAME <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> ?, ?</span><br></pre></td></tr></table></figure><p>페이징 API - Oracle 방언</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span> ROW_.*, <span class="keyword">ROWNUM</span> ROWNUM_</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span></span><br><span class="line">M.ID <span class="keyword">AS</span> <span class="keyword">ID</span>,</span><br><span class="line">M.AGE <span class="keyword">AS</span> AGE,</span><br><span class="line">M.TEAM_ID <span class="keyword">AS</span> TEAM_ID,</span><br><span class="line">M.NAME <span class="keyword">AS</span> <span class="keyword">NAME</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">MEMBER</span> M</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> M.NAME</span><br><span class="line">) ROW_</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">ROWNUM</span> &lt;= ?</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> ROWNUM_ &gt; ?</span><br></pre></td></tr></table></figure><h2 id="1-5-집합과-정렬"><a href="#1-5-집합과-정렬" class="headerlink" title="1.5 집합과 정렬"></a>1.5 집합과 정렬</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">COUNT</span>(m),   //회원수</span><br><span class="line"><span class="keyword">SUM</span>(m.age), //나이 합</span><br><span class="line"><span class="keyword">AVG</span>(m.age), //평균 나이</span><br><span class="line"><span class="keyword">MAX</span>(m.age), //최대 나이</span><br><span class="line"><span class="keyword">MIN</span>(m.age)  //최소 나이</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Member</span> m</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>, <span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br></pre></td></tr></table></figure><h2 id="1-6-조인"><a href="#1-6-조인" class="headerlink" title="1.6 조인"></a>1.6 조인</h2><ul><li>내부 조인: SELECT m FROM Member m [INNER] JOIN m.team t</li><li>외부 조인: SELECT m FROM Member m LEFT [OUTER] JOIN m.team t</li><li>세타 조인: select count(m) from Member m, Team t where m.username = t.name</li></ul><p>한계: 세타 조인시은 내부 조인만 사용할 수 있다.​</p><h3 id="페치-조인"><a href="#페치-조인" class="headerlink" title="페치 조인"></a>페치 조인</h3><ul><li>엔티티 객체 그래프를 한번에 조회하는 방법</li><li>별칭을 사용할 수 없다.</li><li>JPQL: select m  from Member m join fetch m.team</li><li>SQL: SELECT  M.<em>, T.</em> FROM MEMBER T INNER JOIN TEAM T ON M.TEAM_ID=T.ID</li></ul><p>예시</p><p><img src="https://lh6.googleusercontent.com/uZz7CeaYZtnDJchkM8vyR_Pdnlql-B5vBShuplBoaumtekaABcipYMrpUMk0G3yQttPHpKnvaxGt5SeNjldEg7mqMFIKk7aHVikl55dABDf6_7hhK22N8Zlkxd7alFtf9C1SnwE9" alt=""></p><p>최적화를 위해 글로벌 로딩 전략을 즉시 로딩으로 설정하면 애플리케이션 전체에서 항상 즉시 로딩이 일어난다. 물론 일부는 빠를 수는 있지만 전체로 보면 사용하지 않는 엔티티를 자주 로딩하므로 오히려 성능에 악영향을 미칠 수 있다. 따라서 글로벌 로딩 전략은 될 수 있으면 지연 로딩을 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적이다.</p><h2 id="1-7-JPQL-기타"><a href="#1-7-JPQL-기타" class="headerlink" title="1.7 JPQL 기타"></a>1.7 JPQL 기타</h2><ul><li>서브 쿼리 지원 (from절에서 사용안됨)</li><li>EXISTS, IN</li><li>BETWEEN, LIKE, IS NULL</li></ul><p>JPQL 기본 함수</p><ul><li>CONCAT 문자열 합침</li><li>SUBSTRING 문자열 자름</li><li>TRIM 빈공간제거</li><li>LOWER, UPPER 소문자로, 대문자로 치환</li><li>LENGTH 길이를 구함</li><li>LOCATE 검색위치부터 문자를 검색 1부터 시작 못찾으면 0반환</li><li>ABS 절대값, SQRT 제곱근, MOD 나머지</li><li>SIZE 컬렉션크기 구함, INDEX 컬렉션의 위치값 구함(JPA 용도)</li></ul><p>CASE 식</p><p><img src="https://lh6.googleusercontent.com/VLOLnFRuB27J5AyS_kUpRuz5Qyo-yIJWq5JNzTjPI_5yv0ELDLEoZCm_YW0FO_zB3M6zh1kPyu-hPBZntRdK7qBqVtIYsF67nTom2jGF55ZalBrzRcmGHeXLKjXMLsqiRd8UFeZy" alt=""></p><p><img src="https://lh3.googleusercontent.com/mfoMorocy1hxklYtF8HwetaPQraDig8e2anEdAQmPOD1paJaYuGiWRojFptNNXCAAOyXhRJcM7T-5QPhKVQvbhK6aEZDapx2NCkfly7Nc199dRlmXQzBssCW0tppI2aOHBGA0EGh" alt=""></p><h2 id="1-8-Named-쿼리-정적-쿼리"><a href="#1-8-Named-쿼리-정적-쿼리" class="headerlink" title="1.8 Named 쿼리: 정적 쿼리"></a>1.8 Named 쿼리: 정적 쿼리</h2><ul><li>미리 정의해서 이름을 부여해두고 사용하는 JPQL</li><li>어노테이션, XML에 정의</li><li>애플리케이션 로딩 시점에 초기화 후 재사용</li><li>애플리케이션 로딩 시점에 쿼리를 검증</li></ul><p><img src="https://lh4.googleusercontent.com/2SRgVZWCpn6hQaCqiQP0vziMpEoHHNnpr9J4e2hAnPGK90to6DbgDzvX57_qXT4EIXYPot2Hgi1tbkUlZLGjMkF680b7AY7YW9f5GrMVxVVdUAKlG1nK106Eph-UYEytyyDqUgJw" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-JPQL-소개&quot;&gt;&lt;a href=&quot;#1-JPQL-소개&quot; class=&quot;headerlink&quot; title=&quot;1 JPQL 소개&quot;&gt;&lt;/a&gt;1 JPQL 소개&lt;/h1&gt;&lt;p&gt;JPQL(Java Persistence Query Language) : 엔티티 객체를 조회하는 객체지향 쿼리.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.&lt;/li&gt;
&lt;li&gt;JPQL은 객체지향 쿼리 언어다. 테이블X 엔티티O&lt;/li&gt;
&lt;li&gt;JPQL은 결국 SQL로 변환된다.
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>값 타입</title>
    <link href="http://kji6252.github.io/2017/01/23/jpa-basic-08/"/>
    <id>http://kji6252.github.io/2017/01/23/jpa-basic-08/</id>
    <published>2017-01-23T00:30:00.000Z</published>
    <updated>2021-04-02T02:38:07.049Z</updated>
    
    <content type="html"><![CDATA[<ul><li>기본값 타입basic value type<ul><li>자바 기본 타입(예: int, double)</li><li>래퍼 클래스(예: Integer)</li><li>String</li></ul></li><li>임베디드 타입embedded type(복합 값 타입)</li><li>컬렉션 값 타입collection value type</li></ul><h1 id="복합-값-타입"><a href="#복합-값-타입" class="headerlink" title="복합 값 타입"></a>복합 값 타입</h1><p><img src="https://lh6.googleusercontent.com/cFKZlL4JNdKV7OOHodNXWvVThMwQcfglx_M-_NGNV9w_jhBTsoUNteIPJuzfJUKELdLIB-es0t3LAPabcv5EFwKrPHO66R7FxMV8ZtAHZtTf7Da5aQpDcyNgw0qYKa7TIUuu78Ml" alt=""></p><p>복합값 정의 : @Embeddable 어노테이션으로 정의<br><a id="more"></a><br><img src="https://lh5.googleusercontent.com/zjMyPnfvziOQPVFFBUa6akdvuvQolEpd7DPYtacMSejuRFbCuQyz80J-Ha7mFq8eMXXTk2dr6XnxvyA_MXjvXABJP2b1vCwwhfCskB1aJVUOgcg9v3xoanl36bz9X-k4N6uO4F1D" alt=""></p><p>복합값 적용 : 값으로만 사용시엔 @Embedded로  키로 사용할땐 @EmbeddedID로 사용</p><p><img src="https://lh3.googleusercontent.com/ybiWfXUO5CAB6ysY_2US_fsWyn7QHbuDiXXlVSFcIgcvjvD4YUWFKkhWmRqKzgEHBJvl31u3doSa8azuk3bkZ4hGPGdjNS66m_JKAT_1s0VDH04a9LKGr08bw-IJkUobPSCZkWmI" alt=""></p><pre><code>임베디드 타입과                                                 테이블 매핑</code></pre><p><img src="https://lh4.googleusercontent.com/sVtWfNrR6NvI72i4S_6JTY_fHU0kpOiFotaUpWMJaIFkZTgopEx5OMF9GWueY7dUo5U99B1BAdkz0tf1PaiN2R8umbfJTwciGB_-76mcIO1ksJWXfgjwJIu7dbTar-ndBBCscEMZ" alt=""></p><p><img src="https://lh6.googleusercontent.com/riGO3K6RQLfVbmy5Y_jFy4DeIc-2jjDJZuGCiJkfPMJw_VmYL5nK7QsHbQMqu_9QBGdPb83YrZYOxMDCwXnyGJU5tEM5sTzojTZZaFGVnYhEshl-Mr19sm8JNDJVXHMfyk_QmTBw" alt=""></p><p>@AttributeOverride를 통해 컬럼명 변경 가능</p><h1 id="컬렉션-타입"><a href="#컬렉션-타입" class="headerlink" title="컬렉션 타입"></a>컬렉션 타입</h1><p><img src="https://lh5.googleusercontent.com/0kvuvVZUu3ZYD9KskRfjFmEnQ_gOTXeuPTLSNb8UDqT5mMFmTQkkOabnAgBvt_5OKIbf7W2k-YqU1Flos34li8fJ_Tfku4BagglZiqsRMIXWAUiJUPpu-dCQ8n1VZMb1fCptpU2D" alt=""></p><p><img src="https://lh5.googleusercontent.com/wWjtdic736w4ks-V-HNchKulPVo-bYPZrsz7YZmkn0SCyHl8MKT9oSlk5L0tkItVtLh5MBmY_yJoFjqhlhl8kPky1hCubI0Ncp8QpvyJ0Ze7aByiH6xtL6MISCtqUjqnVBmJ0Psz" alt=""></p><p>컬렉션 타입은 기본적으로 영속성 전이 + 고아 객체 제거기능을 필수로 가진다.</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;기본값 타입basic value type&lt;ul&gt;
&lt;li&gt;자바 기본 타입(예: int, double)&lt;/li&gt;
&lt;li&gt;래퍼 클래스(예: Integer)&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;임베디드 타입embedded type(복합 값 타입)&lt;/li&gt;
&lt;li&gt;컬렉션 값 타입collection value type&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;복합-값-타입&quot;&gt;&lt;a href=&quot;#복합-값-타입&quot; class=&quot;headerlink&quot; title=&quot;복합 값 타입&quot;&gt;&lt;/a&gt;복합 값 타입&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://lh6.googleusercontent.com/cFKZlL4JNdKV7OOHodNXWvVThMwQcfglx_M-_NGNV9w_jhBTsoUNteIPJuzfJUKELdLIB-es0t3LAPabcv5EFwKrPHO66R7FxMV8ZtAHZtTf7Da5aQpDcyNgw0qYKa7TIUuu78Ml&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;복합값 정의 : @Embeddable 어노테이션으로 정의&lt;br&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>프록시와 연관관계 관리</title>
    <link href="http://kji6252.github.io/2017/01/22/jpa-basic-07/"/>
    <id>http://kji6252.github.io/2017/01/22/jpa-basic-07/</id>
    <published>2017-01-22T03:10:00.000Z</published>
    <updated>2021-04-02T02:38:07.049Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener">프록시</a> : 연관된 객체를 실제 사용하는 시점에 데이터베이스에서 조회 하는 기술</li><li>지연로딩: 연관된 객체를 실제 사용하는 시점에 불러 오는것</li><li>즉시로딩 : 연관된 객체를 조인을 통하여 함께 불러오는것</li><li>영속성 전이 : 연관된 객체를 함께 저장하거나 삭제</li><li>고아 객체 : 부모객체가 삭제시 홀로 남겨지는 객체</li></ul><h1 id="8-1-프록시"><a href="#8-1-프록시" class="headerlink" title="8.1 프록시"></a>8.1 프록시</h1><p>엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다.</p><p>JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 지연 로딩이라 한다.</p><p>지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 <a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener">프록시</a> 객체라 한다.<br><a id="more"></a></p><h2 id="8-1-1-프록시-기초"><a href="#8-1-1-프록시-기초" class="headerlink" title="8.1.1 프록시 기초"></a>8.1.1 프록시 기초</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//즉시 로딩</span></span><br><span class="line">Member member = em.find(Member.class, “member1”);</span><br><span class="line"></span><br><span class="line"><span class="comment">//지연 로딩</span></span><br><span class="line">Member member = em.getReference(Member.class, “member1”);</span><br></pre></td></tr></table></figure><p>em.getReference()  사용시 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다. 대신에 데이터베이스 접근을 위임한 <a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener">프록시</a> 객체를 반환한다.</p><p><img src="https://lh4.googleusercontent.com/TFbaSRwKdNOGcqXLzZbPwkziCRR20msoGXUZyBpaIYj-jFUgItX9nkPXRtTaK069VPtZUxX7gsiFDQM7C23UZEFD4IxCDsKeQin7eXOC0o3kBhvs39bgjT7zWONJbVrM_cll4o7N" alt="JPA_8_1.png"></p><p>프록시 초기화</p><p>프록시의 특징</p><ul><li>프록시 객체는 처음 사용할 때 한 번만 초기화된다.</li><li>프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.</li><li>프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해야 한다.</li><li>영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다.</li><li>초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면 문제가 발생한다. 하이버네이트는 org.hibernate.LazyInitializationException예외를 발생시킨다.</li></ul><h2 id="8-1-2-프록시와-식별자"><a href="#8-1-2-프록시와-식별자" class="headerlink" title="8.1.2 프록시와 식별자"></a>8.1.2 프록시와 식별자</h2><p>프록시는 식별자 값을 가지고 있으므로 식별자 값을 조회해도 초기화하지 않는다 엔티티 접근 방식 설정으로 초기화 유무를 결정 할 수 있다.</p><p>@Access(AccessType.PROPERTY) : 식별자(getID())메소드 호출시 초기화 하지 않음</p><p>@Access(AccessType.FIELD)  : 식별자(getID())메소드 호출시 초기화 함</p><p>8.1.3 프록시 확인</p><p>JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object Entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">em.getEntityManagerFactory()</span><br><span class="line">.getPersistenceUnitUtil().isLoaded(entity);</span><br></pre></td></tr></table></figure><h1 id="8-2-즉시-로딩과-지연-로딩"><a href="#8-2-즉시-로딩과-지연-로딩" class="headerlink" title="8.2 즉시 로딩과 지연 로딩"></a>8.2 즉시 로딩과 지연 로딩</h1><p>즉시 로딩(EAGER) : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다. @ManyToOne(fetch=FetchType.EAGER)</p><p>지연 로딩(LAZY) : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다. @ManyToOne(fetch=FetchType.LAZY)</p><h2 id="8-2-1-즉시-로딩"><a href="#8-2-1-즉시-로딩" class="headerlink" title="8.2.1 즉시 로딩"></a>8.2.1 즉시 로딩</h2><p>대부분 JPA 구현체는 즉시 로딩을 최적화하기 위해 가능하면 조인 쿼리를 사용한다.</p><p>NULL제약 조건에 따라 내부 조인(INNER JOIN)이나 외부 조인(LEFT OUTER JOIN)을 사용</p><ul><li>@JoinColunm(nullable=true) : NULL 허용(기본값), 외부 조인 사용</li><li>@JoinColunm(nullable=false) : NULL 허용하지 않음, 내부 조인 사용</li><li>또는 @ManyToOne(fetch=FetchType.EAGER, optional=false)</li></ul><h2 id="8-3-2-JPA-기본-패치-전략"><a href="#8-3-2-JPA-기본-패치-전략" class="headerlink" title="8.3.2 JPA 기본 패치 전략"></a>8.3.2 JPA 기본 패치 전략</h2><p>fetch 속성의 기본 설정값은 다음과 같다.</p><p>@ManyToOne, @OneToOne : 즉시 로딩(FetchType.EAGER)</p><p>@OneToMany, @ManyToMany : 지연 로딩(FetchType.LAZY)</p><p>JPA의 기본 페치 전략은 연관된 엔티티가 하나면 즉시 로딩을, 컬렉션이면 지연 로딩을 사용 한다. 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다.</p><h2 id="8-3-3-컬렉션에-FetchType-EAGER-사용시-주의점"><a href="#8-3-3-컬렉션에-FetchType-EAGER-사용시-주의점" class="headerlink" title="8.3.3 컬렉션에 FetchType.EAGER 사용시 주의점"></a>8.3.3 컬렉션에 FetchType.EAGER 사용시 주의점</h2><ul><li>컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.</li><li>컬렉션 즉시 로딩은 항상 외부 조인(OUTER JOIN)을 사용한다.</li><li>@ManyToOne, @OneToOne<ul><li>(optional=false) : 내부 조인</li><li>(optional=true) : 외부 조인</li></ul></li><li>@OnetoMany, @ManyToMany<ul><li>(optional=false) : 외부 조인</li><li>(optional=true) : 외부 조인</li></ul></li></ul><p>일대다 다대다시엔 값이 없을경우도 조회를 해야 해서 무조건 외부조인으로 가져온다.</p><h1 id="8-4-영속성-전이-CASCADE"><a href="#8-4-영속성-전이-CASCADE" class="headerlink" title="8.4 영속성 전이: CASCADE"></a>8.4 영속성 전이: CASCADE</h1><p>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이(transitive persistence)기능을 사용하면 된다.</p><h2 id="8-4-1-영속성-전이-저장"><a href="#8-4-1-영속성-전이-저장" class="headerlink" title="8.4.1 영속성 전이: 저장"></a>8.4.1 영속성 전이: 저장</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(mappedBy=”parent”, cascade=CascadeType.PERSIST)</span><br></pre></td></tr></table></figure><p>부모를 영속화할때 연관된 자식들도 함께 영속화하라고 cascade=CascadeType.PERSIST 옵션을 설정했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//영속성 전이:저장X</span></span><br><span class="line">em.persist(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//연관관계 매핑 코드</span></span><br><span class="line">em.persist(child1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//연관관계 매핑 코드</span></span><br><span class="line">em.persist(child2);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//영속성 전이: 저장</span></span><br><span class="line"><span class="comment">//child와 parent연관관계 추가</span></span><br><span class="line">em.persist(parent);</span><br></pre></td></tr></table></figure><p><img src="https://lh6.googleusercontent.com/leZt4Zl1Dt8a658-c-AcYyjn395VqESdyuAumv5PcKhq-NhNE7R5MiovP1Dh_XtgW6SfWT5Gk5ZUOQNZEmL-pQ89kTKpEbe5nJX5YSIMmuropAZswPhr6n9H-OZlL8aGiSQgDkYo" alt="JPA_8_2.png"></p><p>CASCADE 실행</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//영속성 전이: 삭제X</span></span><br><span class="line">em.remove(findChild1);</span><br><span class="line">em.remove(findChild2);</span><br><span class="line">em.remove(findParent);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//영속성 전이: 삭제</span></span><br><span class="line">em.remove(findParent);</span><br></pre></td></tr></table></figure><p>엔티티를 영속화 하거나 제거 시 연관된 엔티티도 같이 처리 하는 편리함을 제공 한다.</p><h2 id="8-4-3-CASCADE의-종류"><a href="#8-4-3-CASCADE의-종류" class="headerlink" title="8.4.3 CASCADE의 종류"></a>8.4.3 CASCADE의 종류</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CascadeType&#123;</span><br><span class="line">ALL, <span class="comment">//모두 적용</span></span><br><span class="line">PERSIST, <span class="comment">//영속</span></span><br><span class="line">MERGE, <span class="comment">//병합</span></span><br><span class="line">REMOVE, <span class="comment">//삭제</span></span><br><span class="line">REFRESH, <span class="comment">//REFRESH</span></span><br><span class="line">DETACH <span class="comment">//DETACH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-5-고아-객체-ORPHAN"><a href="#8-5-고아-객체-ORPHAN" class="headerlink" title="8.5 고아 객체(ORPHAN)"></a>8.5 고아 객체(ORPHAN)</h1><p>JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OneToMany</span>(mappedBy=”parent”, orphanRemoval=<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>orphanRemoval=true 을 설정하면 사용 가능 하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Parent parent1 = em.find(Parent.class, id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//한개만 제거</span></span><br><span class="line">parent1.getChildren().remove(<span class="number">0</span>); <span class="comment">//자식 엔티티를 컬렉션에서 제거</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//모두 제거</span></span><br><span class="line">parent1.getChildren().clear();</span><br></pre></td></tr></table></figure><p>출처 : 자바 ORM 표준 JPA 프로그래밍 김영한</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프록시&lt;/a&gt; : 연관된 객체를 실제 사용하는 시점에 데이터베이스에서 조회 하는 기술&lt;/li&gt;
&lt;li&gt;지연로딩: 연관된 객체를 실제 사용하는 시점에 불러 오는것&lt;/li&gt;
&lt;li&gt;즉시로딩 : 연관된 객체를 조인을 통하여 함께 불러오는것&lt;/li&gt;
&lt;li&gt;영속성 전이 : 연관된 객체를 함께 저장하거나 삭제&lt;/li&gt;
&lt;li&gt;고아 객체 : 부모객체가 삭제시 홀로 남겨지는 객체&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;8-1-프록시&quot;&gt;&lt;a href=&quot;#8-1-프록시&quot; class=&quot;headerlink&quot; title=&quot;8.1 프록시&quot;&gt;&lt;/a&gt;8.1 프록시&lt;/h1&gt;&lt;p&gt;엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다.&lt;/p&gt;
&lt;p&gt;JPA는 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데 이것을 지연 로딩이라 한다.&lt;/p&gt;
&lt;p&gt;지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%ED%8C%A8%ED%84%B4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;프록시&lt;/a&gt; 객체라 한다.&lt;br&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>고급 매핑</title>
    <link href="http://kji6252.github.io/2017/01/17/jpa-basic-06/"/>
    <id>http://kji6252.github.io/2017/01/17/jpa-basic-06/</id>
    <published>2017-01-17T01:58:00.000Z</published>
    <updated>2021-04-02T02:38:07.049Z</updated>
    
    <content type="html"><![CDATA[<ul><li>상속 관계 매핑: 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지 다룬다.</li><li>@MappedSuperclass: 등록일, 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고 싶으면 이 기능을 사용하면 된다.</li><li>복합 키와 식별 관계 매핑: 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법을 다룬다. 그리고 데이터베이스 설계에서 이야기하는 식별 관계와 비식별 관계에 대해서도 다룬다.</li><li>조인 테이블: 테이블은 외래 키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결 테이블을 두는 방법도 있다. 여기서는 이 연결 테이블을 매핑하는 방법을 다룬다.</li><li>엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있다. 여기서는 이 매핑 방법을 다룬다.</li></ul><a id="more"></a><h1 id="7-1-상속관계-매핑"><a href="#7-1-상속관계-매핑" class="headerlink" title="7.1 상속관계 매핑"></a>7.1 상속관계 매핑</h1><p><img src="https://lh3.googleusercontent.com/3mNucKokBmtY-H9PpW0600QFxX2lxXfegLTjVxWKB9N6riIimJSni0It0qCnSLNEEZ1DgeOHWlj06RNObNyp-iZf-IA6E_e7e1j4o2s7BfFhUj6XIo_yufU5TEsngeBZqxJLE1xC" alt="JPA_Ex7_1.png"></p><p>객체 상속 모델</p><p>JPA에서는 상속관계를 총 3가지로 제공</p><ul><li>조인 전략 : @Inheritance(strategy=InheritanceType.JOINED)</li><li>단일 테이블 전략 : @Inheritance(strategy=InheritanceType.SINGLE_TABLE)</li><li>구현 클래스마다 테이블 전략 : @Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)</li></ul><h2 id="조인-전략"><a href="#조인-전략" class="headerlink" title="조인 전략"></a>조인 전략</h2><p><img src="https://lh3.googleusercontent.com/qhkotbW50hmApzamYVeWxxluUd5CUwUb64sFKze6ddIGLtwEXpQAARfDure2sNzIVatLwm0QRbNuqqxNkzdBLTBnzR4QCxlCINWg-T9DYFYkaJ_XmAgmUrZaMZRmmLe-VH8qoxMF" alt="JPA_Ex7_2.png"></p><p><img src="https://lh6.googleusercontent.com/T5atnTM9sbabH_-mrJK1UQjHM_ZQfkXVCQRNCwjrh7GH8NHLdu4_uyirJCjpSxCY0lQMOXt-S4mg1ePC84trF6Vq2ZWEz5VT1446X3vPEHuYo9g5N28P_J2P-jNE8rdunOI8ZySH" alt=""></p><p><img src="https://lh5.googleusercontent.com/orXf3maC0IxF-yGh7i_kDEsG6SL0k0QlIdYlqYxihiRvyxiG2IrvR9gBn-BDhQSViegSff1JlSEUvpSa7dIwcRuRnyuRiUaNbLBzq0ItbnWZKFCYc7wlmOLSne6GV-kIUKW7P_XH" alt=""></p><p><img src="https://lh4.googleusercontent.com/zY8uB7N_1z8gxJ6oAbYrZRb35B7nA-KlH1J9WzAJ_vUt_stGwb7kG_D3_i0vOOZNe3_fz7EkOcg17I6qUowAwSQoxpPw7_UXCtMCqtIBLjFeAzPq2-udjB021Wj9rGT-7XHGZavz" alt=""></p><p><img src="https://lh5.googleusercontent.com/P81lE4xCJuzQaN5v5Xg-VBnMJn3K64t_HAW0MA7Acb0iJXiItk4x0g7sUk7oGCuMVe76t_tBdQM3X7oNzW1X5HP9Zj23EECG65PoIVSep_IyMO3ID8rotRDKzBQA_-JkABMwCDMX" alt=""></p><p>부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략<br>객체는 타입이 있지만 테이블은 없기에 DTYPE 이라는 컬럼을 구분 컬럼으로 사용해야함</p><h2 id="단일-테이블-전략"><a href="#단일-테이블-전략" class="headerlink" title="단일 테이블 전략"></a>단일 테이블 전략</h2><p><img src="https://lh3.googleusercontent.com/BL90rKP26Z-pOloh-8ov-nrHPWs_vxEnn-Qs0wqfUeh7fPOZYn7IPbn1Z5YK4741_VYJ0Fh99aydF8AFYEihZVoSzlZ2s_W6TmiDc30syIK2zNOS8obOnLOLRHKQMvS3PYCXhjL5" alt="JPA_Ex7_3.png"></p><p><img src="https://lh3.googleusercontent.com/GPuTuXo48Qa7u9wQQevvc5gr35aPbxTG1XSS70b09iKcISNMDQzyiFW3vIB7oEm2eF3FoGZjV9U1y6e2X_k9jdhG9n7uFdVxXqz7EuT8vZPGwicSyJgFWj_gftlWUXU9tMRN84DO" alt=""></p><p><img src="https://lh5.googleusercontent.com/orXf3maC0IxF-yGh7i_kDEsG6SL0k0QlIdYlqYxihiRvyxiG2IrvR9gBn-BDhQSViegSff1JlSEUvpSa7dIwcRuRnyuRiUaNbLBzq0ItbnWZKFCYc7wlmOLSne6GV-kIUKW7P_XH" alt=""></p><p><img src="https://lh4.googleusercontent.com/zY8uB7N_1z8gxJ6oAbYrZRb35B7nA-KlH1J9WzAJ_vUt_stGwb7kG_D3_i0vOOZNe3_fz7EkOcg17I6qUowAwSQoxpPw7_UXCtMCqtIBLjFeAzPq2-udjB021Wj9rGT-7XHGZavz" alt=""></p><p><img src="https://lh5.googleusercontent.com/P81lE4xCJuzQaN5v5Xg-VBnMJn3K64t_HAW0MA7Acb0iJXiItk4x0g7sUk7oGCuMVe76t_tBdQM3X7oNzW1X5HP9Zj23EECG65PoIVSep_IyMO3ID8rotRDKzBQA_-JkABMwCDMX" alt=""></p><p>전략을 싱글테이블로 바꾸면된다.</p><p><img src="https://lh4.googleusercontent.com/7zgeTIdiAThVeKkCAGHOzniVHvqP2nGOIBxrqkV6ovjGLjy3Xyby40gAuAN_0lZDjufszlFK5J5Ent-HVxfmxIWCWmW9Ia_aoHE_t_rqaPQxUWt2h5Ur20YWUOawjQByexwDiYqH" alt=""></p><p>추가로 자식엔티티에서 기본키 칼럼명이 다르면 @PrimaryKeyJoinColumn을 쓴다.</p><h2 id="구현-클래스마다-테이블-전략"><a href="#구현-클래스마다-테이블-전략" class="headerlink" title="구현 클래스마다 테이블 전략"></a>구현 클래스마다 테이블 전략</h2><p><img src="https://lh3.googleusercontent.com/7qkqhiBRjOuzIjb11X6Qp6OPt7w6bkMCEZFhBHOYVLquDPjW14nWoX0OVTsby8Cc_xN9grBcCUWi1p9fh3pqYqujYiYDQDhmmxt9ZcOCoYDoN8KlHW4j4qAhsPThOvLjVSVsXt3u" alt="JPA_Ex7_4.png"></p><p><img src="https://lh3.googleusercontent.com/ZSxzpRR2wwkgIOMA9LNFhtMLNFNkuxK1hNCWGivRetqV5xWQhyf65vahnE_8UH0Rqyqc9T1SMpRvQBC2hUARtI43_M7z9zWFEXRyjkSqEZmn2clCBPOOr95xes1Pug-WSc5pj_dQ" alt=""></p><p><img src="https://lh3.googleusercontent.com/ASEnoYzIbhfryNr3dDgopQP4DDvTrpa4b4m0X-lJSkX-TAeQGLvwQsWuDbhowgoMSEwcUNIjZZH0lQHqxn0FszT4hGntuh7WBpt2g65XsJNKHQs-qZ-oJ2QJJD26X71TE3lsnoE3" alt=""></p><p><img src="https://lh3.googleusercontent.com/3xMJj7zH4ao41IpcRZFZkHBGQRH0cfzrrjaE1ZdN_RQgiVb3N4H5muEpMlGySIkBOGPWLXjcKu8Tc7b-KTkskreZJkKIoSTscbmNBv5oLESMJgL3GIx_Nl72ukl6M8HgQOekm6Ck" alt=""></p><p><img src="https://lh6.googleusercontent.com/BlvJM-OyrB9l7DuYzomKnMSLPlGQyY_rM4QHLQyVgaVPY8DuBWv5aVOJjp-HorNyvldGGYtg1Asn4wkRZjw3lOSmpHq0t052y3aV7CrzcozceQH5ACX7IZhD81x0q5KFfdB58bQf" alt=""></p><p>이전략은 이름도 길어서 제일 안쓸거 같다.. 책에서는 데이터베이스 설계자와 ORM 전문가 둘 다 추천하지 않은 전략이라고 함</p><h1 id="7-2-MappedSuperclass"><a href="#7-2-MappedSuperclass" class="headerlink" title="7.2 @MappedSuperclass"></a>7.2 @MappedSuperclass</h1><p>7.1에선 테이블과의 상속관계를 다뤘는데 이건 순수히 객체의 상속만을 할땐 @MappedSuperclass를 씀 추상 클래스와 비슷하다고 생각하면 됨</p><p><img src="https://lh5.googleusercontent.com/Dk8hGT_YGKzn7zKWLOWBsuID4F0iaG4MeRSvvwu1278cWQVtlQ_bTUfmrxqb2QN5JqH3wYLAevw-g-sGNNXW5dE0Kn8p-C4acNwLK7TESbu-4ZQJLca0JAIdULKrFdB8fWHbLpye" alt="Copy of Untitled Diagram.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"><span class="comment">//ID 상속</span></span><br><span class="line"><span class="comment">//NAME 상속</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@AttributeOverride</span>(name=<span class="string">"id"</span>, column=<span class="meta">@Column</span>(<span class="string">"MEMBER_ID"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seller</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"><span class="comment">//ID 상속</span></span><br><span class="line"><span class="comment">//NAME 상속</span></span><br><span class="line"><span class="keyword">private</span> String shopName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AttributeOverride</span></span><br><span class="line"><span class="meta">@AttributeOverrides</span></span><br></pre></td></tr></table></figure><p>어노테이션을 통해 상속받은 칼럼명을 재정의 할수도 있음.</p><h1 id="7-3-복합-키와-식별-관계-매핑"><a href="#7-3-복합-키와-식별-관계-매핑" class="headerlink" title="7.3 복합 키와 식별 관계 매핑"></a>7.3 복합 키와 식별 관계 매핑</h1><p><img src="https://lh4.googleusercontent.com/AjeFwgRZIzKPOtTUU7BA4c4XslYOYtKyi31Ds_pr4K5rQi6VmzMR4V6ajzSzAeUr4rhy3CzEJt7AQ90gUylMTi7oA6Y-f1sJYgpMtnazY_Ox9dJfbfTkYLxlKQgf6Jwbwo-xEjpo" alt="JPA_7_6.png"></p><p>식별 관계</p><p><img src="https://lh3.googleusercontent.com/P5JfoFJHZTQPIoaX8QVyQVLG0ZSAfaenz9rFNO-6imhLHct1Z0PXOHmtCWex9EJEDEt42KXV-BIVKEz_VtmtCdtQalw5ufH7DW3nWAIb9wawTGmfVEjYeyj_5dNpqoCcur2FWXR4" alt="JPA_7_7.png"></p><p>비식별 관계</p><p>@IdClass와 @EmbeddedId 방식 2가지가 존재 한다.</p><p>@IdClass는 테이블 친화적이고 @EmbeddedId는 객체 친화적</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//식별관계 IdClass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@Column</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@IdClass</span>(ChildId.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line"><span class="keyword">public</span> Parent parent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@Column</span>(name=<span class="string">"CHILD_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> String ChildId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//자식ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="comment">//Child.parent 매핑</span></span><br><span class="line"><span class="keyword">private</span> String parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Child.childId 매핑</span></span><br><span class="line"><span class="keyword">private</span> String childId;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equals, hashcode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span></span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumns</span>(&#123;</span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line">,<span class="meta">@JoinColumn</span>(name=<span class="string">"CHILD_ID"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">private</span> Child child;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@Column</span>(name=<span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//손자 ID</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="comment">//GrandChild.child 매핑</span></span><br><span class="line"><span class="keyword">private</span> ChildId child;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GrandChild.id 매핑</span></span><br><span class="line"><span class="keyword">private</span> String Id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equals, hashcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//식별관계 EmbeddedId</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@Column</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>&#123;</span><br><span class="line"><span class="meta">@EmbeddedId</span></span><br><span class="line"><span class="keyword">private</span> ChildId id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ChildId.prentId 매핑</span></span><br><span class="line"><span class="meta">@MapsId</span>(<span class="string">"prentId"</span>)</span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line"><span class="keyword">public</span> Parent parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//자식ID</span></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="comment">//@MapsId("parentId")로 매핑</span></span><br><span class="line"><span class="keyword">private</span> String parentId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"CHILD_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equals, hashcode</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span></span>&#123;</span><br><span class="line"><span class="meta">@EmbeddedId</span></span><br><span class="line">GrandChildId id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GrandChildId.childId 매핑</span></span><br><span class="line"><span class="meta">@MapsId</span>(<span class="string">"childId"</span>)</span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumns</span>(&#123;</span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line">,<span class="meta">@JoinColumn</span>(name=<span class="string">"CHILD_ID"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Child child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//손자 ID</span></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChildId</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="comment">//@MapsId("childId") 매핑</span></span><br><span class="line"><span class="keyword">private</span> ChildId childId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> String Id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//equals, hashcode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//비식별 관계</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span></span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"CHILD_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ChildId.prentId 매핑</span></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"PARENT_ID"</span>)</span><br><span class="line"><span class="keyword">public</span> Parent parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrandChild</span></span>&#123;</span><br><span class="line"><span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="meta">@Column</span>(name=<span class="string">"GRANDCHILD_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"CHILD_ID"</span>)</span><br><span class="line"><span class="keyword">private</span> Child child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>식별 관계인 경우는 복합키가 필요함으로 키관련 클래스들도 생성해야 하지만 비식별관계는 키가 1개임으로 복합키클래스를 만들 필요가 없다.</p><p>참고로 키가 1개일 경우만 @GeneratedValue 를 사용할수 있다.</p><p>책에서는 비식별 관계를 사용하고 기본 키는 LONG 타입의 대리 키를 사용 하는것이 좋다고 소개 되어있습니다. 그 이유는 비즈니스와 관련이 없어 변경시에 유연한 대처가 가능 Long 타입의 경우 약 920경의 숫자를 담을수 있음.</p><p>나머지 조인테이블과 엔티티 하나에 여러 테이블 매핑이 있지만 비주류라서 소개 하지 않겠습니다.</p><p>출처 : 자바 ORM 표준 JPA 프로그래밍 김영한</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;상속 관계 매핑: 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지 다룬다.&lt;/li&gt;
&lt;li&gt;@MappedSuperclass: 등록일, 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고 싶으면 이 기능을 사용하면 된다.&lt;/li&gt;
&lt;li&gt;복합 키와 식별 관계 매핑: 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법을 다룬다. 그리고 데이터베이스 설계에서 이야기하는 식별 관계와 비식별 관계에 대해서도 다룬다.&lt;/li&gt;
&lt;li&gt;조인 테이블: 테이블은 외래 키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결 테이블을 두는 방법도 있다. 여기서는 이 연결 테이블을 매핑하는 방법을 다룬다.&lt;/li&gt;
&lt;li&gt;엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있다. 여기서는 이 매핑 방법을 다룬다.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>엔티티의 연관관계 매핑시 고려할거 정리</title>
    <link href="http://kji6252.github.io/2017/01/15/jpa-basic-05/"/>
    <id>http://kji6252.github.io/2017/01/15/jpa-basic-05/</id>
    <published>2017-01-15T13:58:00.000Z</published>
    <updated>2021-04-02T02:38:07.048Z</updated>
    
    <content type="html"><![CDATA[<p>고려할건 크게 3가지다.</p><ul><li>다중성</li><li>단방향, 양방향</li><li>연관관계의 주인</li></ul><p>다중성 : 두 엔티티의 연관관계를 나타냄 (예: 일대다,다대일,일대일,다대다) 다중성을 판단하기 힘들땐 반대방향을 생각하면 됨 (일대다의 반대는 다대일)</p><ul><li>다대일(@ManyToOne)</li><li>일대다(@OneToMany)</li><li>일대일(@OneToOne)</li><li><p>다대다(@ManyToMany)</p><a id="more"></a><p>단방향, 양방향</p></li><li><p>객체의 참조용필드를 한쪽만 가지고 조회하면 단방향</p></li><li>객체의 참조용필드를 양쪽에 가지고 조회하면 양방향</li><li>데이터베이스 테이블은 외래키로 조회를하기에 방향이 없다.</li></ul><p>연관관계의 주인 : JPA는 두 객체 연관관계 중 하나를 정해서 데이터베이스 외래 키를 관리하는데 이것을 연관관계의 주인이라 한다.</p><ul><li>외래 키를 가진 테이블과 매핑한 엔티티가 외래 키를 관리하는 게 효율적이므로 보통 이곳을 연관관계의 주인으로 선택한다.</li><li>연관관계의 주인이 아닌곳은 mappedBy를 써서 연관관계의 주인 필드 이름값을 입력해야 한다.</li></ul><p>출처 : 자바 ORM 표준 JPA 프로그래밍 김영한</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;고려할건 크게 3가지다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다중성&lt;/li&gt;
&lt;li&gt;단방향, 양방향&lt;/li&gt;
&lt;li&gt;연관관계의 주인&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다중성 : 두 엔티티의 연관관계를 나타냄 (예: 일대다,다대일,일대일,다대다) 다중성을 판단하기 힘들땐 반대방향을 생각하면 됨 (일대다의 반대는 다대일)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다대일(@ManyToOne)&lt;/li&gt;
&lt;li&gt;일대다(@OneToMany)&lt;/li&gt;
&lt;li&gt;일대일(@OneToOne)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;다대다(@ManyToMany)&lt;/p&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>연관관계 기초</title>
    <link href="http://kji6252.github.io/2017/01/15/jpa-basic-04/"/>
    <id>http://kji6252.github.io/2017/01/15/jpa-basic-04/</id>
    <published>2017-01-15T00:14:00.000Z</published>
    <updated>2021-04-02T02:38:07.048Z</updated>
    
    <content type="html"><![CDATA[<ul><li>객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표다.* </li></ul><h2 id="핵심-키워드"><a href="#핵심-키워드" class="headerlink" title="핵심 키워드"></a>핵심 키워드</h2><ul><li>방향(Direction): [단방향, 양방향]이 있다. 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.</li><li>다중성(Multiplicty): [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)] 다중성이 있다.</li><li>연관관계의 주인(Owner): 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.</li></ul><a id="more"></a><h1 id="5-1-단방향-연관관계"><a href="#5-1-단방향-연관관계" class="headerlink" title="5.1 단방향 연관관계"></a>5.1 단방향 연관관계</h1><p><img src="https://lh3.googleusercontent.com/tsFHJw7DMbEwVx5FW6vnITNwv50vgWy3ZfSIvn6y4RLHDpZhf4Sjo9WUt-JqBJJt0iSm-RxLDe82Hi5nJ9Wg25oocilkdCUJETUn1WXPgG_djddhrulrVu5SKAqjkfPl3k4Wygce" alt="JPAEx5.png"></p><ul><li>객체 연관관계 : 회원 객체는 Member.team 필드(멤버변수)로 팀 객체와 연관관계를 맺는다. (단방향)</li><li>테이블 연관관계 : 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺는다. (양방향)</li></ul><h2 id="객체-연관관계와-테이블-연관관계의-가장-큰-차이"><a href="#객체-연관관계와-테이블-연관관계의-가장-큰-차이" class="headerlink" title="객체 연관관계와 테이블 연관관계의 가장 큰 차이"></a>객체 연관관계와 테이블 연관관계의 가장 큰 차이</h2><p>참조를 통한 연관관계는 언제나 단방향이다. 객체간에 연간관계를 양방향으로 만들고 싶으면 반대쪽에도 필드를 추가해서 참조를 보관해야 한다. 결국 연관관계를 하나 더 만들어야 한다. 이렇게 양쪽에서 서로 참조하는 것을 양방향 연관관계라 한다. 하지만 정확히 이야기하면 이것은 양방향 관계가 아니라 서로 다른 단방향 관계 2개다. 반면에 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.</p><h1 id="5-1-3-객체-관계-매핑"><a href="#5-1-3-객체-관계-매핑" class="headerlink" title="5.1.3 객체 관계 매핑"></a>5.1.3 객체 관계 매핑</h1><p><img src="https://lh3.googleusercontent.com/LWQnn2t9XiTo3s50XQflfgaI9B7E2OLoAPa0EsjeagvTCE6PjJJPNd5an4J9M52jtbamTVvZKT1llzxGTF9xdzwoUgTskIUzUVkq2fXjMDdFeVrA4sjAI7gsedrZ6wOtGkCieeYC" alt="JPAEx5_2.png"><br><img src="https://lh6.googleusercontent.com/L5TGN1r-Or_T4pR2vmq0mBuYU5p3-8ThfT3HlaCHesUQBQWInBv4pV5McTSEQA8zRLYlm3h3dICuB3Zh2TdXhSr0x2cRuumbPUDD_Q_amhj3hWu7AmNQsRyIENUUShArQ0hqfDYi" alt=""><br><img src="https://lh5.googleusercontent.com/y_98NYwiMx3pdv1u2wvWtYPPaH9eUeD2cFcWRqk3aVpYUEmEZp9vYUia2p2vK-86KSoWmctsDErG2XXzopNNTXxi2ZdW3f5F2b9EwU1HTDa5G_8y5hgP8biXQNpfpRL97qgD_nNd" alt=""></p><ul><li>객체 연관관계: 회원 객체의 Member.team 필드 사용</li><li>테이블 연관관계: 회원 테이블의 MEMBER.TEAM_ID 외래 키 컬럼을 사용</li><li>@ManyToOne: 이름 그대로(N:1) 관계라는 매핑 정보다. 회원과 팀은 다대일 관계다. 연관관계를 매핑할 때 이렇게 다중성을 나타내는 어노테이션을 필수로 사용해야 한다.</li><li>@JoinColumn: 조인 컬럼은 외래 키를 매핑할 때 사용한다. name 속성에는 매핑할 외래 키 이름을 지정한다. 회원과 팀 테이블은 TEAM_ID 외래 키로 연관관계를 맺으므로 이 값을 지정하면 된다. 이 어노테이션은 생략할 수 있다.</li></ul><h1 id="5-3-양방향-연관관계"><a href="#5-3-양방향-연관관계" class="headerlink" title="5.3 양방향 연관관계"></a>5.3 양방향 연관관계</h1><p><img src="https://lh6.googleusercontent.com/aCeR3Jrxq3Sd5B0hS-tgodsmKRi059sZ87CvdWL4M3ZSlv5tqbir_LWpBzu-qW9mPfN5C9IIT11FWv8cDlQzmvu8z5NUkK14JfICWqXvL7kTMruxqeMLN1k7rk0eOWsOlAWhGQcS" alt="JPAEx5_3.png"></p><p>단방향 연관관계에서 Team 객체에 List members를 추가 하였다.</p><p><img src="https://lh5.googleusercontent.com/uqAY0CC6EHRRtWxO21DOJxbMJOjMTNPLcgHKpx1iqTpBR5D7qu2g5Mz8OHRo6KkX9olYlf8mwP5MG4VGqMvVYFAS_G-_RVE1inCzTlfBCdPbMxWIySH1NGI_9BL4nVsGaBQOJOJg" alt=""></p><p>Member에서는 @ManyToOne을 했으므로 반대편인 Team에서는 @OneToMany를 주어 양방향 연관관계를 지정 하였다.</p><p>엄밀히 이야기하면 양방향 연관관계 라는 것은 없다. 서로 다른 단방향 연관관계 2개를 잘 묶어 양방향인 것처럼 보이게 할 뿐이다.</p><p>엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 외래 키는 하나다. 따라서 둘 사이에 차이가 발생한다.</p><p>두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인 이라 한다.</p><h2 id="연관관계-주인에-대해"><a href="#연관관계-주인에-대해" class="headerlink" title="연관관계 주인에 대해"></a>연관관계 주인에 대해</h2><p>연관관계의 주인이 아닌쪽에 mappedBy 속성을 넣어줘서 주인이 아님을 표시 하면 된다.</p><p>연관관계의 주인은 외래키를 관리 하며 등록,수정,삭제가 가능하고 아닌쪽은 읽기만 가능하다.</p><table><thead><tr><th>기능\연관관계</th><th>주인</th><th>주인X</th></tr></thead><tbody><tr><td>읽기</td><td>O</td><td>O</td></tr><tr><td>등록,수정,삭제</td><td>O</td><td>X</td></tr><tr><td>외래키</td><td>O</td><td>X</td></tr></tbody></table><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><p>데이터베이스 테이블의 다대일, 일대다 관계에서는 항상 다 쪽이 외래 키를 가진다. 다 쪽인 @ManyToOne은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다. 따라서 @ManyToOne에는 mappedBy 속성이 없다.</p><h2 id="연관관계-기초-정리"><a href="#연관관계-기초-정리" class="headerlink" title="연관관계 기초 정리"></a>연관관계 기초 정리</h2><p>양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것뿐이다.</p><ul><li>단방향 매핑만으로 테이블과 객체의 연관관계 매핑은 이미 완료 되었다.</li><li>단방향을 양방향으로 만들면 반대방향으로 객체 그래프 탐색 기능이 추가된다.</li><li>양방향 연관관계를 매핑하려면 객체에서 양쪽 방향을 모두 관리해야 한다.</li></ul><p>출처 : 자바 ORM 표준 JPA 프로그래밍 김영한</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;객체의 참조와 테이블의 외래 키를 매핑하는 것이 이 장의 목표다.* &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;핵심-키워드&quot;&gt;&lt;a href=&quot;#핵심-키워드&quot; class=&quot;headerlink&quot; title=&quot;핵심 키워드&quot;&gt;&lt;/a&gt;핵심 키워드&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;방향(Direction): [단방향, 양방향]이 있다. 한 쪽만 참조하는 것을 단방향 관계라 하고, 양쪽 모두 서로 참조하는 것을 양방향 관계라 한다. 방향은 객체관계에만 존재하고 테이블 관계는 항상 양방향이다.&lt;/li&gt;
&lt;li&gt;다중성(Multiplicty): [다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)] 다중성이 있다.&lt;/li&gt;
&lt;li&gt;연관관계의 주인(Owner): 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>엔티티 매핑</title>
    <link href="http://kji6252.github.io/2016/08/10/jpa-basic-03/"/>
    <id>http://kji6252.github.io/2016/08/10/jpa-basic-03/</id>
    <published>2016-08-10T03:02:00.000Z</published>
    <updated>2021-04-02T02:38:07.048Z</updated>
    
    <content type="html"><![CDATA[<ul><li>객체와 테이블 매핑 : @Entity, @Table</li><li>기본 키 매핑 : @Id</li><li>필드와 컬럼 매핑 : @Column</li><li>연관관계 매핑 : @ManyToOne, @JoinColumn</li></ul><p>@Entity(클래스) : 테이블과 매핑할 클래스, JPA가 관리함</p><p>@Table(클래스) : 엔티티와 매핑할 테이블 (생략시 엔티티명으로 적용)</p><ul><li>uniqueConstraints(DDL) : DDL생성시 유니크 제약조건 만듬.</li></ul><p>@Column(필드) : 칼럼을 매핑한다.<br><a id="more"></a></p><ul><li>nullable(DDL) : false 시 not null 기본값(true)</li><li>length(DDL) : 문자 길이 제약조건, String 타입에만 사용한다. 기본값(255)</li><li>precision,scale(DDL) : BigDecimal(BigInteger) 타입 사용 precision은 소수점 포함 전체길이, scale은 소수의 자릿수 double,float엔 적용 안됨</li></ul><p>@Enumerated(필드) : 자바의 enum 타입을 매핑한다.</p><ul><li>EnumType.ORDINAL enum 순서를 DB 저장 (0,1,2,3)</li><li>EnumType.STRING enum 이름을 DB 저장 (COUNT,ID,AGE)</li></ul><p>@Temporal(필드) : 날짜 타입을 매핑한다.</p><ul><li>TemporalType.DATE (yyyy-mm-dd)</li><li>TemporalType.TIME (HH-MM-ss)</li><li>TemporalType.TIMESTAMP (yyyy-mm-dd HH-MM-ss)</li></ul><p>@Lob(필드) : BLOB, CLOB 타입을 매핑한다.(속성없이 자바타입으로 결정)</p><ul><li>CLOB : String, char[], java.sql.CLOB</li><li>BLOB : byte[], java.sql.BLOB</li></ul><p>@Transient(필드) : 특정 필드를 데이터베이스에 매핑하지 않는다.</p><h1 id="데이터베이스-스키마-자동-생성"><a href="#데이터베이스-스키마-자동-생성" class="headerlink" title="데이터베이스 스키마 자동 생성"></a>데이터베이스 스키마 자동 생성</h1><p>persistence.xml 에 create, create-drop, update, validate, none 등의 값을 삽입 할수 있다.</p><p>개발이나 테스트에서 쉽게 디비스키마를 자동 생성할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.hbm2ddl.auto"</span> <span class="attr">value</span>=<span class="string">"create"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>create : drop create 실행</li><li>create-drop : drop create drop 실행</li><li>update : 변경분만 적용 (테이블 추가, 칼럼추가, 제약조건 추가 등)</li><li>validate : 디비정보와 비교하여 다를시 프로그램 종료</li><li>none : 아무일도 하지 않음</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.ejb.naming_strategy"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.cfg.ImprovedNamingStrategy"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>이 옵션 추가시 자바에선 카멜식 디비에선 언더스코어 표기법으로 매핑 된다.</p><h2 id="엔티티-매핑-정리"><a href="#엔티티-매핑-정리" class="headerlink" title="엔티티 매핑 정리"></a>엔티티 매핑 정리</h2><ul><li>이 장을 통해 객체와 테이블 매피으 기본키 매핑, 필드와 컬럼매핑에 대해 알아보았다. 그리고 데이터베이스 스키마 자동 생성하기 기능도 알아보았는데, 이 기능을 사용하면 엔티티 객체를 먼저 만들고 테이블은 자동으로 생성할 수 있다.</li><li>JPA는 다양한 기본 키 매핑 전략을 지원한다. 기본 키를 애플리케이션에서 직접 할당하는 방법부터 데이터베이스가 제공하는 기본 키를 사용하는 SEQUENCE, IDENTITY, TABLE 전략에 대해서도 알아보았다.</li><li>이 장에서 다룬 회원 엔티티는 다른 엔티티와 관계가 없다. 회원이 특정 팀에 소속해야 한다면 어떻게 해야 할가? 다음 장을 통해 연관관계가 있는 엔티티들을 어떻게 매핑하는지 알아보자.</li><li>그 전에 다음 실전 예제를 꼭 따라해보자. 실전 예제는 이 장에서 학습한 내용을 소화할 수 있게 도와준다. 그리고 JPA를 사용해서 실제 엔티티를 어떻게 모델링해야 할지 감을 잡을 수 있게 해준다. 실전 예제의 도메인 모델은 각 장을 진행할 때마다 점진적으로 성장한다. 그리고 이렇게 완성한 도메인 모델로 11장의 웹 애플리케이션을 개발한다. 그러므로 실전 예제는 꼭 실행해보자.</li></ul><p>출처 : 자바 ORM 표준 JPA 프로그래밍 (김영한)</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;객체와 테이블 매핑 : @Entity, @Table&lt;/li&gt;
&lt;li&gt;기본 키 매핑 : @Id&lt;/li&gt;
&lt;li&gt;필드와 컬럼 매핑 : @Column&lt;/li&gt;
&lt;li&gt;연관관계 매핑 : @ManyToOne, @JoinColumn&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;@Entity(클래스) : 테이블과 매핑할 클래스, JPA가 관리함&lt;/p&gt;
&lt;p&gt;@Table(클래스) : 엔티티와 매핑할 테이블 (생략시 엔티티명으로 적용)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;uniqueConstraints(DDL) : DDL생성시 유니크 제약조건 만듬.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;@Column(필드) : 칼럼을 매핑한다.&lt;br&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
  <entry>
    <title>영속성 관리</title>
    <link href="http://kji6252.github.io/2016/08/10/jpa-basic-02/"/>
    <id>http://kji6252.github.io/2016/08/10/jpa-basic-02/</id>
    <published>2016-08-10T02:42:00.000Z</published>
    <updated>2021-04-02T02:38:07.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ul><li>EntityManagerFactory : EntityManager를 만드는 공장. 애플리케이션에서 persistens.xml의 persistens-unit갯수 만큼만 있어야함</li><li>EntityManager : 요청이 올때마다 생성 해도 됨.(커넥션풀에서 커넥션 한개씩 이라고 생각해도 될듯)</li></ul><p><img src="https://user-images.githubusercontent.com/6037055/43312616-d026e46c-91c8-11e8-91d3-4d547753a096.png" alt="persistencecontext4"></p><ul><li>persistence context(영속성 컨텍스트) : ‘엔티티를 영구 저장하는 환경’ </li></ul><h1 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h1><ul><li>영속 상태인 엔티티는 식별자 값이 반드시 있어야 한다. (식별자 값이없으면 예외 발생)</li><li><p>트랜잭션 커밋 하는 순간 DB 반영힘 이를 플러시(flush)라 함</p><a id="more"></a><h1 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h1></li><li><p>1차 캐시 : 영속성 컨텍스트에서 맵형태로 id(식별자)와 엔티티를 관리</p></li><li>동일성 : 1차 캐시에 있는 같은 엔티티를 반환 함으로 동일성 보장(==)</li><li>트랜잭션을 지원 하는 쓰기 지연 : 커밋 전까지 inser,update,delete문을 쓰기 지연 SQL 저장소에 담아두고 한번에 내보낸다.</li><li>변경 감지 : 최초 상태를 복사(스냅샷) 해두는데 이를 비교하여 변경을 감지함 변경이 감지되면 해당 엔티티로 update 문을 DB에 보냄</li><li>지연 로딩 : 연관관계로 매핑된 엔티티의 경우 조회할때 데이터를 가져옴</li></ul><h1 id="엔티티-생명주기"><a href="#엔티티-생명주기" class="headerlink" title="엔티티 생명주기"></a>엔티티 생명주기</h1><ul><li>비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태</li><li>영속(managed) : 영속성 컨텍스트에 저장된 상태</li><li>준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태</li><li>삭제(removed) : 삭제된 상태</li></ul><p><img src="https://user-images.githubusercontent.com/6037055/43312618-d0f2098a-91c8-11e8-848a-ec98ac16e049.png" alt="entitylife"></p><h1 id="영속성-관리-정리"><a href="#영속성-관리-정리" class="headerlink" title="영속성 관리 정리"></a>영속성 관리 정리</h1><ul><li>엔티티 매니저는 엔티티 매니저 팩토리에서 생성한다. 자바를 직접 다루는 J2SE환경에서는 엔티티 매니저를 만들면 그 내부에 영속성 컨텍스트도 함께 만들어진다. 이 영속성 컨텍스트는 엔티티 매니저를 통해서 접근할 수 있다.</li><li>영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다. 영속성 컨텍스트 덕분에 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연로딩 기능을 사용할 수 있다.</li><li>영속성 컨텍스트에 저장한 엔티티는 플러시 시점에 데이터베이스에 반영되는데 일반적으로 트랜잭션을 커밋할 때 영속성 컨텍스트가 플러시 된다.</li><li>영속성 컨텍스트가 관리하는 엔티티를 영속 상태의 엔티티라 하는데, 영속성 컨텍스트가 해당 엔티티를 더 이상 관리하지 못하면 그 엔티티는 준영속 상태의 엔티티라 한다. 준영속 상태의 엔티티는 더는 영속성 컨텍스트가 제공하는 1차 캐시, 동일성 보장 트랜잭션을 지원하는 쓰기 지연, 변경감지, 지연 로딩 같은 기능들을 사용할 수 없다.</li></ul><p>출처 : 자바 ORM 표준 JPA 프로그래밍 (김영한)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;EntityManagerFactory : EntityManager를 만드는 공장. 애플리케이션에서 persistens.xml의 persistens-unit갯수 만큼만 있어야함&lt;/li&gt;
&lt;li&gt;EntityManager : 요청이 올때마다 생성 해도 됨.(커넥션풀에서 커넥션 한개씩 이라고 생각해도 될듯)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/6037055/43312616-d026e46c-91c8-11e8-91d3-4d547753a096.png&quot; alt=&quot;persistencecontext4&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;persistence context(영속성 컨텍스트) : ‘엔티티를 영구 저장하는 환경’ &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;특징&quot;&gt;&lt;a href=&quot;#특징&quot; class=&quot;headerlink&quot; title=&quot;특징&quot;&gt;&lt;/a&gt;특징&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;영속 상태인 엔티티는 식별자 값이 반드시 있어야 한다. (식별자 값이없으면 예외 발생)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;트랜잭션 커밋 하는 순간 DB 반영힘 이를 플러시(flush)라 함&lt;/p&gt;
    
    </summary>
    
      <category term="JPA" scheme="http://kji6252.github.io/categories/JPA/"/>
    
    
      <category term="Java" scheme="http://kji6252.github.io/tags/Java/"/>
    
      <category term="JPA" scheme="http://kji6252.github.io/tags/JPA/"/>
    
      <category term="ORM" scheme="http://kji6252.github.io/tags/ORM/"/>
    
  </entry>
  
</feed>
